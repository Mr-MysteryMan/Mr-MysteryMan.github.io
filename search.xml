<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>编译原理知识点整理</title>
    <url>/2025/03/15/Compiler/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h1><h2 id="第一章-概论"><a href="#第一章-概论" class="headerlink" title="第一章 概论"></a>第一章 概论</h2><ol>
<li><p>低级语言：字位码、机器语言、汇编语言。与特定机器有关，功效高但使用复杂且易出错。</p>
<p>高级语言：C、Java等语言。不依赖具体机器，移植性好易维护。</p>
</li>
<li><p>源程序：汇编或高级语言编写的待翻译程序；</p>
<p>目标程序：目标语言编写的程序；</p>
<p>翻译程序：将源程序转换为目标程序的程序。</p>
</li>
<li><p>源程序使用汇编，目标程序是机器语言，此翻译程序就是汇编程序；源程序使用高级语言，此翻译程序就是编译程序。</p>
</li>
<li><p>编译过程指将高级语言程序翻译为目标语言程序的过程。</p>
</li>
<li><p>五个阶段：词法分析、语法分析、语义分析与生成中间代码、代码优化、生成目标程序。</p>
<p>七个逻辑部分：词法分析、语法分析、语义分析与生成中间代码、代码优化、生成目标程序、符号表管理、出错处理。</p>
</li>
<li><p>遍：对源程序（以及源程序中间形式）从头到尾扫描一次，并进行相应处理。</p>
</li>
<li><p>编译程序通常分为前端（分析，与源语言有关）和后端（综合，与目标机有关）。</p>
</li>
</ol>
<h2 id="第二章-文法与语言概念"><a href="#第二章-文法与语言概念" class="headerlink" title="第二章 文法与语言概念"></a>第二章 文法与语言概念</h2><ol>
<li><p>文法/语法：对语言结构的定义与描述。</p>
</li>
<li><p>语法规则：描述句子的语法结构的规则。</p>
<p>用 ::= 表示由什么组成。</p>
</li>
<li><p>最左推导：从最左的语法成分进行推导，类似有最右推导、一般推导。</p>
</li>
<li><p>语法树：推导为语法成分（非终结符），再推导为单词符号（终结符）。</p>
</li>
<li><p>文法定义：$G=(V_n,V_t,P,Z)$，$V_n$非终结符号集，$V_t$终结符号集，$P$规则集，$Z$开始符号/识别符号。</p>
</li>
<li><p>在文法G中，由式子v推导到式子w，记作 $v\underset{G}{\Rightarrow}w$ 。<font color=navy>实际上是任意符推任意符。</font></p>
</li>
<li><p>在文法G中，$u_0, u_1, … \in V^+$，若 $v\Rightarrow u_0\Rightarrow u_1\Rightarrow …\Rightarrow w$，记作 $v\overset{+}{\underset{G}{\Rightarrow}}w$ 。<font color=navy>实际上是多层推导，v一步不能到w。</font></p>
</li>
<li><p>在文法G中， $v\overset{+}{\underset{G}{\Rightarrow}}w$ ，推导符号下加文法G、上加正闭包+，或 $v=w$ ，记作 $v\overset{*}{\underset{G}{\Rightarrow}}w$ 。</p>
</li>
<li><p>规范推导：若$xUy \Rightarrow xuy$，且y是终结符号，则称作规范推导。（规范推导就是最右推导）</p>
</li>
<li><p>文法G[Z]，Z能推导到的任何串称为句型，Z能推导到的只含终结符的串称为句子，文法G[Z]产生的所有句子的集合称为语言。</p>
</li>
<li><p>文法G与G’为不同文法，若两个文法产生的语言相同，则称为等价文法。</p>
</li>
<li><p>递归规则：规则右部有与左部一致的非终结符。</p>
<p>对于$U::=xUy$，若$x=\varepsilon$，称为左递归；若$y=\varepsilon$，称为右递归；若$x,y\neq\varepsilon$，称为自嵌入递归。</p>
</li>
<li><p>递归文法：若$U\Rightarrow U…$，称为左递归文法；若$U\Rightarrow …U$，称为右递归文法；若$U\Rightarrow …U…$，称为递归文法。</p>
</li>
<li><p>短语：句型可以推导到的串，即任何非终结符所能推导出的最终字符串，不可含自身（简单短语是由一个非终结符一步推导出的只含终结符的字符串）</p>
</li>
<li><p>句柄：句型能够推导到的最左简单短语。</p>
</li>
<li><p>若一个文法的某句子存在两种不同的规范推导，则称该文法具有二义性。</p>
</li>
<li><p>有害规则：形如$U::=U$，会引起二义性。</p>
</li>
<li><p>多余规则： 该规则的左部非终结符不出现在任何句型中。（不可达符号）</p>
<p>​                    该规则中含有推不出任何终结符号串的非终结符。（不活动符号）</p>
</li>
<li><p>某文法中不含有害规则或多余规则，则称该文法是压缩过的。</p>
</li>
<li><p>文法语言分类：0型，1型，2型，3型</p>
<p>0型：短语结构文法，可以用图灵机接受；($u::=v,u\in V^+,v\in V^*$)</p>
<p>1型：上下文敏感或上下文有关，只有在左右为x、y的情况下可以完成推导，可以用线性界限自动机接受；($xUy::=xuy,U\in V_n,xyu\in V^*$)</p>
<p>2型：上下文无关，与BNF等价，可以用下推自动机接受；($U::=u,U\in V_n,u\in V^*$)</p>
<p>3型：正则文法，可以用有穷自动机接受；(左线性：$U::=t \;/\; U::=Wt,UW\in V_n,t\in V_t$，右线性：$U::=t \;/\; U::=tW,UW\in V_n,t\in V_t$)</p>
</li>
</ol>
<h2 id="第三章-词法分析"><a href="#第三章-词法分析" class="headerlink" title="第三章 词法分析"></a>第三章 词法分析</h2><ol>
<li><p>词法分析：根据此法规则识别及组合单词，进行词法检查。</p>
</li>
<li><p>单词种类：保留字（for，begin，end，do）、标识符（函数变量名称）、常数、分界符（+-*/）</p>
</li>
<li><p>单词内部形式：</p>
<ul>
<li><p>按单词种类分类：类别编码+单词值</p>
</li>
<li><p>保留字和分界符采用一符一类</p>
<p><img src="E:\文件\照片\markdown图片集\编译原理\保留字和分界符采用一符一类.png" alt="保留字和分界符采用一符一类" style="zoom: 67%;" /></p>
</li>
<li><p>标识符和常数的单词值又为指示字</p>
</li>
</ul>
</li>
<li><p>状态图： 状态以圆表示，箭头由规则右侧状态指向规则左侧状态，箭头上写转移时的终结符。</p>
<p>​                初始状态以S表示，其表示推导的最终结果（仅存在终结符）</p>
<p>​                文法G[Z]初始语句Z以状态Z表示，其外围两圈圆，内圆为虚线</p>
</li>
<li><p>词法分析中使用的全局变量和过程：</p>
</li>
</ol>
<p><img src="/images/Compiler/编译原理/词法分析全局变量.png" alt="词法分析全局变量" style="zoom:67%;" /></p>
<ol>
<li>正则文法：左线性文法 + 右线性文法</li>
</ol>
<h2 id="第四章-语法分析"><a href="#第四章-语法分析" class="headerlink" title="第四章 语法分析"></a>第四章 语法分析</h2><ol>
<li><p>自顶向下：给定符号串，遵照文法尝试对其建立语法树。</p>
</li>
<li><p>存在问题：左递归文法、需要回溯</p>
</li>
<li><p>左递归消除：</p>
<ul>
<li>使用扩充BNF表示改写文法：提因子（$E::=Ac\,|\,Bc \Rightarrow E::=(A\,|\,B)c$），递归文法改写（$E::=E+T\,|\,T \Rightarrow E::=T{+T}$）；</li>
<li>将左递归文法改写为右递归文法。</li>
</ul>
</li>
<li><p>回溯问题：分析工作需要部分或全部退回去。</p>
</li>
<li><p>回溯问题不发生的充要条件：</p>
<p>定义$FIRST(\beta) = {c\,|\,\beta\overset{<em>}{\Rightarrow}c\,…,c\in V_t}$，$FOLLOW(A)={c\,|\,Z\overset{</em>}{\Rightarrow}\,…Ac\,…,c\in V_t}$。对于G的每一个满足$A::=\alpha\,|\,\beta$的非终结符A都应存在$FIRST(\alpha)\cap FIRST(\beta) = \varnothing$ 及$FIRST(\alpha)\cap FOLLOW(A) = \varnothing$（若$\beta\overset{*}{\Rightarrow}\epsilon 空字符$）。</p>
</li>
<li><p>回溯问题消除：多次改写和提因子，最终使得分析过程满足不需要回溯的冲要条件；超前扫描：向前多侦察多个字符，以确定文法选择。</p>
</li>
<li><p>分析程序主要使用方法：递归下降法</p>
</li>
</ol>
<h2 id="第五章-符号表"><a href="#第五章-符号表" class="headerlink" title="第五章 符号表"></a>第五章 符号表</h2><ol>
<li><p>符号表：编译过程中，编译程序用来记录源程序中各种名字的特性信息，也称名字特性表。</p>
</li>
<li><p>常见符号：程序名、过程名、函数名、用户定义类型名、变量名、常量名、枚举值名、标号名等。</p>
<p>常见信息：种类、类型、维数、参数个数、数值、存储单元地址等。</p>
</li>
<li><p>各种标识符通过声明存入符号表（填表）；填表前检查是否重复定义，后续使用时需查询符号表标识符是否声明（查表）。</p>
</li>
<li><p>符号表结构：名字+特性</p>
</li>
<li><p>特性域：应该包含多个子域。</p>
<ul>
<li>普通标识符：种类（变量名、函数名）、类型（int/char）、性质（var/const）、值、地址、所占地址大小、作用域嵌套层次</li>
<li>数组：维数、上下界值、首元素地址、数组元素类型</li>
<li>记录（结构、联合）：域的个数、域名、地址位移、类型</li>
<li>过程、函数：形参个数、所在层次、返回值类型、局部变量所占空间大小</li>
<li>指针：所指对象类型</li>
</ul>
</li>
<li><p>组织方式：大部分共同信息按统一格式制表，部分特殊信息用指针连接。</p>
</li>
<li><p>非分程序结构语言：可独立编译的程序单元是一个不包含子模块的单一模块，如FORTRAN语言。</p>
</li>
<li><p>标识符按作用域不同分为全局局部，制成全局符号表、局部符号表。</p>
</li>
<li><p>子程序、函数名、公共区名填入全局符号表</p>
<p>子程序（函数）声明部分制造或填入局部符号表（本单元局部符号表，有同名：重复声明报错，无同名：造表）</p>
<p>语句部分读到标识符查表（本单元局部符号表及全局符号表，有同名：已声明，无同名：无定义报错）</p>
<p>程序单元结束释放该单元局部符号表，程序编译结束释放全部符号表。</p>
</li>
<li><p>符号表可为无序符号表、有序符号表、哈希表</p>
</li>
<li><p>分程序结构语言：模块内可嵌入子模块</p>
</li>
<li><p>标识符声明性出现建表（本层符号表，有同名：重复声明报错，无同名：填表）</p>
<p>标识符引用性出现查表（本层符号表，有同名：已声明，无同名：转到直接外层）</p>
<p>标准标识符（不必声明可全程使用，标准名及数目已知）初始化时建表并将名字表填入</p>
</li>
</ol>
<h2 id="第六章-运行时存储管理"><a href="#第六章-运行时存储管理" class="headerlink" title="第六章 运行时存储管理"></a>第六章 运行时存储管理</h2><ol>
<li><p>静态存储分配：在编译阶段有编译程序实现对存储空间的管理和为源程序中变量分配存储。</p>
<p>条件：在编译时能够确定变量在运行时的数据空间大小，且运行时不改变。</p>
</li>
<li><p>动态存储分配：在目标程序运行阶段由目标程序实现对对存储空间的管理和为源程序中变量分配存储。</p>
<p>特点：在目标程序运行时进行变量存储分配，编译时要生成进行动态分配的目标指令。</p>
</li>
<li><p>静态存储分配：</p>
<ul>
<li><p>分配策略：开辟数据区，为每个模块分配，在模块内按序分配，目标地址填入符号表</p>
</li>
<li><p>FORTRAN子程序（模块）典型数据区：</p>
<p>变量、返回地址、形式参数、临时变量</p>
<p><img src="/images/Compiler/编译原理/FORTRAN子程序典型存储结构.png" alt="FORTRAN子程序典型存储结构" style="zoom:50%;" /></p>
</li>
</ul>
</li>
<li><p>动态存储分配：编译时不能具体确定程序所需数据空间，编译程序生成有关存储分配的目标代码，实际分配在目标程序运行时进行。</p>
<p>分程序结构，且允许递归调用的语言：栈式动态存储分配</p>
<p>分配策略：整个数据区为一个堆栈，进入过程时，在栈顶分配数据区；退出过程时，撤销过程数据区。</p>
</li>
<li><p>典型活动记录可以分为三部分：局部数据区（各局部变量），参数区（显式隐式参数），display区（存放各外层模块活动记录的基地址）</p>
</li>
<li><p>参数区：显式参数：形参数据，出现在用户源程序中；隐式参数：prev abp（存放调用模块记录基地址，执行完后释放数据区，数据区指针指向调用前地址）、ret addr（返回地址，调用语句的下一条执行指令地址）、ret value（函数返回值）</p>
</li>
</ol>
<h2 id="第七章-源程序中间形式"><a href="#第七章-源程序中间形式" class="headerlink" title="第七章 源程序中间形式"></a>第七章 源程序中间形式</h2><ol>
<li><p>一般编译程序都是先生成中间代码，再生成目标代码，优点是可移植性（与具体目标程序无关）与可优化性。主要有三种中间代码表示形式：波兰表示，N元组表示，抽象机代码。</p>
</li>
<li><p>波兰表达式：前序后序中序表达式，$a+b \Rightarrow ab+$</p>
<p>算法：设立操作符栈。读到操作数时立即输出；读到操作符时，与栈顶操作符比较优先级，栈顶操作符优先级高/相同时栈顶操作符出栈，栈顶操作符优先级低时读入操作符入栈。</p>
</li>
<li><p>N元组表示：每条指令由N个域组成，通常第一个域表示操作符，其余表示操作数。（常用三元组四元组）</p>
<p>前序表达式，$a+b<em>c \Rightarrow (1)</em>,b,c \quad(2)+,a,(1)$</p>
</li>
<li><p>间接三元式：三元式不便优化，优化时会删除一些三元式，或对三元式顺序（编号）进行改变，但有些改变的三元式结果出现于其他三元式中，因此引入间接三元式。将三元式与三元式的执行顺序存储为两张表，优化时改变三元式执行顺序表。</p>
</li>
<li><p>四元式：操作符+操作数1+操作数2+结果</p>
<p>结果通常是由编译引入的临时变量，可由编译器分配一个寄存器或主存单元。</p>
</li>
<li><p>抽象机代码：P-code中间代码，主要操作寄存器，保存程序指令的存储器，堆栈式数据</p>
<p>使用的寄存器： PC: 程序计数器</p>
<p>​                            NP: New指针，指向存放由New生成的动态数据的堆顶端</p>
<p>​                            SP: 运行栈指针，存放所有可按源程序的数据声明直接寻址的数据</p>
<p>​                            BP: 基地址指针，指向当前活动记录的起始位置指针</p>
<p>​                            MP: 栈标志指针</p>
<p>​                            EP: 极限栈指针</p>
</li>
<li><p>抽象机所有操作都在运行栈的栈顶进行，顺序与波兰表达式相同</p>
</li>
<li><p>中间代码的图表示：</p>
<ul>
<li>语法树：操作数出现在叶结点，操作符出现在中间结点。</li>
<li>DAG图：Directed Acyclic Graphs有向无环图，语法树的一种归约表达形式（语法树中相同表达部分表示一次）</li>
</ul>
</li>
<li><p>三地址码：适合目标代码优化生成的表达形式，是语法树或DAG图的线性表示，树的中间结点由临时变量表示。</p>
</li>
</ol>
<h2 id="第八章-错误处理"><a href="#第八章-错误处理" class="headerlink" title="第八章 错误处理"></a>第八章 错误处理</h2><ol>
<li><p>错误分为两类：语法错误（不合文法）和语义错误（不合语义规则或超越系统限制）</p>
</li>
<li><p>语义规则：标识符先声明后引用；引用要符合作用域规定；调用时形参实参要一致；参与运算的操作数类型一致；下标变量下标不能越界。</p>
<p>超越系统限制：数据溢出错误；符号表、静态存储分配数据区溢出；动态存储数据区溢出。</p>
</li>
<li><p>错误诊察： 违反语法语义规则、超过编译系统限制的错误（语法语义分析时）</p>
<p>​                    下标越界、计算结果溢出、动态存储数据区溢出（目标程序运行时）</p>
</li>
<li><p>错误报告： 出错位置：行号计数器、单词序号计数器</p>
<p>​                    出错性质：文字信息、错误编码</p>
</li>
<li><p>错误处理技术：发现错误后，在报告错误的同时还要对错误进行处理，以便编译能继续进行。</p>
<p>错误改正：查出错误后，根据文法进行错误改正</p>
<p>错误局部化：尽可能将错误的影响限制在一个小范围内，避免错误扩散和影响程序其他部分分析。</p>
</li>
<li><p>局部化处理：</p>
<ul>
<li>一般原则：诊察到错误后停止对后面符号进行分析，跳过错误所在语法成分继续分析（一般是跳到语句右界符，从新语句开始分析）</li>
<li>局部化处理实现：递归下降法，出错后转存，并跳到正确部分分析。</li>
<li>提高错误局部化的方法：建立语法成分对应的合法后继符号集、停止符号集（跳读必须停止的符号）</li>
</ul>
</li>
<li><p>目标程序运行时错误检测与处理：较难确定出错位置，只需打印错误信息，保留寄存器储存器中的值</p>
</li>
</ol>
<h2 id="第九章-语法制导翻译技术"><a href="#第九章-语法制导翻译技术" class="headerlink" title="第九章 语法制导翻译技术"></a>第九章 语法制导翻译技术</h2><ol>
<li><p>程序语言的语义形式化描述有三种，操作语义、指称语义、公理语义。</p>
</li>
<li><p>翻译目标是将中缀表达式变为后缀表达式（逆波兰表示）。（只需在中缀表达文法中插入相应动作符号）</p>
</li>
<li><p>输入文法：未插入动作符号时的文法，可推导出输入序列。</p>
<p>翻译文法：插入动作符号后的文法，可推导出活动序列（输入序列/动作序列）。</p>
<blockquote>
<p>输入文法：$E \Rightarrow T + F \Rightarrow i + F \Rightarrow i + j$</p>
<p>翻译文法：$E \Rightarrow T + F@+ \Rightarrow i @i + F @+ \Rightarrow i @i + j @j @+$</p>
<p>其中，$@$为动作符号标记，代表一个动作，比如是打印其后字符串。</p>
</blockquote>
</li>
<li><p>活动序列：由翻译文法推导出的字符串，由终结符和动作符号组成。去除动作符号，可得输入序列；去除输入序列，可得动作序列。（执行动作序列即可完成翻译任务）</p>
<p>活动序列中的输入序列和动作序列构成对偶集。</p>
</li>
<li><p>语法制导翻译：给定输入字符串，根据翻译文法获得动作序列并完成动作的过程。</p>
</li>
<li><p>属性文法：在翻译文法基础上，为终结符、非终结符、动作符号加上属性（综合属性/继承属性）。</p>
</li>
<li><p>综合属性：$\uparrow c$ 代表该属性，$\uparrow$是综合属性标记，$c$是属性变量或属性值。根据文法自顶向下构建语法树，自底向上计算属性。</p>
<p>继承属性：$\downarrow c$ 代表该属性，$\downarrow$是继承属性标记，$c$是属性变量或属性值。可从之前得到，继承之前的值，自顶向下计算属性。</p>
</li>
<li><p>L属性翻译文法(L-TAG)：输入文法要求是LL(1)文法，可自顶向下构造分析器，分析过程中可进行属性求值。要求文法中的非终结符、终结符、动作符都需要存在属性，开始符号的继承属性和终结符号的综合属性有初值。继承属性自顶向下自左向右求值，综合属性自底向上自右向左求值。</p>
</li>
<li><p>简单赋值形式的L属性翻译文法(SL-TAG)：属性传递时除去动作符号，其余符号的属性只是简单的赋值关系，不存在复杂运算。</p>
<p>产生式右侧符号的继承属性等于左侧符号的继承属性或同右侧在其左边符号的综合属性。</p>
<p>产生式左侧符号的综合属性等于左侧符号的继承属性或右侧符号的综合属性。</p>
<blockquote>
<p>非SL-TAG文法：$A \Rightarrow B<em> {\uparrow R} C</em>{\uparrow S} D_{\downarrow I}$，其中$I:=f(R,S)$</p>
<p>SL-TAG文法：$A \Rightarrow B<em> {\uparrow R} C</em>{\uparrow S} @f<em>{\downarrow I_1, I_2\uparrow S_1} D</em>{\downarrow I}$，其中$I_1 := R, I_2 := S, S_1 = f(I_1, I_2),I := S_1$</p>
</blockquote>
</li>
<li><p>递归下降翻译器：翻译文法的自顶向下翻译。思路与输入文法的递归下降分析基本相同，只需按照翻译文法在过程中增加动作即可。</p>
</li>
<li><p>递归下降属性翻译器：属性文法的自顶向下翻译。对每个非终结符设置一个子程序，根据其具有属性数目设置相应参数。继承属性设置为赋值形参，综合属性设置为变量形参。</p>
<p>关于属性名：产生式左部同名非终结符使用相同属性名，具有相同值的属性取相同属性名。</p>
</li>
<li><p>过程调用函数实参，继承属性传递继承属性值，综合属性传递属性变量名（地址）。</p>
</li>
</ol>
<h2 id="第十章-语义分析和代码生成"><a href="#第十章-语义分析和代码生成" class="headerlink" title="第十章 语义分析和代码生成"></a>第十章 语义分析和代码生成</h2><ol>
<li><p>源语言：通用的过程语言。</p>
</li>
<li><p>生成代码：栈式抽象机生成的伪汇编代码。</p>
</li>
<li><p>翻译方法：自顶向下的属性翻译。</p>
</li>
<li><p>语法成分翻译子程序参数设置：继承属性为值形参，综合属性为变量形参。</p>
</li>
<li><p>语法成分动作翻译子程序参数设置：继承属性为值形参，综合属性不设形参而作为动作子程序返回值。</p>
</li>
<li><p>L属性翻译文法(L-ATG)：输入文法要求是LL(1)文法，可用自顶向下分析构建分析器。</p>
<p>其拥有特征：终结符、非终结符和动作符都具有属性；非终结符和动作符属性可分为继承属性综合属性；开始符号的继承属性具有指定初始值；终结符号的综合属性具有指定初始值；属性求值规则。</p>
</li>
<li><p>语义分析：</p>
<ul>
<li><p>上下文有关分析：标识符作用域；</p>
</li>
<li><p>类型一致性检查</p>
</li>
<li><p>语义处理： 声明语句：语义是声明变量类型等。编译程序工作是填符号表，登录名字特征信息，分配存储。</p>
<p>​                    执行语句：语义是某种操作。编译程序工作是按某种操作的目标结构生成代码。</p>
</li>
</ul>
</li>
<li><p>用上下文无关文法只能描述语言的语法结构，而不能描述其语义。</p>
<p>构建上下文有关文法过于困难，其分析器效率低。通常把与语义相关的上下文有关信息填入符号表中，并通过查符号表中的这些信息来分析程序的语义是否正确。</p>
</li>
<li><p>栈式抽象机：三个存储器、一个指令寄存器和多个地址寄存器组成。</p>
<p>存储器：数据存储器（存放AR的运行栈）、操作存储器（操作数栈）、指令存储器。</p>
</li>
<li><p>栈式抽象机指令代码：</p>
<p>| 指令名称 | 操作码                                   | 地址  | 指令意义                                     |<br>| ———— | ———————————————————— | ——- | —————————————————————— |<br>| 加载指令 | LOD                                      | D     | 将D的内容→栈顶                               |<br>| 立即加载 | LDC                                      | const | 常量→栈顶                                    |<br>| 地址加载 | LDA                                      | (D)   | 变量D的地址→栈顶                             |<br>| 存储     | STO                                      | D     | 栈顶内容→变量D                               |<br>| 间接存   | ST                                       | @D    | 栈顶内容→D所指单元                           |<br>| 间接存   | STN                                      |       | 栈顶内容→次栈顶所指单元                      |<br>| 加       | ADD                                      |       | 栈顶和次栈顶内容相加，结果留栈顶             |<br>| 减       | SUB                                      |       | 次栈顶内容减栈顶内容                         |<br>| 乘       | MUL                                      |       |                                              |<br>| 逻辑与   | AND                                      |       |                                              |<br>| 逻辑或   | ORL                                      |       |                                              |<br>| 逻辑非   | NOT                                      |       |                                              |<br>| 比较     | EQL, NEQ, <br />GRT, LES, <br />GTE, LSE |       | 次栈顶内容与栈顶内容比较，结果（1或0）留栈顶 |<br>| 转子     | JSR                                      | lab   |                                              |<br>| 分配     | ALC                                      | M     | 在运行栈顶分配大小为M的活动记录区            |</p>
</li>
<li><p>声明的处理：处理声明主要是填表并检查是否重复声明，处理已声明实体主要是查表。</p>
</li>
<li><p>对于静态数组，编译程序处理声明时应建立数组模板（数组信息向量），以便后期计算数组元素的存储地址。一般存储下界上界和地址计算常量。</p>
</li>
<li><p>大部分程序语言数组元素按照行优先存放，FORTRAN例外。</p>
</li>
<li><p>翻译文法中的动作符号也称为动作程序。</p>
</li>
<li><p>表达式的处理：处理表达式主要是生成计算该表达式值的代码。通常是把操作数装载到操作数栈栈顶或某个寄存器中，执行表达式所指定的操作，并将结果保留在栈顶或寄存器中。</p>
</li>
<li><p>操作数栈可以和运行栈（动态存储分配）合并，也可单独设栈。本章选择单独设栈的方式。</p>
</li>
<li><p>对于实际表达式计算允许整型实型混合使用，允许出现数组元素。因此除去基本运算，还应加入类型一致性检查或转换，计算下标变量地址并取下标变量值的语义动作。</p>
</li>
<li><p>过程调用：</p>
<ul>
<li>传值：调用段：计算实参值，放在操作数栈栈顶；被调用段：从栈顶取得值，对应形参单元。对形参的访问等于对相应实参的访问。</li>
<li>传值：调用段：计算实参地址，放在操作数栈栈顶；被调用段：从栈顶取得地址，对应形参单元。通过对形参的间接访问来访问相应的实参。</li>
<li>传名：将实参名传给形参。当实参变量为下标变量时，传名和传地址效果可能不同。传名实现复杂效率较低，现基本不使用。</li>
</ul>
</li>
<li><p>返回语句：返回返回值，并删除被调用过程活动记录。</p>
</li>
</ol>
<h2 id="第十一章-词法分析自动化"><a href="#第十一章-词法分析自动化" class="headerlink" title="第十一章 词法分析自动化"></a>第十一章 词法分析自动化</h2><ol>
<li><p>正则表达式和正则集合：有字母表 $\Sigma$ , 定义在 $\Sigma$ 上的正则表达式和正则集合递归定义如下 :</p>
<ul>
<li><p>$\varepsilon$ 和 $\phi$ 都是 $\Sigma$ 上的正则表达式, 其正则集合分别为: ${\varepsilon}$ 和 $\phi$ ;</p>
</li>
<li><p>任何 $a \in \Sigma$ <strong>,</strong> $a$是 $\Sigma$ 上的正则表达式,其正则集合为: ${a}$ ; </p>
</li>
<li>假定 $U$ 和 $V$ 是 $\Sigma$ 上的正则表达式, 其正则集合分别记为 $L(U)$ 和 $L(V)$ , 那么 $U|V$ , $U\cdot V$ 和 $U <em>$ 也都是 $\Sigma$ 上的正则表达式, 其正则集合分别为 $L(U) \cup L(V)$ 、 $L(U) \cdot L(V)$ 和 $L(U) </em>$ ；</li>
<li>任何 $\Sigma$ 上的正则表达式和正则集合均由 1、2和3产生。</li>
</ul>
</li>
<li><p>正则表达式符号： $|$ 或， $\cdot$ 连接， $* / {}$ 重复， $()$ 括号。</p>
</li>
<li><p>正则表达式与3型文法等价。</p>
</li>
<li><p>确定有穷自动机DFA：$M = {S, \Sigma, \delta, s_0, Z}$ ，其中 $S$ 代表有穷状态集， $\Sigma$ 代表输入字母表， $\delta$ 状态转移函数， $s_0$ 初始状态， $Z$ 终止状态集。</p>
<p>DFA的确定性表现在状态转换函数是单值函数。</p>
</li>
<li><p>不确定有穷自动机NFA：若 $δ$ 是一个多值函数，且输入可允许为 $\varepsilon$ ，则有穷自动机是不确定的 , 即在某个状态下，对于某个输入字符存在多个后继状态。</p>
</li>
<li><p>$\varepsilon-Closure(A) = A \cup B$ ，其中 $B$ 是指 $A$ 中元素经过任意条 $\varepsilon$ 弧能够到达的状态的集合。</p>
</li>
<li><p>NFA到DFA的转换原理是构建新的状态，按照NFA图构建新的转换函数 $\delta(s_0, 0) = \varepsilon-Closure(s_1) = {s_1, s_2}$ 。</p>
</li>
<li><p>DFA的化简：多余状态、等价状态（一致性：同为可接受或不可接受；蔓延性：任意输入符号都得转换到等价状态）。</p>
</li>
<li><p>DFA与正则文法等价。</p>
</li>
<li><p>正则文法可分为左线性正则文法和右线性正则文法。</p>
</li>
</ol>
<h2 id="第十二章-语法分析提高"><a href="#第十二章-语法分析提高" class="headerlink" title="第十二章 语法分析提高"></a>第十二章 语法分析提高</h2><ol>
<li><p>LL分析法：LL自左向右扫描、自左向右地分析和匹配输入串，表现出最左推导的性质。从左到右扫描，自顶向下归约。</p>
</li>
<li><p>$FIRST(\alpha) = {a|\alpha \Rightarrow a…, a\in V_t}$ ，其中 $a$ 可以为空字符。</p>
<p>$FOLLOW(A) = {a|\alpha \Rightarrow …Aa…, a\in V_t}$ 。若 $\alpha\Rightarrow …A$ ，则 $#\in FOLLOW(A)$ 。</p>
</li>
<li><p>LL(1)文法：文法分析表不含多重定义入口，即分析表中每格无两条以上规则。</p>
</li>
<li><p>LL(1)文法充要条件：对任意规则 $A::=\alpha \,|\, \beta$ ，都有</p>
<ul>
<li>$FIRST(\alpha) \cap FIRST(\beta) = \varnothing$ ；</li>
<li>若 $\beta \Rightarrow \varepsilon$ ，$FIRST(\alpha) \cap FOLLOW(A) = \varnothing$ 。</li>
</ul>
</li>
<li><p>自底向上分析：从输入符号串开始，重复查找当前句型句柄，并利用有关规则进行归约。</p>
</li>
<li><p>移进-归约分析：建立符号栈，记录分析历史和现状，根据所面临状态，确定下一步动作是移进还是归约。</p>
</li>
<li><p>算符优先分析：仿效算术式四则运算，为每个终结符设定执行的先后顺序。</p>
<p>该分析不一定是严格的最左归约/规范归约。</p>
</li>
<li><p>$FIRSTVT(U) = {b|U\Rightarrow b… 或 U \Rightarrow Vb…, V\in V_n, b \in V_t}$ ；</p>
<p>$LASTVT(U) = {a|U\Rightarrow …a 或 U \Rightarrow …aV, V\in V_n, a \in V_t}$ 。</p>
</li>
<li><p>素短语：一个短语，至少包含一个终结符号，且除它自身外不包含其他素短语。</p>
</li>
<li><p>LR分析法：从左到右扫描，自底向上归约。</p>
</li>
<li><p>LR分析器有状态栈、分析表、控制程序三部分。</p>
</li>
<li><p>分析表种类：SLR（简单LR）、LR（标准LR）、LALR（超前LR）。</p>
</li>
<li><p>规范句型：通过规范规约得到的句型。</p>
<p>前缀：输入串前部终结符串，只要满足剩余部分与其连接成为输入串即可。</p>
<p>活前缀：若分析过程能保证栈中符号串均是规范句型的前缀，则称为活前缀（表示当前分析中并无语法错误，活前缀实际是不包括句柄右边符号的前缀）。</p>
</li>
<li><p>有效项目：若项目 $A \rightarrow \beta_1\beta_2$ 对活前缀 $\alpha\beta_1$ 成立，则必有规范推导 $E\Rightarrow \alpha Aw\Rightarrow \alpha\beta_1\beta_2w$ 。（假设活前缀为 $\alpha_1…\alpha_k$ ，获得项目族群和项目间转移关系后，按照活前缀顺序输入进行转移，最终所在项目即是该活前缀的有效项目集）</p>
</li>
<li><p>状态转移表（GOTO）：终结符导致状态转移</p>
</li>
<li><p>分析动作表（ACTION）：移进（shift），归约（reduce），接受（accept），出错（error）</p>
</li>
<li><p>控制程序：根据栈顶状态和现输入符号查ACTION表执行规定操作，并根据GOTO表设置新栈顶状态。</p>
</li>
<li><p>LR分析过程：每次归约总是归约当前句型的句柄（规范规约）；分析每一步栈中符号串均是规范句型的活前缀，与输入串剩余部分构成规范句型。</p>
</li>
<li><p>SLR分析表构建：</p>
<ul>
<li>确定文法状态集合，即LR(0)项目集规范族：实现时首先应拓广文法，如普通G[S]文法，应该添加推导规则 $S’\rightarrow S$ ，保证分析表只有一个接受状态。初始状态是 $I_0:S’\rightarrow .S$ 以及这个项目的闭包（所有可以转移到的项目，如 $S\rightarrow .E,\ E\rightarrow .abc$ ）。</li>
<li>确定转移函数，从初始项目集出发，将 $.$ 后移一位，判断转移函数，填写ACTION和GOTO表。</li>
<li>确定文法归约，在状态中，寻找形如 $A\rightarrow abc.$ 的语句，则在 $FOLLOW(A)$ 的字符对应的格子中填入该语句对应的归约编号。如该语句编号为 $2$ ，$FOLLOW(A) = {a,b}$ ，则在 $a,b$ 对应的格子中填入 $r_2$ 。</li>
</ul>
</li>
<li><p>SLR判断方法：判断是否有移进-移进冲突（即一个字符出现两种转移）、移进-归约冲突（即一个字符可能为转移也可能为归约）。</p>
</li>
</ol>
<h2 id="第十四章-代码优化"><a href="#第十四章-代码优化" class="headerlink" title="第十四章 代码优化"></a>第十四章 代码优化</h2><ol>
<li><p>优化目标：提高目标代码运行效率，时间+空间</p>
</li>
<li><p>优化方法分类：</p>
<ul>
<li>与机器无关（中间代码优化）、与机器有关（目标代码优化，指令与寄存器的使用）；</li>
<li>局部优化（基本块内）、全局优化（函数内基本块间）、跨函数优化（整个程序内）。</li>
</ul>
</li>
<li><p>基本块定义：连续的语句序列，控制流只能从第一句进入基本块，从最后一句离开基本块。</p>
</li>
<li><p>流图定义：有向图，节点是基本块，基本块间关系是前驱和后继。</p>
</li>
<li><p>基本块内优化：</p>
<ul>
<li><p>代数变换：常数计算与合并，削弱运算强度；</p>
</li>
<li><p>复写传播：形如 $x:=y$ 的赋值语句称为复写语句，满足一定条件时，后续 $y$ 可用 $x$ 替代，称为复写传播；</p>
</li>
<li><p>死代码删除：如 $x := x + 0$ ，永真的 if-else 语句块。</p>
<blockquote>
<p><strong>消除公共子表达式</strong></p>
<p>通过构建DAG图（有向无环图）消除公共子表达式。</p>
<blockquote>
<p><strong>DAG图构建算法</strong></p>
<p>对于形如 $z = x\ op\ y$ 的表达式，在图中寻找 $x$ 、 $y$ 对应的节点，如果没有就在图中新添加。接着寻找 $op$ 对应的节点（该节点存在有向边分别指向 $x$ 、 $y$ 对应的节点），如果没有就在图中新添加。完成后将 $z$ 所代表的节点设置为 $op$ 对应的节点。</p>
<p>对于数组元素，需要改写表达式。对于形如 $z = a[i]$ 的表达式，改写为 $z = a\ []\ i$ 的形式， $[]$ 作为运算符。对于形如 $a[i] = z$ 的表达式，改写为 $a = i\ {[]=}\ z$ 的形式， $[]=$ 作为运算符。对于指针运算，尽量不要优化。</p>
<p><strong>从DAG图导出中间代码算法</strong></p>
<p>选择DAG图中任意一无父节点（即无有向边指向它）的节点，去除并加入队列。接着如果它的最左子节点符合无父节点的条件，则去除并加入队列，继续对加入节点的最左子节点判断；如果不符合条件，则在图中再选取一个符合条件的节点，继续上述流程。所有节点均加入队列后，反序输出队列中节点作为代码运算顺序。</p>
</blockquote>
</blockquote>
</li>
</ul>
</li>
<li><p>窥孔优化：窥孔优化关注在目标指令的 一个较短的序列上，通过删除其中的冗余代码，或者用更高效简洁的新代码来替代其中的部分代码，达到提升目标代码质量的目的。并不局限于一个基本块内。</p>
</li>
<li>全局优化：首先应进行数据流分析， $out[S] = gen[S] \cup (in[S] - kill[S])$ 或 $in[S] = use[S] \cup (out[S] - def[S])$ 对于任意基本块或语句都成立。</li>
<li>到达定义分析：某个变量定义是在哪里产生、在哪里消除，在哪些语句中都可以使用。基本块的到达定义分析先获得 $in$ 集合（ $in[B] = \cup_{B的前驱基本块P}\ out[P]$ ，其中 $in[B_1] = \varnothing$ ），并通过上式（ $out[S] = gen[S] \cup (in[S] - kill[S])$ ）获得 $out$ 集合。循环执行，直至全部块的 $out$ 集合不变。</li>
<li>活跃变量分析：某个变量在当前位置是否是活跃的，即后续是否使用。本块的活跃变量分析先获得 $out$ 集合（ $out[B] = \cup<em>{B的后驱基本块P}\ in[P]$ ，其中 $out[B</em>{exit}] = \varnothing$ ），并通过上式（ $in[S] = use[S] \cup (out[S] - def[S])$ ，活跃变量中， $def$ 代表在使用前定义/赋值的变量； $use$ 代表在定义/赋值前使用的变量）获得 $in$ 集合。循环执行，直至全部块的 $in$ 集合不变。</li>
<li>冲突图：假设只有跨越基本块活跃的变量才能分配到全局寄存器，并且活跃范围重合的变量之间无法共享全局寄存器。节点是待分配的全局寄存器，当两个变量中一个在另一个定义/赋值处活跃，他们之间便有一条边相连。</li>
<li>变量的定义-使用链：每个变量可能有多个链，每个链头元素表示定义/赋值位置，后面元素表示使用位置，可写为 ${<B_{def}, n_{pos}>, …}$ 的形式。</li>
<li>循环优化：循环不变式（不随循环控制变量改变而改变）外提、循环展开（以空间换时间，需判断展开前后是否更节省时间）、归纳变量（每次迭代过程中固定增加或减少一个值）的优化和条件判断的替换、多重嵌套变单层、相同形式循环合并。</li>
<li>in_line展开：将函数调用展开在主程序中，节省压栈和跳转时间。</li>
</ol>
<h2 id="第十五章-目标代码生成"><a href="#第十五章-目标代码生成" class="headerlink" title="第十五章 目标代码生成"></a>第十五章 目标代码生成</h2><ol>
<li><p>代码生成器输入：符号表、源程序中间表示。</p>
<p>要求：获得中间表示、标识符表示直接操作的变量、完成语法语义等检查。</p>
</li>
<li><p>指令集架构：</p>
<ul>
<li>栈式架构：PUSH、POP出入栈顶，计算指令计算栈顶单元。</li>
<li>累加器式架构：LOAD、STORE加载存储栈顶，计算指令计算栈顶单元和新输入单元。</li>
<li>寄存器架构：分为寄存器-内存指令架构（操作指令从寄存器和内存获得数据）和寄存器-寄存器（操作指令只能从寄存器获得数据）指令架构。</li>
</ul>
</li>
<li><p>为了程序效率，应该尽可能少访问除寄存器外的存储设备。</p>
</li>
<li><p>循环可以通过循环交换优化提高缓存命中率。</p>
</li>
<li><p>地址空间：代码区存放目标代码；静态数据区存放全局变量、静态变量和其他部分变量（如字符串）；动态内存区（也称内存堆）存放普通变量；程序运行栈存放活动记录和函数调用上下文现场。</p>
</li>
<li><p>程序运行栈设计：进入子程序/函数时分配，地址空间向下生长；从子程序/函数返回时，当前运行栈将被废弃；递归调用的同一个子程序/函数，每次调用都应获得独立的运行栈空间。</p>
</li>
<li><p>活动记录：函数返回地址、全局寄存器保存区、临时变量保存区、未分配到全局寄存器的局部变量保存区、其他辅助信息保存区。</p>
</li>
<li><p>寄存器分类：通用寄存器（临时寄存器/全局寄存器）、专用寄存器。</p>
</li>
<li><p>全局寄存器分配：相对于基本块而言，不是对于程序全局。</p>
<p>分配原则：优先分配给跨基本块活跃的变量，尤其是循环体内最活跃变量；局部变量参与全局寄存器分配；为线程安全，全局变量、静态变量不参与全局寄存器分配。</p>
</li>
<li><p>常用全局寄存器分配方法：</p>
<ul>
<li>引用计数：如果一个局部变量被访问次数较多，则获得全局寄存器概率越大；出现在循环尤其是内层嵌套循环中的变量被访问次数应获得一定加权。（但存在不再使用的寄存器不能及时释放寄存器）</li>
<li>图着色算法：通过数据流分析，构建变量的冲突图。如果有 $k$ 个可供分配的寄存器，尝试用 $k$ 种颜色为冲突图着色。一种方法是不断找到连接边数目小于 k 的节点移走；当无法再移走点时，删除合适的点，记录为不分配全局寄存器的变量，并继续重复上述步骤；当只剩余一个节点时，给此节点分配一种颜色，按照节点被移走的顺序，反向添加节点和边并选取颜色。</li>
</ul>
</li>
<li><p>图着色构建变量冲突图：节点是待分配全局寄存器的变量。一个变量在另一个变量的定义/赋值处是活跃的，则这两个变量的节点间有一条边连接（即有边相连的变量无法共用一个全局寄存器）。</p>
</li>
<li><p>临时寄存器的分配：如 <code>$a0</code> 、 <code>$v0</code> 、 <code>$hi</code> 此类寄存器。生成某些指令时必须使用指定寄存器，临时寄存器可能保有此前计算中间结果，因此需要合理使用临时寄存器。使用寄存器池管理分配临时寄存器。</p>
</li>
<li><p>临时寄存器生存范围：不超越基本块，不跨越函数调用。</p>
</li>
<li><p>分配原则：进入基本块时，清空临时寄存器池；如寄存器池中有空闲寄存器，标记该寄存器被占用，并返回该寄存器；反之选取一个不会被马上使用的寄存器写回相应内存空间，并将该寄存器分配给待分配变量；在基本块结束或调用函数前都应该将临时寄存器写回相应内存空间并清空寄存器池。</p>
</li>
</ol>
<h2 id="第十六章-编译程序生成方法和工具"><a href="#第十六章-编译程序生成方法和工具" class="headerlink" title="第十六章 编译程序生成方法和工具"></a>第十六章 编译程序生成方法和工具</h2><ol>
<li>编译程序的书写语言：机器语言或汇编语言、高级程序设计语言。</li>
<li>自编译性：如果一个高级语言可以书写自己的编译程序，则称为自编译语言。</li>
<li>自编译性不是绝对的，只是强弱不同。数据类型、控制结构丰富（适于进行多分支程序设计）的语言自编译性强。</li>
<li>自展：将语言分为多个部分，不断用前若干部分语言编写后若干部分的编译程序。（可提高生产率，核心语言小，可用汇编实现，其余部分高级语言编写）</li>
<li>编译程序的移植：将宿主机软件移植到目标机上。将语言分为两部分（与机器有关与机器无关），使用与机器有关语言改写为目标机有关语言，编译生成在宿主机上运行的语言交叉编译程序（其生成只能在目标机上运行的代码），编译生成在目标机上运行的语言编译程序。</li>
<li>编译程序的自动生成：目前还没有程序能自动生成整个编译系统。</li>
</ol>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>review</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象课程Unit1总结</title>
    <url>/2025/03/17/OO/2024%E6%98%A5-OO%E8%AF%BE%E7%A8%8BUnit1%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="2024春-OO课程Unit1总结"><a href="#2024春-OO课程Unit1总结" class="headerlink" title="2024春-OO课程Unit1总结"></a>2024春-OO课程Unit1总结</h1><hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>第一单元作业是实现复杂多项式化简，第一次作业实现较为基础的运算，第二次作业加入了自定义函数与指数函数等，第三次作业则加入了表达式求导。第一单元的思想、算法更加偏向面向对象、复杂迭代，与上学期的OOpre课程题目难度相去甚远，因此在构建整体架构时确实消耗了不少精力。本篇总结主要是记录一下三次作业的架构设计、各种优缺点分析，以及自身一点心得体会。</p>
<hr>
<h2 id="一、作业架构分析"><a href="#一、作业架构分析" class="headerlink" title="一、作业架构分析"></a>一、作业架构分析</h2><h3 id="Homework1"><a href="#Homework1" class="headerlink" title="Homework1"></a>Homework1</h3><h4 id="题目重点重述"><a href="#题目重点重述" class="headerlink" title="题目重点重述"></a>题目重点重述</h4><p>第一次作业主要是实现较为简单的基础运算，运算有加（+）、减（-）、乘（<em>）、乘方（^），并涉及到带括号的优先运算（无多括号的迭代）。主要概念涉及到<strong>表达式</strong>、<strong>项</strong>、<em>*因子</em></em>。</p>
<h4 id="程序UML图"><a href="#程序UML图" class="headerlink" title="程序UML图"></a>程序UML图</h4><p><img src="/images/OO/oo第1单元总结/hw1-1UML图.png" alt="hw1-1UML图"  /></p>
<p>主要方法是梯度下降法。流程大致为通过<code>Lexer</code>类将字符串转换为一个个<code>Token</code>，接着使用<code>Parser</code>类构建出表达式树（结点为<code>Expr</code>、<code>Term</code>、<code>Factor</code>类，其中<code>Factor</code>类可能含有<code>Expr</code>类元素，因此构建表达式树过程中会出现迭代过程）。通过各类的<code>getVars()</code>函数将各元素转换为<code>Var</code>的列表类，并进行合并化简计算，最终将表达式树转换为目标字符串。</p>
<h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><p>类复杂度表格如图所示：其中<code>OCavg</code>指代平均操作复杂度，<code>OCmax</code> 指代最大操作复杂度，<code>WMC</code> 指代加权方法复杂度</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Class</th>
<th>OCavg</th>
<th>OCmax</th>
<th>WMC</th>
</tr>
</thead>
<tbody>
<tr>
<td>Expr</td>
<td>2.5</td>
<td>6</td>
<td>15</td>
</tr>
<tr>
<td>Lexer</td>
<td>3</td>
<td><strong>11</strong></td>
<td>15</td>
</tr>
<tr>
<td>Main</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>Num</td>
<td>1</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>Operation</td>
<td>2.75</td>
<td>4</td>
<td>11</td>
</tr>
<tr>
<td>Parser</td>
<td><strong>3.25</strong></td>
<td><strong>7</strong></td>
<td>13</td>
</tr>
<tr>
<td>Term</td>
<td><strong>3.67</strong></td>
<td>6</td>
<td>11</td>
</tr>
<tr>
<td>Token</td>
<td>1</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>Var</td>
<td>2</td>
<td>5</td>
<td>16</td>
</tr>
</tbody>
</table>
</div>
<p>可以观察到，<code>Operation</code>、<code>Lexer</code>、<code>Parser</code>、<code>Expr</code>、<code>Term</code>类复杂度较高，这是意料之中的。这几个类作为整个程序最重要的操作类，方法众多。但仍应注意到，有些类最大操作复杂度较高，这证明程序设计中出现的部分方法代码长度大、实现功能过程复杂，仍与<strong>高内聚，低耦合</strong>的设计原则有出入，仍需要优化。</p>
<h3 id="Homework2"><a href="#Homework2" class="headerlink" title="Homework2"></a>Homework2</h3><h4 id="题目重点重述-1"><a href="#题目重点重述-1" class="headerlink" title="题目重点重述"></a>题目重点重述</h4><p>第二次作业与第一次作业主要区别有<strong>三点</strong>：自定义函数（无自定义函数的嵌套）、以e为底的指数函数（可多层指数函数嵌套）、多次括号迭代化简。自定义函数函数名限定为$f$、$g$或$h$，形式参数名限定为$x$、$y$或$z$。</p>
<h4 id="程序UML图-1"><a href="#程序UML图-1" class="headerlink" title="程序UML图"></a>程序UML图</h4><p><img src="/images/OO/oo第1单元总结/hw1-2UML图.png" alt="hw1-2UML图"></p>
<p>在第一次作业的基础上，增加了<code>Function</code>类，使用字符串替换的方法，在预处理阶段将表达式中形参函数替换为实参函数。对于指数函数，则通过新建<code>Exp</code>类存储。在第一次作业中，由于<code>Parser</code>可以实现迭代处理字符串表达式为表达式树，而多层括号则可以理解为<code>Expr</code>嵌套，因此实际上梯度下降法对该要求有着天然优势。</p>
<h4 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h4><p>类复杂度表格如图所示：其中<code>OCavg</code>指代平均操作复杂度，<code>OCmax</code> 指代最大操作复杂度，<code>WMC</code> 指代加权方法复杂度</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Class</th>
<th>OCavg</th>
<th>OCmax</th>
<th>WMC</th>
</tr>
</thead>
<tbody>
<tr>
<td>Exp</td>
<td>1.25</td>
<td>2</td>
<td>5</td>
</tr>
<tr>
<td>Expr</td>
<td>2.67</td>
<td>6</td>
<td>8</td>
</tr>
<tr>
<td>Function</td>
<td><strong>5.33</strong></td>
<td><strong>11</strong></td>
<td>16</td>
</tr>
<tr>
<td>Lexer</td>
<td>3.8</td>
<td><strong>15</strong></td>
<td>19</td>
</tr>
<tr>
<td>Main</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>Num</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>Operation</td>
<td>3.29</td>
<td>8</td>
<td>23</td>
</tr>
<tr>
<td>Parser</td>
<td><strong>3.75</strong></td>
<td>8</td>
<td>15</td>
</tr>
<tr>
<td>Term</td>
<td>2.33</td>
<td>5</td>
<td>7</td>
</tr>
<tr>
<td>Token</td>
<td>1</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>Var</td>
<td>2</td>
<td>5</td>
<td>18</td>
</tr>
</tbody>
</table>
</div>
<p>可以观察到，<code>Operation</code>、<code>Function</code>、<code>Lexer</code>、<code>Parser</code>、<code>Expr</code>、<code>Term</code>类复杂度较高（<del>这仍是意料之中的，毕竟代码量只加不减</del>）。这几个类作为整个程序最重要的操作类，方法众多，逻辑交叉复杂。但仍应注意到，新加类<code>Function</code>类操作复杂度尤其高，这是因为该类使用字符串替换方法，而这种方法<strong>更加面向过程而非面向对象</strong>，平替方案见下文优化策略。</p>
<h3 id="Homework3"><a href="#Homework3" class="headerlink" title="Homework3"></a>Homework3</h3><h4 id="题目重点重述-2"><a href="#题目重点重述-2" class="headerlink" title="题目重点重述"></a>题目重点重述</h4><p>第三次作业与第二次作业的区别主要有<strong>两点</strong>：表达式求导、函数迭代。其中，对于任意表达式，均对自变量x进行求导，求导可以迭代。函数迭代过程不能出现循环迭代，即函数定义时，引用函数只能引用已经出现的函数。</p>
<h4 id="程序UML图-2"><a href="#程序UML图-2" class="headerlink" title="程序UML图"></a>程序UML图</h4><p><img src="/images/OO/oo第1单元总结/hw1-3UML图.png" alt="hw1-3UML图"></p>
<p>在第二次作业的基础上，增加了<code>derive()</code>方法，在parser的过程中，直接对<code>Token.Type == DER</code>的元素求导。这是一个迭代求导的过程，因此很容易解决对含有导数表达式的式子再次求导。在第二次作业中，处理函数表达式的方法是字符串替换，并且替换停止的判断条件是遍历替换后表达式不再出现函数名，因此也可以很好的处理函数嵌套的问题。</p>
<h4 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h4><p>类复杂度表格如图所示：其中<code>OCavg</code>指代平均操作复杂度，<code>OCmax</code> 指代最大操作复杂度，<code>WMC</code> 指代加权方法复杂度</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Class</th>
<th>OCavg</th>
<th>OCmax</th>
<th>WMC</th>
</tr>
</thead>
<tbody>
<tr>
<td>Exp</td>
<td>1.2</td>
<td>2</td>
<td>6</td>
</tr>
<tr>
<td>Expr</td>
<td>2.5</td>
<td>6</td>
<td>10</td>
</tr>
<tr>
<td>Function</td>
<td><strong>5.33</strong></td>
<td><strong>11</strong></td>
<td>16</td>
</tr>
<tr>
<td>Lexer</td>
<td>3.25</td>
<td><strong>11</strong></td>
<td>26</td>
</tr>
<tr>
<td>Main</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>Num</td>
<td>1</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>Operation</td>
<td>3.43</td>
<td>8</td>
<td>24</td>
</tr>
<tr>
<td>Parser</td>
<td><strong>3.75</strong></td>
<td>7</td>
<td>15</td>
</tr>
<tr>
<td>Term</td>
<td>2.5</td>
<td>4</td>
<td>10</td>
</tr>
<tr>
<td>Token</td>
<td>1</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>Var</td>
<td>2</td>
<td>5</td>
<td>20</td>
</tr>
</tbody>
</table>
</div>
<p>可以观察到，<code>Operation</code>、<code>Function</code>、<code>Lexer</code>、<code>Parser</code>、<code>Expr</code>、<code>Term</code>类复杂度较高（<del>这当然还是意料之中的</del>）。可以发现，<code>Lexer</code>类的最大复杂度有所降低，这是因为在第三次作业中，将部分<code>Lexer</code>构造方法中复杂的函数部分提出来作为了新的方法，降低了耦合度。但仍应注意到，优化后的<code>Function</code>、<code>Lexer</code>类操作复杂度仍然很高，两类中部分方法对字符串进行了详细解析，这样显然也是<strong>更加面向过程而非面向对象</strong>，可以通过提取出新方法来优化。</p>
<hr>
<h2 id="二、架构重点实现分析"><a href="#二、架构重点实现分析" class="headerlink" title="二、架构重点实现分析"></a>二、架构重点实现分析</h2><h3 id="Homework1-1"><a href="#Homework1-1" class="headerlink" title="Homework1"></a>Homework1</h3><p>第一次作业程序中主要有三个实现的重点：</p>
<ul>
<li><p><strong>表达式预处理：</strong> 主要处理了以下三类特殊情况：</p>
<ul>
<li><p>多个正号负号</p>
</li>
<li><p>变量前出现负号</p>
</li>
<li><p>数字前仅有负号，没有连接的正号</p>
</li>
</ul>
<p><em>具体过程如下：</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;\\+\\+|--|-\\+|\\+-|\\*\\+|\\^\\+|-x|-\\(|-exp|-dx&quot;</span>);</span><br><span class="line">      <span class="keyword">while</span> (pattern.matcher(preLine).find())</span><br><span class="line">      &#123;</span><br><span class="line">          preLine = preLine.replaceAll(<span class="string">&quot;\\++|--&quot;</span>, <span class="string">&quot;+&quot;</span>);</span><br><span class="line">          preLine = preLine.replaceAll(<span class="string">&quot;-\\+|\\+-&quot;</span>, <span class="string">&quot;-&quot;</span>);</span><br><span class="line">          preLine = preLine.replaceAll(<span class="string">&quot;\\*\\+&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">          preLine = preLine.replaceAll(<span class="string">&quot;\\^\\+&quot;</span>, <span class="string">&quot;^&quot;</span>);</span><br><span class="line">          preLine = preLine.replaceAll(<span class="string">&quot;-x&quot;</span>, <span class="string">&quot;-1*x&quot;</span>);</span><br><span class="line">          preLine = preLine.replaceAll(<span class="string">&quot;-exp&quot;</span>, <span class="string">&quot;-1*exp&quot;</span>);</span><br><span class="line">          preLine = preLine.replaceAll(<span class="string">&quot;-dx&quot;</span>, <span class="string">&quot;-1*dx&quot;</span>);</span><br><span class="line">          preLine = preLine.replaceAll(<span class="string">&quot;-\\(&quot;</span>, <span class="string">&quot;+-1*(&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      preLine = preLine.replaceAll(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;+-&quot;</span>);</span><br><span class="line">      preLine = preLine.replaceAll(<span class="string">&quot;\\*\\+-&quot;</span>, <span class="string">&quot;*-&quot;</span>);</span><br><span class="line">      preLine = preLine.replaceAll(<span class="string">&quot;\\(\\+&quot;</span>, <span class="string">&quot;(&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><strong>梯度下降法构建表达式树：</strong> 主要使用<code>Expr</code>、<code>Term</code>、<code>Factor</code>三个类型的处理方法，在<code>Parser</code>类中主要对应以下三种方法：<ul>
<li><code>parserExpr</code>：主要对<code>Expr</code>类处理，以加号作为分隔界限，调用<code>parserTerm</code>方法获取该表达式内的各项；</li>
<li><code>parserTerm</code>：主要对<code>Term</code>类处理，以乘号和乘方符号作为分割界限，调用<code>parserFactor</code>方法获取该项内的各因子；</li>
<li><code>parserFactor</code>：主要处理<code>Factor</code>类型的对象，按照对象类型，构建新对象<code>Num</code>、<code>Exp</code>、<code>Var</code>存入列表中，或者对<code>Expr</code>类再迭代调用<code>parserExpr</code>方法并存入列表中。</li>
</ul>
</li>
<li><strong><code>getVars()</code>统一接口：</strong> 将表达式树中结点计算合并，重新变为字符串。为统一接口，方便化简，定义了这种方法。在程序中，我们将<code>Var</code>类定义为形如$Ratio\cdot\prod\limits_{i=1}^{n}{Var}_i^{Power}$的变量，这样各类都可以很方便地转化为<code>Var</code>类，从而达到统一接口的需求。</li>
</ul>
<h3 id="Homework2-1"><a href="#Homework2-1" class="headerlink" title="Homework2"></a>Homework2</h3><p>第二次作业程序中主要有三个实现重点：</p>
<ul>
<li><p><strong>自定义函数：</strong> 本次作业中，主要使用字符串解析替换的方法，建立<code>Function</code>类，属性有函数名，变量名列表，函数形式表达式。使用时将实参导入，替换所有对应形参，并返回替换后字符串。函数处理步骤位于预处理与表达式建树两步之间。</p>
</li>
<li><p><strong><code>Exp</code>类指数函数：</strong> 本次作业中，为指数函数建立<code>Exp</code>类，将指数作为属性传入，并在构造函数中将指数作为表达式，按照流程化简。如此，当指数中仍含有<code>Exp</code>类时，迭代调用化简；当指数中不含<code>Exp</code>类时，直接化简。</p>
<p><em>具体过程如下：</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Exp</span><span class="params">(String con)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">this</span>.power = BigInteger.ONE;</span><br><span class="line">       <span class="built_in">this</span>.content = con.substring(<span class="number">1</span>, con.length() - <span class="number">1</span>); <span class="comment">//这里只用中间段字符串是因为con传入时带两侧括号</span></span><br><span class="line">       <span class="built_in">this</span>.unfoldContent();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unfoldContent</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="type">Operation</span> <span class="variable">operation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Operation</span>();</span><br><span class="line">       operation.setBeforeStr(<span class="built_in">this</span>.content);</span><br><span class="line">       operation.preDeal();</span><br><span class="line">       operation.unfold();</span><br><span class="line">       operation.merge();</span><br><span class="line">       <span class="built_in">this</span>.calculateRes = operation.getResult(); <span class="comment">//content代表计算前表达式，caculateRes代表化简计算后表达式</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Homework3-1"><a href="#Homework3-1" class="headerlink" title="Homework3"></a>Homework3</h3><p>第三次作业程序中主要有一个实现重点：</p>
<ul>
<li><strong>任意表达式求导：</strong> 本次作业中，遵循递归求导的法则，建立<code>derive()</code>方法，逐步实现表达式因子的最终结果。<ul>
<li><strong><code>Expr</code>对象求导：</strong><code>Expr</code>对象由多个<code>Term</code>相加组成，因此只需要对各<code>Term</code>求导，将所有结果均放入容器储存即可。</li>
<li><strong><code>Term</code>对象求导：</strong><code>Term</code>对象由多个<code>Factor</code>相乘组成，按照多项式求导的乘法法则和链式法则，对一因子求导，保持其他因子不变，组成新项。将多个新项均放入容器存储即可。应注意，如不加处理，<code>Term</code>对象求导之后应为<code>Expr</code>对象。</li>
<li><strong><code>Factor</code>对象求导：</strong><code>Factor</code>因子主要分为<code>Num</code>、<code>Var</code>、<code>Exp</code>、<code>Expr</code>四类；为统一接口，在获得求导结果后，将其全部转换为<code>Term</code>类。<ul>
<li><strong><code>Expr</code>：</strong> 求导方式如上所示；</li>
<li><strong><code>Num</code>：</strong> 求导之后数值为0，类型仍为<code>Num</code>类；</li>
<li><strong><code>Var</code>：</strong> 求导之后按照指数分为两类：<ul>
<li>求导后指数等于0：求导之后数值为$Ratio \cdot Power$，类型变为<code>Num</code>类；</li>
<li>求导后指数大于0：求导之后$Ratio$为$Ratio \cdot Power$，$Power$为$Power-1$，类型仍为<code>Var</code>类；</li>
</ul>
</li>
<li><strong><code>Exp</code>：</strong> 求导之后整体形式变为$\exp(content) \cdot dx(content)$，类型变为<code>Term</code>类。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="三、类设计介绍与目标"><a href="#三、类设计介绍与目标" class="headerlink" title="三、类设计介绍与目标"></a>三、类设计介绍与目标</h2><p>本次设计总共建立了11个类，1个接口，现介绍如下：</p>
<ul>
<li><code>Main</code>：主类，按照流程进行读入、预处理、展开、化简。</li>
<li><code>Operation</code>：操作类，内含预处理方法、函数替换方法、函数解析方法、展开方法、化简方法。设计其是为了各操作最上层的耦合调用。</li>
<li><code>Lexer</code>：字符串解析类，面向过程解析字符串，将整体表达式解析为多个<code>Token</code>。设计其是为了按照字符特征将字符串切割为各个<code>Token</code>包，方便解析。</li>
<li><code>Parser</code>：解析类，使用递归下降法将经过<code>Lexer</code>处理的<code>Token</code>串建立为表达式树。设计其是为了建立表达式树，方便展开时按照计算顺序获取最终字符串表达式。</li>
<li><code>Function</code>：函数类，内含函数各种属性和处理方法。设计其是为了方便在<code>Lexer</code>里遇到形式函数的解析以及形式函数的替换操作。</li>
<li><code>Token</code>：<code>Lexer</code>解析里的最小单元，含有多种类型。</li>
<li><code>Expr</code>：表达式类，内含表达式各种属性和处理方法。设计其是为了方便在<code>Parser</code>里获取表达式，在展开时其各项统一处理。</li>
<li><code>Term</code>：项类，内含项各种属性和处理方法。设计其是为了方便在<code>Parser</code>里获取项，在展开时其各因子统一处理。</li>
<li><code>Factor</code>：因子接口，统一接入各因子类。<ul>
<li><code>Num</code>：数字类，内含常数各种属性和处理方法。设计其是为了方便在<code>Lexer</code>里遇到常数的解析以及各种涉及常数的操作。</li>
<li><code>Var</code>：变量类，内含变量各种属性和处理方法。设计其是为了方便在<code>Lexer</code>里遇到幂函数变量的解析、各种涉及变量的操作以及表达式树在展开使用方法<code>getVars()</code>时统一各类接口。</li>
<li><code>Exp</code>：指数函数变量类，内含指数函数各种属性和处理方法。设计其是为了方便在<code>Lexer</code>里遇到指数函数的解析以及各种涉及指数函数的操作。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="四、Bug分析及程序优化"><a href="#四、Bug分析及程序优化" class="headerlink" title="四、Bug分析及程序优化"></a>四、Bug分析及程序优化</h2><h3 id="Homework1-2"><a href="#Homework1-2" class="headerlink" title="Homework1"></a>Homework1</h3><h4 id="Bug分析"><a href="#Bug分析" class="headerlink" title="Bug分析"></a>Bug分析</h4><p>第一次作业暂无Bug</p>
<h4 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h4><p>设计最初时，出于对统一性的思考，缺省了对于性能的追求。现对作业过程中所做优化进行记录：</p>
<ul>
<li><p><strong>多余0项未化简：</strong> 最初设计为保障统一性，因此在任何表达式开头前侧均增加了一项“0+”，这会增加在计算化简过程中需要存储的项数，从而大大增加空间需求。为降低资源浪费，不选择该种方法，而是选择将以正号开头的表达式第一项符号去除，以达到统一性。</p>
</li>
<li><p><strong><code>Term</code>对象连接符号：</strong> 最初设计将连接各项的符号提出，储存为一个列表，单独处理。这大大增加了设计的复杂度，因此在更改后，将减号作为负号存入数值中，各项之间只用加号连接，降低了设计难度。</p>
</li>
<li><strong>乘方运算：</strong> 最初设计将乘方使用循环转化为多项同一项相乘，这增加了化简后表达式的长度，更改了<code>Var</code>类的属性，存入系数$Ratio$和指数$Power$，对于<code>Expr</code>类的元素，则仍按照循环转化相乘的方法计算，提高了化简后表达式的性能。</li>
</ul>
<h3 id="Homework2-2"><a href="#Homework2-2" class="headerlink" title="Homework2"></a>Homework2</h3><h4 id="Bug分析-1"><a href="#Bug分析-1" class="headerlink" title="Bug分析"></a>Bug分析</h4><p>第二次作业无逻辑bug，而是集中在性能问题上：</p>
<ul>
<li><strong>单项式多次乘方运算：</strong> 第二次作业中，单项式的高阶次方形如$((Factor)^i)^j$，由于括号的出现，在parser过程中会将其解析为仅含一项的<code>Expr</code>，这样运算时，会将其展开为多项。当乘方运算过多时，会出现表达式树层数过深，结点过多的问题，这会大大影响程序的性能乃至程序的可使用性和结果的正确性。</li>
</ul>
<h4 id="优化策略-1"><a href="#优化策略-1" class="headerlink" title="优化策略"></a>优化策略</h4><p>设计最初时，出于对统一性的思考，缺省了对于性能的追求。现对作业过程中所做优化进行记录：</p>
<ul>
<li><strong>单项式多次乘方运算：</strong> 最初设计时，没有考虑多次乘方对于程序性能的影响。调整时在<code>parserTerm()</code>函数中添加特判，当<code>Expr</code>对象中仅含有一个项，且这个项中仅有一个<code>Num</code>、<code>Exp</code>、<code>Var</code>因子，那么将这一个<code>Expr</code>对象取出，加入一个相应因子。</li>
<li><strong>函数处理面向过程：</strong> 最初设计时，将每一个函数解析为<code>Function</code>类，利用解析出的形参在使用中和实参替换，从而达到效果。这样的字符串解析显然过于面向过程，实际上可以将自定义函数式也当作表达式，使用<code>Parser</code>类解析为表达式树（并且形参必定处在叶结点位置），化简表达式时，只需要在对应位置将形参结点替换为实参表达式树，最终将整棵表达式树转换为字符串即可。</li>
<li><strong>多项式合并：</strong> 最初设计时，是将<code>Exp</code>函数中指数作为字符串储存，当字符串中各项相同但位置不同时，就会出现无法合并的问题。这个问题有一个简单的解决方案，即将字符串按照正号拆开，利用字符串处理函数<code>replace()</code>进行字符串减法，来判断两字符串是否相等。笔者才疏学浅，没有想到这一个方法，而是想到了另一个异曲同工的方法：即将<code>Var</code>改为多变量相乘的形式，存储整体系数，各变量变量名，各变量指数。实际上这两种方法是一样的，第一种方法相当于整体存储所有<code>Exp</code>指数之和，第二种方法则相当于按项存储各<code>Exp</code>指数。</li>
</ul>
<h3 id="Homework3-2"><a href="#Homework3-2" class="headerlink" title="Homework3"></a>Homework3</h3><h4 id="Bug分析-2"><a href="#Bug分析-2" class="headerlink" title="Bug分析"></a>Bug分析</h4><p>第三次作业存在一些笔者自身的失误导致的bug，现分享为其他找bug的朋友提供一个思路：</p>
<ul>
<li><p><strong>方法调用时对象错误：</strong> 形如$dx(x^n)$，笔者在添加<code>Var.derive()</code>函数时，建立新的<code>Var</code>对象，但在调用方法时选错对象，导致改变属性时发生错误，从而导致了整个程序未能通过测试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (newPower.compareTo(BigInteger.ZERO) &gt; <span class="number">0</span>) <span class="comment">//当幂函数求导后指数不为零，则仍为变量</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="type">Var</span> <span class="variable">var</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Var</span>(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">          <span class="keyword">var</span>.changeRatio(newRatio, <span class="string">&quot;*&quot;</span>); <span class="comment">//笔者最初并未使用var，导致方法调用不是所希望的对象，出现错误</span></span><br><span class="line">          <span class="keyword">var</span>.changePower(newPower, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">          termFactors.add(<span class="keyword">var</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="优化策略-2"><a href="#优化策略-2" class="headerlink" title="优化策略"></a>优化策略</h4><p>第三次的程序基于第二次的程序，在性能上并未做过多调整。</p>
<ul>
<li><strong><code>Var</code>类存储<code>Exp</code>指数方式更换：</strong> 在第二次作业中，存储字符串形如<code>exp((指数))</code>，在第三次作业中则改为<code>指数</code>。这是一个小改动，但对程序复杂性有一定程度的优化。在迭代处理<code>Exp</code>对象时，更改前，需要对字符串进行处理，提出其中的指数，改动后则不必再对字符串属性做其他处理，可直接使用。</li>
</ul>
<hr>
<h2 id="五、心得体会"><a href="#五、心得体会" class="headerlink" title="五、心得体会"></a>五、心得体会</h2><p>挺过开学的三板斧，终于有时间整理一下在前三周的所学所想。不得不说，虽然经过先导课程和各位学长学姐的提醒，对本课程已经有了足够的心理准备，但一上来还是被打懵了。可能从当初的c语言学习开始，字符串处理就一直不是我喜欢的一个问题，毕竟涉及到多次迭代，各种栈的相关操作，以及各种奇怪不统一的输入数据。但现实中的问题输入都是多样而复杂的，因此统一化的预处理能力是极其有必要的。当我们不能改变环境时，那就努力的去适应环境吧。</p>
<p>小小发泄之后，就谈谈获得的一些经验吧：</p>
<ul>
<li><strong>预习的重要性。</strong> 在寒假时，课程组就将梯度下降法的算法介绍发到公众号中。笔者之所以觉得第一周压力极大，还是因为没有提前进行详尽的预习，对梯度下降法理解还不够深刻。</li>
<li><strong>讨论的重要性。</strong> 三次作业中加入了一节讨论课，在这节课和不同同学讨论之后，对梯度下降法等算法有了更深刻的认识，对于字符串处理的方法也有了更多的想法，对开阔视野和思路极有帮助。</li>
<li><strong>测试的重要性。</strong> 课程组鼓励自建评测机，通过多组数据测试才能更加完全验证程序的正确性，这也是未来工程所要求的能力。笔者对于这部分的思考较为匮乏，还需要向大佬们学习。</li>
</ul>
<p>至于对课程的建议，也没什么想法。硬要说的话，应该是正课课程与先导课程的跳度过大吧。不过公众号上算法的介绍与代码的给出，倒是帮助减少了不少难度。</p>
<p>最后，还是要感谢助教nr学长和gc学姐的帮助。也希望在之后的学习中能再接再厉，继续进步。</p>
]]></content>
      <categories>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象课程Unit2总结</title>
    <url>/2025/03/17/OO/2024%E6%98%A5-OO%E8%AF%BE%E7%A8%8BUnit2%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="2024春-OO课程Unit2总结"><a href="#2024春-OO课程Unit2总结" class="headerlink" title="2024春-OO课程Unit2总结"></a>2024春-OO课程Unit2总结</h1><hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>第二单元的作业的主题是电梯调度，主要涉及到多线程的使用与互相关联。第一次作业主要实现六个互相独立的电梯，同时对每个请求设定了要乘坐电梯的序号；第二次作业放开了乘坐策略，同时增加了<code>Reset</code>策略；第三次作业主要实现了双轨电梯，即互相影响的两个线程。第二单元涉及各种陌生的多线程知识，功能的实现难度不大，但共享对象的访问、原子操作的拆分、线程的休眠、停止时无法唤醒线程使其停止等问题较难纠正。同时由于多线程的随机性，出现bug无法复刻的问题，导致debug十分困难。本篇总结主要是记录一下三次作业的架构设计、各种优缺点分析，以及自身一点心得体会。</p>
<hr>
<h2 id="一、作业架构分析"><a href="#一、作业架构分析" class="headerlink" title="一、作业架构分析"></a>一、作业架构分析</h2><h3 id="Homework1"><a href="#Homework1" class="headerlink" title="Homework1"></a>Homework1</h3><h4 id="题目重点重述"><a href="#题目重点重述" class="headerlink" title="题目重点重述"></a>题目重点重述</h4><p>第一次作业主要实现6个电梯的调度，并且在本次作业中，每个请求都有其要求的电梯序号。因此问题转变为6个相互独立的请求序列，每个电梯负责一个请求序列，互不影响。输入的解析形式是<code>[Time]personId-FROM-fromFloor-TO-toFloor-BY-elevatorId</code>，并按照请求响应种类输出电梯动作<code>ARRIVE</code>、<code>OPEN</code>、<code>CLOSE</code>，乘客动作<code>IN</code>、<code>OUT</code>。</p>
<h4 id="程序UML图"><a href="#程序UML图" class="headerlink" title="程序UML图"></a>程序UML图</h4><p><img src="/images/OO/oo第2单元总结/hw2-1UML图.png" alt="hw2-1UML图"></p>
<p>线程<code>InputThread</code>、<code>ScheduleThread</code>共享一个<code>wholeRequests</code>请求池，读入全部请求至请求池并按照调度策略分配到各电梯的任务池中。线程<code>ScheduleThread</code>、<code>ElevatorThread</code>共享一个<code>tasks</code>任务池，按照调度策略分配到电梯的任务后，电梯根据自身运行策略选择请求执行。第一次作业指定请求的电梯，因此调度策略即按照请求电梯序号分配即可。运行策略暂定为电梯内有乘客，优先满足目标楼层最近的乘客；当电梯内没有乘客而任务池中有请求时，优先前往有乘客的最近楼层；当电梯内没有乘客且任务池中没有请求时，电梯执行等待操作（即该线程对于共享对象<code>tasks</code>上锁进行<code>wait()</code>操作）。</p>
<h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><p>类复杂度表格如图所示：其中<code>OCavg</code>指代平均操作复杂度，<code>OCmax</code> 指代最大操作复杂度，<code>WMC</code> 指代加权方法复杂度</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Class</th>
<th>OCavg</th>
<th>OCmax</th>
<th>WMC</th>
</tr>
</thead>
<tbody>
<tr>
<td>Elevator</td>
<td><strong>4.3</strong></td>
<td><strong>11</strong></td>
<td><strong>43</strong></td>
</tr>
<tr>
<td>InputThread</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>Main</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>RequestQueue</td>
<td>1.25</td>
<td>3</td>
<td><strong>10</strong></td>
</tr>
<tr>
<td>ScheduleThread</td>
<td><strong>2.33</strong></td>
<td><strong>5</strong></td>
<td>7</td>
</tr>
<tr>
<td>TestMain</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
</tbody>
</table>
</div>
<p>可以观察到，<code>Elevator</code>类具有极高的复杂度，这是因为其内部含有多种判别方法（如电梯运行方向判断、电梯是否停止并转运判断、进入电梯人选判断等）。这些判断方法含有多次遍历判断，以期寻找到最优解，因此复杂度较高。</p>
<h4 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h4><p>由于第一次的架构设计较为不合理，部分类代码过于冗长且重复，动作归属混乱且偏向面向过程。因此对整体架构重构，记录如下：</p>
<p><img src="/images/OO/oo第2单元总结/hw2-1UML图改.png" alt="hw2-1UML图改"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Class</th>
<th>OCavg</th>
<th>OCmax</th>
<th>WMC</th>
</tr>
</thead>
<tbody>
<tr>
<td>Customer</td>
<td>1</td>
<td>1</td>
<td>5</td>
</tr>
<tr>
<td>Elevator</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>ElevatorAction</td>
<td><strong>2.36</strong></td>
<td><strong>7</strong></td>
<td><strong>26</strong></td>
</tr>
<tr>
<td>ElevatorScheduler</td>
<td><strong>5</strong></td>
<td><strong>9</strong></td>
<td>10</td>
</tr>
<tr>
<td>InputThread</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>Main</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>RequestQueue</td>
<td>1.73</td>
<td>3</td>
<td><strong>19</strong></td>
</tr>
<tr>
<td>ScheduleThread</td>
<td>2.33</td>
<td>5</td>
<td>7</td>
</tr>
</tbody>
</table>
</div>
<p>可以发现，将<code>Elevator</code>中的动作和电梯调度器提出，可以降低原类的复杂度。同时，由于动作归属更加明确，架构逻辑也更加清晰。</p>
<h3 id="Homework2"><a href="#Homework2" class="headerlink" title="Homework2"></a>Homework2</h3><h4 id="题目重点重述-1"><a href="#题目重点重述-1" class="headerlink" title="题目重点重述"></a>题目重点重述</h4><p>第二次作业在第一次作业的基础上，去除了乘坐特定电梯的限制。即不再为每位乘客划分特定电梯，而是采用估测分数、划分最优电梯的方法，达到局部最优解，并在为电梯分配任务后发出<code>Receive</code>标志。同时增加了<code>Reset</code>指令<code>[Time]RESET-Elevator-elevatorId-peopleLimit-moveTime</code>，当电梯在运行时，发出<code>Reset</code>指令，电梯停止运行，电梯中的乘客尽快离开，电梯重置参数，并将电梯全部任务返回总任务池，重新分配。由于除去<code>Reset</code>指令，划分出去的任务无法重新划分，因此理论上仅能达到局部最优解。</p>
<h4 id="程序UML图-1"><a href="#程序UML图-1" class="headerlink" title="程序UML图"></a>程序UML图</h4><p><img src="/images/OO/oo第2单元总结/hw2-2UML图.png" alt="hw2-2UML图"></p>
<p>本次作业中，对整体架构进行了进一步的修改，使得动作归属更加明确，逻辑更加清晰，并保障在线程类中除去<code>run()</code>方法并无过多无关方法。本次作业中，新增<code>ResetThread</code>线程，获得<code>Reset</code>指令并进行分配，允许<code>Elevator</code>使用<code>wholeRequests</code>请求池，将<code>Reset()</code>操作加入<code>ElevartorThread</code>的运行流程之中，先使用<code>leaveAllPeople()</code>让电梯内人员在当前楼层下电梯，再使用<code>returnResetPeople()</code>将该电梯的全部乘坐请求返回<code>wholeRequests</code>中，等待重新分配。新增<code>GlobalScheduler</code>类，获得每个电梯的分数，并进行局部最优的电梯分配。新增<code>Observer</code>类，内部全部属性方法均为全局静态，用来总体观察当前指令执行情况。当输入一条指令时未执行指令数量加1，执行完成一条指令时未执行指令数量减1，输入完成时执行<code>inputEnd()</code>方法。当<code>number == 0</code>且<code>end == true</code>时可以唤醒全部线程并结束程序。</p>
<h4 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h4><p>类复杂度表格如图所示：其中<code>OCavg</code>指代平均操作复杂度，<code>OCmax</code> 指代最大操作复杂度，<code>WMC</code> 指代加权方法复杂度</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Class</th>
<th>OCavg</th>
<th>OCmax</th>
<th>WMC</th>
</tr>
</thead>
<tbody>
<tr>
<td>Customer</td>
<td>1</td>
<td>1</td>
<td>5</td>
</tr>
<tr>
<td>ElevatorAction</td>
<td>2</td>
<td>7</td>
<td><strong>32</strong></td>
</tr>
<tr>
<td>ElevatorScheduler</td>
<td><strong>3.75</strong></td>
<td><strong>10</strong></td>
<td>15</td>
</tr>
<tr>
<td>ElevatorThread</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>GlobalScheduler</td>
<td>2.5</td>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>InputThread</td>
<td>3</td>
<td>5</td>
<td>6</td>
</tr>
<tr>
<td>Main</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>Observer</td>
<td>1</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>RequestQueue</td>
<td>1.79</td>
<td>3</td>
<td><strong>25</strong></td>
</tr>
<tr>
<td>ResetThread</td>
<td>2</td>
<td>4</td>
<td>6</td>
</tr>
<tr>
<td>ScheduleThread</td>
<td><strong>3.33</strong></td>
<td><strong>7</strong></td>
<td>10</td>
</tr>
</tbody>
</table>
</div>
<p>可以观察到，相比于第一次作业，大部分类复杂度降低，证明架构调整取得了较好的效果。同时也发现部分类最大操作复杂度和加权方法复杂度有一定提高，这是因为加入了新的有一定复杂度的方法（如在<code>ElevatorScheduler</code>中加入了判断是否进行开关门操作的方法，而这在上一次作业中是在<code>ElevatorAction</code>中的）。应该指出，类复杂度仍然较高，还有很大优化空间。</p>
<h3 id="Homework3"><a href="#Homework3" class="headerlink" title="Homework3"></a>Homework3</h3><h4 id="题目重点重述-2"><a href="#题目重点重述-2" class="headerlink" title="题目重点重述"></a>题目重点重述</h4><p>第三次作业在第二次作业的基础上，增加了重置普通电梯为双轨电梯的<code>Reset</code>操作：<code>[Time]RESET-DCElevator-elevatorId-exchangeFloor-peopleLimit-moveTime</code>。该<code>Reset</code>操作与普通<code>Reset</code>操作基本相同，只是在<code>Reset</code>操作结束后，关闭普通电梯，增加双轨电梯，该双轨电梯分为A轿厢和B轿厢，A轿厢的运动范围是<code>[1, exchangeFloor]</code>，B轿厢的运动范围是<code>[exchangeFloor, 11]</code>，两个轿厢相互独立，但不能同时处于交换楼层。</p>
<h4 id="程序UML图-2"><a href="#程序UML图-2" class="headerlink" title="程序UML图"></a>程序UML图</h4><p><img src="/images/OO/oo第2单元总结/hw2-3UML图.png" alt="hw2-3UML图"></p>
<p>本次作业中，为了降低双轨电梯新增线程的难度，对原架构又进行了一定的调整，进行了一定的集合和简化。主要是新增了一系列关于双轨电梯的类，如<code>DoubleElevatorThread</code>双轨电梯单轿厢的运行线程类，<code>DoubleElevator</code>双轨电梯宏观调控类（负责查询两个轿厢的状态），<code>DoubleElevatorAction</code>双轨电梯单轿厢的动作类。同时，将原<code>ElevatorThread</code>进行修改，未进行<code>DoubleCarReset</code>操作时，是正常的单轿厢运行线程；进行<code>DoubleCarReset</code>操作后，是双轨电梯任务分配线程，主要功能是在<code>ScheduleThread</code>将任务池中请求分配进入各电梯<code>tasks</code>后，将<code>tasks</code>中请求分配进入两个轿厢的任务序列<code>tasksA</code>和<code>tasksB</code>中（实际上这样的设计固然能降低程序结束时线程未结束的问题，但从逻辑上看是极其不合理的，应该将其分为两个线程）。</p>
<h4 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h4><p>类复杂度表格如图所示：其中<code>OCavg</code>指代平均操作复杂度，<code>OCmax</code> 指代最大操作复杂度，<code>WMC</code> 指代加权方法复杂度</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Class</th>
<th>OCavg</th>
<th>OCmax</th>
<th>WMC</th>
</tr>
</thead>
<tbody>
<tr>
<td>Customer</td>
<td>1</td>
<td>1</td>
<td>5</td>
</tr>
<tr>
<td>DoubleElevator</td>
<td>1</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>DoubleElevatorAction</td>
<td><strong>3.57</strong></td>
<td><strong>13</strong></td>
<td><strong>50</strong></td>
</tr>
<tr>
<td>DoubleElevatorThread</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>ElevatorAction</td>
<td>2.63</td>
<td><strong>9</strong></td>
<td><strong>50</strong></td>
</tr>
<tr>
<td>ElevatorThread</td>
<td>4</td>
<td>6</td>
<td>12</td>
</tr>
<tr>
<td>GlobalScheduler</td>
<td>2.5</td>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>InputThread</td>
<td><strong>3.5</strong></td>
<td>6</td>
<td>7</td>
</tr>
<tr>
<td>Main</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>Observer</td>
<td>1</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>RequestQueue</td>
<td>1.69</td>
<td>3</td>
<td>27</td>
</tr>
<tr>
<td>ResetThread</td>
<td>3</td>
<td>4</td>
<td>9</td>
</tr>
<tr>
<td>ScheduleThread</td>
<td>3.33</td>
<td>6</td>
<td>10</td>
</tr>
</tbody>
</table>
</div>
<p>可以观察到，本次作业中部分类的复杂度极高，这是因为为了正确性将部分方法进行了集合，并且出现了较为面向过程的问题。这部分还需要对架构进行进一步的优化，使得逻辑更加清晰，复杂度更低。</p>
<hr>
<h2 id="二、架构重点实现分析"><a href="#二、架构重点实现分析" class="headerlink" title="二、架构重点实现分析"></a>二、架构重点实现分析</h2><h3 id="Homework1-1"><a href="#Homework1-1" class="headerlink" title="Homework1"></a>Homework1</h3><p>第一次作业程序中主要有三个实现的重点：</p>
<ul>
<li><p><strong>各线程间请求队列共享：</strong> 主要是线程<code>InputThread</code>、<code>ScheduleThread</code>共享一个<code>wholeRequests</code>请求池和线程<code>ScheduleThread</code>、<code>Elevator</code>共享一个<code>tasks</code>任务池。执行过程中，这两个共享请求队列需要作为锁存在于线程间，保证不会产生对于请求池<code>isEnd</code>、<code>isEmpty</code>等属性的不一致。</p>
</li>
<li><p><strong><code>Elevator</code>操作实现：</strong> 在程序中，电梯主要有<code>acquireGoal()</code>、<code>move()</code>、<code>transfer()</code>（内含<code>enterPeople</code>、<code>leavePeople</code>操作）等操作以及<code>isFull()</code>、<code>isEmpty()</code>、<code>needTransfer()</code>等判断。这些方法共同构成了获得任务池后运行的电梯线程。</p>
</li>
<li><p><strong><code>Elevator</code>运行策略：</strong> 本次作业不需要实现调度策略，仅需要自行实现电梯运行策略。本次作业的运行策略设计为：电梯内有乘客，优先满足目标楼层最近的乘客；当电梯内没有乘客且任务池中有请求时，优先前往有乘客的最近楼层；当电梯内没有乘客且任务池中没有请求时，电梯执行等待操作（即该线程对于锁<code>tasks</code>进行<code>wait()</code>操作）。</p>
</li>
</ul>
<h3 id="Homework2-1"><a href="#Homework2-1" class="headerlink" title="Homework2"></a>Homework2</h3><p>第二次作业程序中主要有三个实现重点：</p>
<ul>
<li><strong>电梯<code>Reset</code>操作：</strong> 电梯<code>Reset</code>操作主要有以下几个步骤：<code>isReset</code>标志置true以防止在<code>Reset</code>过程中再获得指令、全部电梯内乘客下电梯（通过<code>inpeople.isEmpty()</code>标志判断是否需要进行这一步）、电梯任务池中全部指令返回总任务池、更改电梯参数、<code>isReset</code>标志置false并执行<code>Observer.subRequest()</code>方法（本次<code>Reset</code>指令成功执行，未执行操作数减1）。</li>
<li><strong><code>Observer</code>静态全局观察类：</strong> 本次作业实现了<code>Observer</code>类，以此来判断程序是否执行完成，各线程可以停止。类之中属性全部设置有<code>static</code>属性，可以在全局中使用。也可以在电梯线程无可执行指令时唤醒调度器线程，通过判断<code>wholeRequests.isEmpty()</code>、<code>wholeRequests.isEnd()</code>、<code>elevatorTasks.isEmpty()</code>、<code>elevatorInPeople.isEmpty()</code>、<code>elevatorResetRequest == null</code>均为true来决定是否结束程序（实际上后面三个对象都是<code>private</code>属性，需在电梯内部实现判断，笔者只是为了表述方便）。</li>
<li><strong>电梯调度策略：</strong> 本次作业不再强制指定运输乘客的电梯，自行设置调度策略。受限于完成时间，笔者本次仅采取了一种简单的电梯得分策略，并按照得分最高电梯赢得竞争的原则分配。本次作业中，将<code>targetFloor</code>、<code>nowFloor</code>、<code>moveTime</code>、<code>inPeople.size()</code>、<code>tasks.size()</code>作为评判属性，以层次分析法分配权重（实际上层次分析法主观性极强，需要不停尝试），并由<code>GlobalScheduler</code>计算获得最终得分并分配给最佳电梯。</li>
</ul>
<h3 id="Homework3-1"><a href="#Homework3-1" class="headerlink" title="Homework3"></a>Homework3</h3><p>第三次作业程序中主要有三个实现重点：</p>
<ul>
<li><p><strong><code>DoubleCarReset</code>操作后双轿厢的启动：</strong> 本次作业实现了<code>DoubleElevator</code>类，其中的<code>begin()</code>方法用于启动两个电梯线程。具体操作为在接收到<code>Reset</code>指令后，创建新的<code>DoubleElevator</code>对象，并调用<code>begin()</code>方法。具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在接收到Reset指令后，创建新的doubleElevator并启动线程</span></span><br><span class="line"><span class="keyword">if</span> (request <span class="keyword">instanceof</span> DoubleCarResetRequest)</span><br><span class="line">       &#123;</span><br><span class="line">           resetEnd = <span class="literal">true</span>;</span><br><span class="line">           <span class="type">DoubleElevator</span> <span class="variable">doubleElevator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleElevator</span>(id, peopleLimit, moveTime, bothFloor,</span><br><span class="line">                   queueA, queueB, tasks, taskPool);</span><br><span class="line">           doubleElevator.begin();</span><br><span class="line">       &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//双轿厢线程的启动</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">begin</span><span class="params">()</span></span><br><span class="line">   	&#123;</span><br><span class="line">       	<span class="type">DoubleElevatorThread</span> <span class="variable">elevatorThreadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleElevatorThread</span>(<span class="string">&quot;A&quot;</span>, elevatorA);</span><br><span class="line">       	elevatorThreadA.start();</span><br><span class="line">       	<span class="type">DoubleElevatorThread</span> <span class="variable">elevatorThreadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleElevatorThread</span>(<span class="string">&quot;B&quot;</span>, elevatorB);</span><br><span class="line">       	elevatorThreadB.start();</span><br><span class="line">   	&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>双轿厢电梯动作：</strong> 双轿厢电梯可看作是两个同质的轿厢，因此只需要实现单个轿厢的动作即可。单个轿厢动作与普通电梯电梯基本相同，不同点主要有以下几点：换乘楼层有电梯时不可前往并休眠一定时间、部分乘客强制要求在换乘楼层下电梯、<code>inPeople.size() == 0 &amp;&amp; tasks.getSize() == 0</code>成立时不可在换乘层休眠。</p>
</li>
<li><strong>双轿厢监控器：</strong>双轿厢并不独立，之间会互相影响，因此设立监控器，随时观测两个轿厢的状态。两个轿厢间主要的影响是不能同时位于换乘层，又可以分为换乘层有轿厢时另一轿厢不可前往、有轿厢前往换乘层时另一轿厢不可前往、位于换乘层轿厢还未离开换乘层时另一轿厢不可前往（实际上这条条件较为宽松，因为两轿厢速度相同，当换乘层轿厢离开的同时另一轿厢前往换乘层不会发生冲突）。设置<code>have</code>属性代表换乘层是否有轿厢，当轿厢确定换乘层为目标时<code>have</code>设置为<code>true</code>，轿厢完全离开换乘层时<code>have</code>设置成<code>false</code>，在读取和设置时将<code>have</code>上锁，保证不会出现线程冲突的问题。</li>
</ul>
<hr>
<h2 id="三、Bug分析及程序优化"><a href="#三、Bug分析及程序优化" class="headerlink" title="三、Bug分析及程序优化"></a>三、Bug分析及程序优化</h2><h3 id="Homework1-2"><a href="#Homework1-2" class="headerlink" title="Homework1"></a>Homework1</h3><h4 id="Bug分析"><a href="#Bug分析" class="headerlink" title="Bug分析"></a>Bug分析</h4><p>本次作业中，由于对于锁的理解不深，出现了<code>ConcurrentModificationException</code>的错误。这是因为未将遍历过程化为原子操作，在遍历的过程中发现了锁改变，导致遍历范围改变的问题，问题代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (PersonRequest request : tasks.getRequests()) <span class="comment">//getRequests()方法具有synchronized属性</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span> (Math.abs(request.getFromFloor() - nowFloor) &lt; delta) </span><br><span class="line">          &#123;</span><br><span class="line">              delta = Math.abs(request.getFromFloor() - nowFloor);</span><br><span class="line">              goalRequest = request;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p><code>getRequests()</code>方法是个<code>synchronized</code>方法，但可以发现，每次循环均要访问<code>getRequests()</code>方法，在访问过程中会上锁开锁，在开锁后<code>tasks</code>中的<code>requests</code>属性会发生变化，故<code>getRequests()</code>的结果会不断变化，因此导致循环范围改变，产生错误。</p>
<h4 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h4><p>设计最初时，缺省了一定的程序鲁棒性以及对于性能的追求。现对作业过程中所做优化进行记录：</p>
<ul>
<li><p><strong>迭代器的使用：</strong> 当乘客离开电梯时，有可能出现电梯内所有乘客都要离开电梯的情况，对应到程序中就是需要逐一去除<code>inPeople</code>集合中的全部元素。使用遍历+<code>remove</code>的方法具有一定危险性，因此可以替换为迭代器删除的方法，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!inPeople.isEmpty())</span><br><span class="line">      &#123;</span><br><span class="line">          Iterator&lt;PersonRequest&gt; iterator = inPeople.iterator();</span><br><span class="line">          <span class="keyword">while</span> (iterator.hasNext())</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="type">PersonRequest</span> <span class="variable">request</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">              <span class="keyword">if</span> (request.getToFloor() == nowFloor)</span><br><span class="line">              &#123;</span><br><span class="line">                  iterator.remove();</span><br><span class="line">                  <span class="type">int</span> <span class="variable">personId</span> <span class="operator">=</span> request.getPersonId();</span><br><span class="line">                  TimableOutput.println(<span class="string">&quot;OUT-&quot;</span> + personId + <span class="string">&quot;-&quot;</span> + nowFloor + <span class="string">&quot;-&quot;</span> + id);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>电梯运行策略优化：</strong> 当前策略显然仍不是最优解，如以下情况：电梯处于1楼，此时任务池加入请求<code>[1.0]1-FROM-10-TO-3-BY-1</code>和<code>[1.0]2-FROM-9-TO-2-BY-1</code>，按照当前策略只会进入2号，之后向2楼出发。显然在电梯未满的情况下，让1号进入一同向2楼出发更优。可以可以通过比较直接向目标楼层出发和完成另外一条请求的收益（即直接向目标楼层出发再返回让1号进入需要经过的楼层和让1号进入再向目标楼层出发需要经过的楼层）。</p>
</li>
</ul>
<h3 id="Homework2-2"><a href="#Homework2-2" class="headerlink" title="Homework2"></a>Homework2</h3><h4 id="Bug分析-1"><a href="#Bug分析-1" class="headerlink" title="Bug分析"></a>Bug分析</h4><p>本次作业中，主要出现了死锁的问题。当电梯线程完成全部任务并输入已经结束时，唤醒调度器线程，调度器线程为所有电梯线程设置结束标志，并唤醒全部电梯线程，最终程序结束。这个思路会出现某一电梯线程无法结束的问题。经过很长一段时间debug后，终于找到了问题：当调度器被唤醒并设置结束标志之后，电梯又进入了休眠状态。问题代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调度器线程整体流程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">//调度器线程结束判断</span></span><br><span class="line">           <span class="keyword">if</span> (Observer.allEnd())</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; queues.size(); i++)</span><br><span class="line">               &#123;</span><br><span class="line">                   queues.get(i).setEnd(<span class="literal">true</span>); <span class="comment">//为每个电梯线程设置结束标志，并唤醒电梯线程</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           ......</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电梯线程整体流程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (action.finished()) <span class="comment">//判断电梯是否停止，并唤醒调度器流程</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           action.work(); <span class="comment">//work()方法含有如果tasks为空则线程休眠的功能</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>经过排查，发现当电梯线程位于<code>action.finished()</code>方法时，唤醒调度器，两个线程同时进行。当调度器线程为电梯<code>setEnd(true)</code>时，电梯线程位于<code>action.work()</code>方法内，但还未到判断tasks是否为空的位置。当调度器完成<code>setEnd(true)</code>操作后，电梯线程到达判断tasks是否为空的位置，并判断为空休眠线程，导致最终程序无法停止，从而引发<code>RTLE</code>的问题。解决方案也很简单，在判断tasks是否为空的位置加上条件语句<code>if(!isEnd())</code>，表示如果没有结束可以休眠，如果已经获得结束标志不可以休眠。</p>
<h4 id="优化策略-1"><a href="#优化策略-1" class="headerlink" title="优化策略"></a>优化策略</h4><p>设计最初时，由于听取过多不同关于架构的意见（<del>所以还是要坚持自己的想法，毕竟别人也不知道你是怎么设计的，有些建议会带来负面效果</del>），加之自身理解不深，导致debug的方向出现偏差，从而引发最终时间、提交次数不够的问题，也就没有实现自己关于总体调度器的一些设想。现对作业过程中所做的未做的优化进行记录：</p>
<ul>
<li><strong>CPU运行时间缩减：</strong> 笔者进行设计的最初妄图逐个击破，先添加<code>Reset</code>指令，便随意设计了一个分配方案（按照乘客的序号分配，第<code>i</code>号乘客分配给<code>i % 6</code>号电梯）。测试时发现出现了<code>ScheduleThread</code>线程CPU使用时间过长的问题，先入为主地认为是在分配完所有任务后<code>ScheduleThread</code>线程没有进入休眠而是进行轮询消耗大量时间，因此更改了众多方法中的<code>notifyAll()</code>方法（后期发现不是这个问题后给自己增添了许多工作量）。实际上是因为从总任务池中取出指令分配时，需要判断当前是否有电梯可以接受分配，如果不能分配需要将指令放回任务池。而如果使用上文的分配方法，仅查询一个电梯，可分配概率会大幅度降低，导致需要不停进行取出、放回的操作，从而增长CPU使用时间。</li>
<li><strong>影子电梯：</strong> 即在分配指令时，按照当前电梯状态，计算为此电梯分配与不分配该指令的分数差。可以按照课程组给出的性能分得分方式：$s=15×(0.3r(T<em>{run})+0.3r(MT)+0.4r(W))$获得各电梯的分数差。得分方式也可以简化为仅与运行时间$T</em>{run}$、耗电量$W$相关，并对得分进行归一化处理：$s = 0.6 \times \frac{1}{T<em>{run}} + 0.4 \times \frac{1}{W}$。而影子电梯即是设置以当前电梯状态为初始状态的虚拟电梯，该电梯基本操作与普通电梯相同，但不进行真实的延时操作，模拟真实电梯完成两次任务序列的过程，并将两个变量表示成仅与移动次数$N</em>{move}$、转运次数$N<em>{transfer}$的函数：$T</em>{run} = t<em>{move_perfloor} \times N</em>{move} + 0.4 \times N<em>{transfer}$、$W = 0.4 \times N</em>{move} + 0.2 \times N_{transfer}$。</li>
<li><strong>分配限制：</strong> 本次作业中，发现了一种较为影响程序性能的特殊情况。即当六部电梯仅有一部电梯不处于<code>isReset</code>状态时，此时调度器会将全部任务分配到该电梯的任务池中。由于分配入任务池中的请求无法取出重新分配，导致当其余五部电梯结束<code>Reset</code>后总任务池中不存在请求，在之后程序的进行中其余电梯会一直处于休眠状态。解决方法很简单，将在电梯分配任务时判断是否可以分配的条件改为<code>!isReset &amp;&amp; (inPeople.size() + tasks.getSize() &lt; 10)</code>。</li>
</ul>
<h3 id="Homework3-2"><a href="#Homework3-2" class="headerlink" title="Homework3"></a>Homework3</h3><h4 id="Bug分析-2"><a href="#Bug分析-2" class="headerlink" title="Bug分析"></a>Bug分析</h4><p>第三次作业暂无bug。</p>
<h4 id="优化策略-2"><a href="#优化策略-2" class="headerlink" title="优化策略"></a>优化策略</h4><p>第三次作业基于第二次作业的架构，对于性能并无太大影响，因此未对性能进行优化。作业设计中，对于程序的泛用性具有一定的思考，现对该可能的优化做一定的记录：</p>
<ul>
<li><strong>电梯轿厢泛用性设计：</strong> 前两次作业电梯均为普通单轿厢电梯，第三次作业电梯为双轿厢电梯，其中每次调控的原子对象实际上是单个电梯轿厢。因此我们可以设置电梯轿厢动作，上层设置电梯调度器，宏观观察多个轿厢，进行调控。每个轿厢具有运行楼层上下限，在上下限之间运动，在换乘楼层进行换乘操作。</li>
</ul>
<hr>
<h2 id="四、心得体会"><a href="#四、心得体会" class="headerlink" title="四、心得体会"></a>四、心得体会</h2><p>挺过开学的三板斧，又被到期中这段时间的各项事情狠狠地扇了一巴掌。不得不说，各科课程的难度逐渐增加，又涉及到各种其他奇奇怪怪的事情，导致没有足够的精力去设计更加科学的框架、去实现预想的更加高效的调度方法、去对程序进行更加极限的普适性鲁棒性测试。书山有路勤为径，学海无涯苦作舟。学习的生涯必然是痛并快乐着的，希望自己能挺过这些痛苦，翻过这些山，爬过这些坎，站在山顶上欣赏日出吧。</p>
<p>小小发泄之后，就谈谈获得的一些经验吧：</p>
<ul>
<li><strong>架构设计的重要性。</strong> 本次作业架构设计不是很合理，所以在第一次作业完成后又对整体架构进行了重构调整，让各个类更加简洁清晰，逻辑也更加严密。</li>
<li><strong>讨论的重要性。</strong> 三次作业中加入了一节讨论课，在这节课和不同同学讨论之后，对锁、线程的休眠唤醒等多线程操作有了更深刻的认识，对于处理中可能遇到的细节性问题也有了更多的想法，对开阔视野和思路极有帮助。</li>
<li><strong>测试的重要性。</strong> 测试测试测试，重要的事情说三遍。课程组鼓励自建评测机，通过多组数据测试才能更加完全验证程序的正确性，这也是未来工程所要求的能力。<del>（由于笔者的拖延症，第三次作业留给测试的时间很短，导致互测被爆杀）</del></li>
</ul>
<p>至于对课程的建议，本单元是真没什么想法了。公众号上发的推送对于多线程介绍很清晰详细，作业描述、各项课程支援的说明都很明白，作业的承接跨度也做得很好，应该说很难再吹毛求疵了。</p>
<p>最后，还是要感谢助教wsj学长的帮助。也希望在之后的学习中能再接再厉，继续进步。</p>
]]></content>
      <categories>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象课程Unit3总结</title>
    <url>/2025/03/17/OO/2024%E6%98%A5-OO%E8%AF%BE%E7%A8%8BUnit3%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="2024春-OO课程Unit3总结"><a href="#2024春-OO课程Unit3总结" class="headerlink" title="2024春-OO课程Unit3总结"></a>2024春-OO课程Unit3总结</h1><hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>第三单元作业的主题是社交网络的构建和维护，主要学习内容涉及到程序规格的确认以及<code>JML</code>语言的阅读与书写。第一次作业主要实现基本的社交网络，内部单元仅有<code>Person</code>，主要操作针对网络和个人，同时书写对于<code>queryTripleSum()</code>方法的测试；第二次作业增加了<code>Tag</code>标签类，将部分人标为同一群组，对群组进行整体操作，同时书写对于<code>queryCoupleSum()</code>方法的测试；第三次作业增加了<code>Message</code>信息类，实现人与人、人与群组间信息通讯，同时书写对于<code>deleteColeEmoji()</code>方法的测试。第三单元源代码实现主要涉及<code>JML</code>代码的阅读与实际功能的实现转化，对照着注释，功能的实现难度不大，主要是各自性能高要求导致需要对部分属性进行动态维护，引入多项图数据处理方法。测试代码套路较为统一，按照<code>JML</code>描述即可完成测试，主要是练习参数化测试。本篇总结主要是记录一下三次作业的具体实现、各种优缺点分析，以及自身一点心得体会。</p>
<hr>
<h2 id="一、作业架构分析"><a href="#一、作业架构分析" class="headerlink" title="一、作业架构分析"></a>一、作业架构分析</h2><h3 id="Homework1"><a href="#Homework1" class="headerlink" title="Homework1"></a>Homework1</h3><h4 id="题目重点重述"><a href="#题目重点重述" class="headerlink" title="题目重点重述"></a>题目重点重述</h4><p>第一次作业主要实现仅含<code>Person</code>元素的无向图网络，以<code>person</code>作为网络节点，<code>acquaintance</code>作为网络连接边，并以<code>value</code>作为边权重。程序要求实现对于网络的一系列功能，可分为对<code>person</code>节点的操作与对<code>acquaintance</code>边的操作。具体有网络增删节点、增加边、调整边权重等修改操作，查询块数量（所有相连节点构成一个块）、查询三角形数量（三个节点两两相连构成一个三角形）、查询两节点是否相连、查询边权重等查询操作。</p>
<h4 id="程序UML图"><a href="#程序UML图" class="headerlink" title="程序UML图"></a>程序UML图</h4><p><img src="/images/OO/oo第3单元总结/hw3-1UML图.png" alt="hw3-1UML图"></p>
<p>本次作业含有四种异常处理，包括两节点不含关系、网络不含节点、获得同一节点、获得同一关系等异常。在网络操作发生错误访问时要抛出相应异常。<code>Counter</code>作为计数器，记录各异常发生次数。主要功能类是<code>MyPerson</code>、<code>MyNetwork</code>类，并在其中进行各项修改和查询操作。<code>DisjointSet</code>作为并查集类，用于简化块相关操作，提高程序性能。</p>
<h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><p>类复杂度表格如图所示：其中<code>OCavg</code>指代平均操作复杂度，<code>OCmax</code> 指代最大操作复杂度，<code>WMC</code> 指代加权方法复杂度</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Class</th>
<th>OCavg</th>
<th>OCmax</th>
<th>WMC</th>
</tr>
</thead>
<tbody>
<tr>
<td>Counter</td>
<td>1.25</td>
<td>2</td>
<td>5</td>
</tr>
<tr>
<td>DisjointSet</td>
<td><strong>2.57</strong></td>
<td><strong>5</strong></td>
<td><strong>18</strong></td>
</tr>
<tr>
<td>Main</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>MyEqualPersonIdException</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>MyEqualRelationException</td>
<td>1.5</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>MyNetwork</td>
<td><strong>2.5</strong></td>
<td><strong>6</strong></td>
<td><strong>30</strong></td>
</tr>
<tr>
<td>MyPerson</td>
<td>1.38</td>
<td>2</td>
<td><strong>18</strong></td>
</tr>
<tr>
<td>MyPersonIdNotFoundException</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>MyRelationNotFoundException</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
</tbody>
</table>
</div>
<p>可以观察到，相比前两单元的架构复杂度，本单元复杂度有所降低，证明笔者的架构设计还需进一步练习与学习。本次作业中，复杂度最高的是<code>MyNetwork</code>、<code>DisjointSet</code>两个类。在<code>MyNetwork</code>类中，多个函数涉及到多分支判断，复杂度较高。<code>DisjointSet</code>类主要有查找根节点、合并块、整合拆分块等操作，而这些操作涉及遍历操作，因此复杂度较高。</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>本次作业要求对<code>MyNetwork</code>中的<code>queryTripleSum()</code>函数进行测试，测试库使用<code>JUnit4</code>。主要测试了函数结果计算是否正确，及函数查询前后原属性是否改变。测试数据主要为仅有节点的网络和随机构建联系的网络。结果是否正确测试策略是调用函数获得测试结果，按照<code>JML</code>构建正确的计算函数并获得正确结果，进行比对。该方法作为一个纯查询型的方法，不应改变网络的任何属性。属性是否改变测试策略是构建两个网络，一个始终不变，作为对照组；一个调用<code>queryTripleSum()</code>方法，作为变量组。比对调用方法前后的两个网络，当两个网络属性相同时，证明函数调用没有改变网络属性。</p>
<h3 id="Homework2"><a href="#Homework2" class="headerlink" title="Homework2"></a>Homework2</h3><h4 id="题目重点重述-1"><a href="#题目重点重述-1" class="headerlink" title="题目重点重述"></a>题目重点重述</h4><p>本次作业在第一次作业的基础上，增加了<code>Tag</code>标签类（同一标签可记为一个群组，在后续操作中也是对群组整体操作）。每个群组可以加入多个<code>Person</code>，群组具有群组的各项操作。具体包含增删<code>person</code>的基础群组维护操作，查询群组内<code>value</code>数值、查询群组内<code>person</code>的年龄方差特征等。对于<code>Network</code>，新增了查询某人最佳关系、查询网络中的<code>couple</code>数量、查询两个人之间的最短路径（即最短通过几人可以和对方取得联系）长度等操作。作业的主要难度在于群组<code>value</code>数值、最佳关系等对于性能要求较高，需要动态维护；最短路径需要借助经典算法减少查询时间。</p>
<h4 id="程序UML图-1"><a href="#程序UML图-1" class="headerlink" title="程序UML图"></a>程序UML图</h4><p><img src="/images/OO/oo第3单元总结/hw3-2UML图.png" alt="hw3-2UML图"></p>
<p>本次作业新增四种异常，无法找到路径、人物与任何人均无联系、人物不含群组、人物含有相同编号群组。同样使用<code>Counter</code>作为计数器，记录各异常发生次数。新增主要功能类<code>MyTag</code>，在其中进行群组的相关查询增删操作。对于网络，新增<code>MyNetworkFeature</code>类，作为查询网络特征类，包含网络的多项查询功能，降低网络类复杂度。</p>
<h4 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h4><p>类复杂度表格如图所示：其中<code>OCavg</code>指代平均操作复杂度，<code>OCmax</code> 指代最大操作复杂度，<code>WMC</code> 指代加权方法复杂度</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Class</th>
<th>OCavg</th>
<th>OCmax</th>
<th>WMC</th>
</tr>
</thead>
<tbody>
<tr>
<td>Counter</td>
<td>1.25</td>
<td>2</td>
<td>5</td>
</tr>
<tr>
<td>DisjointSet</td>
<td><strong>2.57</strong></td>
<td><strong>5</strong></td>
<td>18</td>
</tr>
<tr>
<td>Main</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>MyAcquaintanceNotFoundException</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>MyEqualPersonIdException</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>MyEqualRelationException</td>
<td>1.5</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>MyEqualTagIdException</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>MyNetwork</td>
<td><strong>3.05</strong></td>
<td><strong>8</strong></td>
<td><strong>64</strong></td>
</tr>
<tr>
<td>MyNetworkFeature</td>
<td>2.12</td>
<td><strong>5</strong></td>
<td>17</td>
</tr>
<tr>
<td>MyPathNotFoundException</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>MyPerson</td>
<td>1.71</td>
<td>4</td>
<td><strong>41</strong></td>
</tr>
<tr>
<td>MyPersonIdNotFoundException</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>MyRelationNotFoundException</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>MyTag</td>
<td>2.18</td>
<td>4</td>
<td>24</td>
</tr>
<tr>
<td>MyTagIdNotFoundException</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
</tbody>
</table>
</div>
<p>可以观察到，相较于上一次作业，尽管增加了<code>MyNetworkFeature</code>类降低复杂度，本次作业<code>MyNetwork</code>复杂度仍然有所上升。这是因为增加了部分函数含有多分支选择，增加了复杂度。其余类复杂度较为正常。</p>
<h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p>本次作业要求对<code>MyNetwork</code>中的<code>queryCoupleSum()</code>函数进行测试，测试库使用<code>JUnit4</code>。主要测试了函数结果计算是否正确，及函数查询前后原属性是否改变。测试数据主要为仅有节点的网络和随机构建联系的网络。结果是否正确测试策略是调用函数获得测试结果，按照<code>JML</code>构建正确的计算函数并获得正确结果，进行比对。该方法作为一个纯查询型的方法，不应改变网络的任何属性。属性是否改变测试策略是构建两个网络，一个始终不变，作为对照组；一个调用<code>queryCoupleSum()</code>方法，作为变量组。比对调用方法前后的两个网络，当两个网络属性相同时，证明函数调用没有改变网络属性。相较于第一次作业，本次作业测试在思路架构上无较大变化。</p>
<h3 id="Homework3"><a href="#Homework3" class="headerlink" title="Homework3"></a>Homework3</h3><h4 id="题目重点重述-2"><a href="#题目重点重述-2" class="headerlink" title="题目重点重述"></a>题目重点重述</h4><p>第三次作业在第二次作业的基础上，增加了<code>Message</code>类及关于信息的操作。<code>Message</code>类有三个子类，分别为表情信息<code>EmojiMessage</code>、通知信息<code>NoticeMessage</code>、红包信息<code>RedEnvelopeMessage</code>。对于每类信息，又有两种信息类型，单人信息（即单对单，单人向单人发送信息）和群组信息（即单对多，单人向群组发送信息）。所有信息存入网络属性<code>messages</code>中，网络新增方法加入删除信息，发送信息，清除热度较低的表情，清除某人所收到的全部通知信息。</p>
<h4 id="程序UML图-2"><a href="#程序UML图-2" class="headerlink" title="程序UML图"></a>程序UML图</h4><p><img src="/images/OO/oo第3单元总结/hw3-3UML图.png" alt="hw3-3UML图"></p>
<p>本次作业新增四种异常，未存储当前表情、存储表情序号相等、存储信息序号相等、无法获得待查询信息。同样使用<code>Counter</code>作为计数器，记录各异常发生次数。新增功能类主要是<code>Message</code>类，含有<code>id</code>、<code>socialValue</code>、<code>type</code>等通用属性，三类信息存储有不同的特殊信息特殊属性：<code>EmojiMessage</code>含有表情序号<code>emojiId</code>（相同的<code>emojiId</code>代表同一类表情），<code>NoticeMessage</code>含有通知内容<code>string</code>，<code>RedEnvelopeMessage</code>含有红包价值<code>money</code>。而对于每类信息的不同对单对群类型，又有不同操作：对于<code>EmojiMessage</code>和<code>NoticeMessage</code>，对单仅<code>person2</code>接收信息，对群则<code>tag</code>内全部成员都接收信息（<code>EmojiMessage</code>需另外对当前<code>emojiId</code>类表情的热度加一）；对于<code>RedEnvelopeMessage</code>，对单<code>person1</code>减少红包等值的<code>money</code>，<code>person2</code>增加红包等值的<code>money</code>，对群<code>tag</code>内全部成员增加<code>messageMoney / tagSize</code>等值的<code>money</code>，<code>person1</code>减少<code>tagSize * (messageMoney / tagSize)</code>等值的<code>money</code>（这里由于<code>messageMoney</code>和<code>tagSize</code>均是<code>int</code>类型，因此<code>person1</code>减少的<code>money</code>可能不等于红包的<code>money</code>，这也是本次作业设计中比较奇怪的一点）。对于网络，仅增加了<code>messages</code>属性与整体网络内<code>message</code>的操作方法。同时为降低<code>MyNetwork</code>的复杂度和缩减长度，新增<code>MyNetworkBehavior</code>类，内含不发生异常时网络的各项操作。</p>
<h4 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h4><p>类复杂度表格如图所示：其中<code>OCavg</code>指代平均操作复杂度，<code>OCmax</code> 指代最大操作复杂度，<code>WMC</code> 指代加权方法复杂度</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Class</th>
<th>OCavg</th>
<th>OCmax</th>
<th>WMC</th>
</tr>
</thead>
<tbody>
<tr>
<td>DisjointSet</td>
<td><strong>2.57</strong></td>
<td><strong>5</strong></td>
<td>18</td>
</tr>
<tr>
<td>Main</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>MyEmojiMessage</td>
<td>1</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>MyMessage</td>
<td>1.11</td>
<td>2</td>
<td>10</td>
</tr>
<tr>
<td>MyNetwork</td>
<td><strong>2.42</strong></td>
<td><strong>8</strong></td>
<td><strong>87</strong></td>
</tr>
<tr>
<td>MyNetworkBehavior</td>
<td>1.93</td>
<td><strong>5</strong></td>
<td>27</td>
</tr>
<tr>
<td>MyNetworkFeature</td>
<td>2.33</td>
<td><strong>5</strong></td>
<td>21</td>
</tr>
<tr>
<td>MyNoticeMessage</td>
<td>1</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>MyPerson</td>
<td>1.62</td>
<td>4</td>
<td><strong>52</strong></td>
</tr>
<tr>
<td>MyRedEnvelopeMessage</td>
<td>1</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>MyTag</td>
<td>2.15</td>
<td>4</td>
<td>28</td>
</tr>
<tr>
<td>myexceptions.Counter</td>
<td>1.25</td>
<td>2</td>
<td>5</td>
</tr>
<tr>
<td>myexceptions.MyAcquaintanceNotFoundException</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>myexceptions.MyEmojiIdNotFoundException</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>myexceptions.MyEqualEmojiIdException</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>myexceptions.MyEqualMessageIdException</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>myexceptions.MyEqualPersonIdException</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>myexceptions.MyEqualRelationException</td>
<td>1.5</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>myexceptions.MyEqualTagIdException</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>myexceptions.MyMessageIdNotFoundException</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>myexceptions.MyPathNotFoundException</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>myexceptions.MyPersonIdNotFoundException</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>myexceptions.MyRelationNotFoundException</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>myexceptions.MyTagIdNotFoundException</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
</tbody>
</table>
</div>
<p>可以观察到，将<code>behavior</code>从网络中提取出来后，<code>MyNetwork</code>类复杂度有所降低，但仍因为存在多组多分支查询，因此复杂度仍较高。其余类复杂度正常。</p>
<h4 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h4><p>对于本次作业，笔者个人认为主要难度在测试环节。本次作业要求对<code>MyNetwork</code>中的<code>deleteColdEmoji()</code>函数进行测试，测试库使用<code>JUnit4</code>。主要测试了函数结果计算是否正确，及函数查询前后原属性是否改变。表情信息主要有三种存储形式，分别是在<code>emojiIds</code>中存储表情种类，每个<code>emojiId</code>代表一类表情；在<code>emojiHeats</code>中存储每个<code>emojiId</code>对应的表情使用热度；在<code>message</code>中存储信息，<code>message</code>中属性 <code>id</code>代表信息的序号，<code>emojiId</code>代表这条表情信息对应的表情类型。<code>deleteColdEmoji()</code>的主要实现逻辑是查询每种表情的热度，小于<code>limit</code>的表情进行删除（这种删除包括三种存储形式，即删除<code>emojiIds</code>和<code>emojiHeats</code>中<code>emojiId</code>对应的元素，删除<code>messages</code>中所有对应<code>emojiId</code>的<code>EmojiMessage</code>），并返回删除后<code>messages</code>的长度。</p>
<p>测试逻辑仍然是构建两个网络，一个始终不变，作为对照组；一个调用<code>deleteColdEmoji()</code>方法，作为变量组。比对调用方法前后的两个网络，观察函数的返回结果是否正确，以及各项应该改变或不该改变的属性是否发生变化。主要步骤可以分为两步：</p>
<ul>
<li><p>网络初始化：网络初始化需要为网络添加人物，添加群组，为人物添加关系，对网络添加信息，按照发送频率发送信息。为了保证测试的全面性，应保证在发送之后，所有<code>emojiId</code>均有一定热度，发送之后网络内存储的待发送信息<code>messages</code>应包含全部6类信息。（请注意，下列代码中省略了应对调用各网络函数后可能产生的异常的处理方法，请自行补充完善）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">netInitial</span><span class="params">(MyNetwork oldNet, MyNetwork newNet)</span></span><br><span class="line">   &#123;</span><br><span class="line">   	<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">long</span> <span class="variable">seed</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">       <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(seed);</span><br><span class="line">  </span><br><span class="line">       <span class="comment">/*<span class="doctag">TODO:</span>添加人*/</span></span><br><span class="line">       ...</span><br><span class="line">  </span><br><span class="line">       <span class="comment">/*<span class="doctag">TODO:</span>添加群组*/</span></span><br><span class="line">       ...</span><br><span class="line">  </span><br><span class="line">       <span class="comment">/*<span class="doctag">TODO:</span>添加emojiId*/</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; emojiIdSize; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           oldNet.storeEmojiId(i);</span><br><span class="line">           newNet.storeEmojiId(i);</span><br><span class="line">       &#125;</span><br><span class="line">  </span><br><span class="line">       <span class="comment">/*<span class="doctag">TODO:</span>添加emoji信息*/</span></span><br><span class="line">       <span class="keyword">for</span> (; index &lt; emojiSize; index++)</span><br><span class="line">       &#123;</span><br><span class="line">           Message message1;</span><br><span class="line">           Message message2;</span><br><span class="line">           <span class="type">int</span> <span class="variable">emojiId</span> <span class="operator">=</span> random.nextInt(emojiIdSize);</span><br><span class="line">           <span class="type">int</span> <span class="variable">id1</span> <span class="operator">=</span> random.nextInt(peopleSize);</span><br><span class="line">           <span class="type">int</span> <span class="variable">id2</span> <span class="operator">=</span> random.nextInt(peopleSize);</span><br><span class="line">           <span class="keyword">switch</span> (index % <span class="number">2</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                   message1 = <span class="keyword">new</span> <span class="title class_">MyEmojiMessage</span>(index, emojiId,</span><br><span class="line">                           oldNet.getPerson(id1), oldNet.getPerson(id2));</span><br><span class="line">                   message2 = <span class="keyword">new</span> <span class="title class_">MyEmojiMessage</span>(index, emojiId,</span><br><span class="line">                           newNet.getPerson(id1), newNet.getPerson(id2));</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">default</span>:</span><br><span class="line">                   message1 = <span class="keyword">new</span> <span class="title class_">MyEmojiMessage</span>(index, emojiId,</span><br><span class="line">                           oldNet.getPerson(id1), oldNet.getPerson(id1).getTag(id1));</span><br><span class="line">                   message2 = <span class="keyword">new</span> <span class="title class_">MyEmojiMessage</span>(index, emojiId,</span><br><span class="line">                           newNet.getPerson(id1), newNet.getPerson(id1).getTag(id1));</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           oldNet.addMessage(message1);</span><br><span class="line">           newNet.addMessage(message2);</span><br><span class="line">       &#125;</span><br><span class="line">  </span><br><span class="line">       <span class="comment">/*<span class="doctag">TODO:</span>添加notice信息*/</span></span><br><span class="line">       <span class="keyword">for</span> (; index &lt; noticeSize + emojiSize; index++)</span><br><span class="line">       &#123;</span><br><span class="line">           Message message1;</span><br><span class="line">           Message message2;</span><br><span class="line">           <span class="type">int</span> <span class="variable">id1</span> <span class="operator">=</span> random.nextInt(peopleSize);</span><br><span class="line">           <span class="type">int</span> <span class="variable">id2</span> <span class="operator">=</span> random.nextInt(peopleSize);</span><br><span class="line">           <span class="keyword">switch</span> (index % <span class="number">2</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                   message1 = <span class="keyword">new</span> <span class="title class_">MyNoticeMessage</span>(index, <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">                           oldNet.getPerson(id1), oldNet.getPerson(id2));</span><br><span class="line">                   message2 = <span class="keyword">new</span> <span class="title class_">MyNoticeMessage</span>(index, <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">                           newNet.getPerson(id1), newNet.getPerson(id2));</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">default</span>:</span><br><span class="line">                   message1 = <span class="keyword">new</span> <span class="title class_">MyNoticeMessage</span>(index, <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">                           oldNet.getPerson(id1), oldNet.getPerson(id1).getTag(id1));</span><br><span class="line">                   message2 = <span class="keyword">new</span> <span class="title class_">MyNoticeMessage</span>(index, <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">                           newNet.getPerson(id1), newNet.getPerson(id1).getTag(id1));</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           oldNet.addMessage(message1);</span><br><span class="line">           newNet.addMessage(message2);</span><br><span class="line">       &#125;</span><br><span class="line">  </span><br><span class="line">       <span class="comment">/*<span class="doctag">TODO:</span>添加redElevator信息*/</span></span><br><span class="line">       <span class="keyword">for</span> (; index &lt; redElevatorSize + noticeSize + emojiSize; index++)</span><br><span class="line">       &#123;</span><br><span class="line">           Message message1;</span><br><span class="line">           Message message2;</span><br><span class="line">           <span class="type">int</span> <span class="variable">wholeMoney</span> <span class="operator">=</span> random.nextInt(<span class="number">100</span>);</span><br><span class="line">           <span class="type">int</span> <span class="variable">id1</span> <span class="operator">=</span> random.nextInt(peopleSize);</span><br><span class="line">           <span class="type">int</span> <span class="variable">id2</span> <span class="operator">=</span> random.nextInt(peopleSize);</span><br><span class="line">           <span class="keyword">switch</span> (index % <span class="number">2</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                   message1 = <span class="keyword">new</span> <span class="title class_">MyRedEnvelopeMessage</span>(index, wholeMoney,</span><br><span class="line">                           oldNet.getPerson(id1), oldNet.getPerson(id2));</span><br><span class="line">                   message2 = <span class="keyword">new</span> <span class="title class_">MyRedEnvelopeMessage</span>(index, wholeMoney,</span><br><span class="line">                           newNet.getPerson(id1), newNet.getPerson(id2));</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">default</span>:</span><br><span class="line">                   message1 = <span class="keyword">new</span> <span class="title class_">MyRedEnvelopeMessage</span>(index, wholeMoney,</span><br><span class="line">                           oldNet.getPerson(id1), oldNet.getPerson(id1).getTag(id1));</span><br><span class="line">                   message2 = <span class="keyword">new</span> <span class="title class_">MyRedEnvelopeMessage</span>(index, wholeMoney,</span><br><span class="line">                           newNet.getPerson(id1), newNet.getPerson(id1).getTag(id1));</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           oldNet.addMessage(message1);</span><br><span class="line">           newNet.addMessage(message2);</span><br><span class="line">       &#125;</span><br><span class="line">  </span><br><span class="line">       <span class="comment">/*<span class="doctag">TODO:</span>将信息进行发送*/</span></span><br><span class="line">       <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; emojiSize + noticeSize + redElevatorSize; index++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (index % sendFrequency == <span class="number">0</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               oldNet.sendMessage(index);</span><br><span class="line">               newNet.sendMessage(index);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>变量组对照组比对：属性比对主要针对<code>emojiIds</code>、<code>emojiHeats</code>、<code>messages</code>三个数组中的元素。对于<code>emojiIds</code>，应确保原数组中对应热度大于等于<code>limit</code>的序号新数组均含有，原数组中对应热度小于<code>limit</code>的序号新数组均不含有，新数组中不含有相同元素；对于<code>emojiHeats</code>，应确保原数组中对应热度大于等于<code>limit</code>的热度新数组均含有，原数组中对应热度小于<code>limit</code>的热度新数组均不含有，新数组中不含有相同元素；对于<code>messages</code>，应确保原数组的<code>NoticeMessage</code>、<code>RedEnvelopeMessage</code>不发生变化，原数组中的<code>EmojiMessage</code>应确保对应热度大于等于<code>limit</code>的热度新数组均含有，对应热度小于<code>limit</code>的热度新数组均不含有，新数组中不含有相同元素。</p>
</li>
</ul>
<hr>
<h2 id="二、架构重点实现分析"><a href="#二、架构重点实现分析" class="headerlink" title="二、架构重点实现分析"></a>二、架构重点实现分析</h2><h3 id="Homework1-1"><a href="#Homework1-1" class="headerlink" title="Homework1"></a>Homework1</h3><p>第一次作业程序中主要有三个实现的重点：</p>
<ul>
<li><p><strong>并查集<code>DisjointSet</code>构建与使用：</strong>在本次作业中，<code>queryBlockSum()</code>与<code>isCircle()</code>方法作为核心方法，对性能要求较高，因此引入并查集<code>DisjointSet</code>类提高性能。并查集的核心在于时刻保证位于同一个块（即互相相连的节点）的根节点相同。</p>
<ul>
<li><code>find()</code>方法：查询节点的根节点；</li>
<li><code>merge()</code>方法：合并两个块，将一个根节点的的父节点设置为另一个根节点；</li>
<li><code>modify()</code>方法：调整一个块各点的根节点，在删除边时使用。对节点1进行深度遍历，记录全部可以到达的节点，并将所有可到达的节点的根节点变动为节点1。若节点2可以到达，则不需要继续进行任何操作；若节点2不可以到达，则对节点2进行深度遍历，并将所有可到达的节点的根节点变动为节点2。</li>
</ul>
</li>
<li><p><strong>计数器<code>Counter</code>构建与使用：</strong>在本次作业中，需要对各项异常发生次数进行统计，因此加入计数器<code>Counter</code>类。每个异常中设置一个静态属性计数器<code>counter</code>记录该类异常的发生次数。</p>
</li>
<li><strong>三角形数量<code>triNum</code>的动态维护：</strong>在本次作业中，<code>queryTripleSum()</code>方法同作为核心方法，对性能要求也较高，因此对<code>Network</code>设立属性<code>triNum</code>记录三角形的数量。在加入联系时，查询联系两个端节点共同相连的节点数量，即是增加的三角形数量。删除练习时相同，减少两个端节点共同相连的节点数量即可。</li>
</ul>
<h3 id="Homework2-1"><a href="#Homework2-1" class="headerlink" title="Homework2"></a>Homework2</h3><p>第二次作业程序中主要有三个实现重点：</p>
<ul>
<li><strong>群组<code>value</code>维护：</strong>在本次作业中，<code>queryValueSum()</code>方法作为核心方法，对性能要求较高，因此对<code>Tag</code>设立属性<code>valueSum</code>记录特定群组的数值总和。维护情况主要分为对群组中增删人员和增删关系时对群组产生影响。当增删人员时，遍历群组内属性<code>persons</code>，增加或删减群组人员与待增删人员之间的关系价值。当增删人员间关系时，遍历网络中全部人员的全部群组，对含有增删关系的两位成员的群组改变群组的<code>valueSum</code>。</li>
<li><strong>人员最佳关系维护：</strong>在本次作业中，<code>queryBestAcquaintance()</code>方法作为核心方法，对性能要求较高，因此对<code>Person</code>设立属性<code>bestId</code>记录与人员关系数值<code>value</code>最高的成员编号。维护情况主要是在增加和调整整合关系时对人员产生影响。当增加关系时，将增加的关系的<code>id</code>、<code>value</code>与当前最佳关系的<code>id</code>、<code>value</code>进行比较，判断是否需要变化最佳关系。当调整关系数值时，分为两种情况：如果变化的关系是当前最佳关系且数值增加，或变化的关系不是当前最佳关系且数值减少，则不需要调整；如果变化的关系不是当前最佳关系且数值增加，或变化的关系是当前最佳关系且数值减少，则需要遍历所有现在的关系并找到最佳关系。当删除关系时，也分为两种情况：如果删除的不是最佳关系，则不需要调整；如果删除的是最佳关系，则需要遍历所有现在的关系并找到最佳关系。</li>
<li><strong>寻找最短路径：</strong>在本次作业中，<code>queryShortest()</code>方法作为核心方法，对性能要求较高，但由于路径增删相关操作影响过多，不便动态维护，因此需要采用高效的寻路算法。笔者使用的是普通的广度优先遍历，首次遍历经过<code>person2</code>后，清空队列，并返回相应长度。测试证明普通的广度优先算法完全够用。</li>
</ul>
<h3 id="Homework3-1"><a href="#Homework3-1" class="headerlink" title="Homework3"></a>Homework3</h3><p>第三次作业程序中主要有两个实现重点：</p>
<ul>
<li><p><strong>同一类不同构造函数：</strong>本次作业中，对于三种信息<code>EmojiMessage</code>、<code>NoticeMessage</code>、<code>RedEnvelopeMessage</code>，每种信息均有两种类型对单对群，因此这三个类每个类应该有两种构造方法。而在一个类中使用多种构造方法过程较为简单，直接书写即可，最终产生新对象时会根据传入数据类型自动识别使用哪种构造方法。</p>
</li>
<li><p><strong>迭代器的使用：</strong>本次作业中涉及多个需要对集合进行遍历删除的操作，而在这个过程中，集合不应该发生改变，否则会抛出<code>ConcurrentModificationException</code>的异常。因此应该构造迭代器，使用迭代器对集合进行遍历删除操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Object&gt; iterator = objects.iterator();</span><br><span class="line">      <span class="keyword">while</span> (iterator.hasNext())</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">          <span class="keyword">if</span> (condition)</span><br><span class="line">          &#123;</span><br><span class="line">              iterator.remove();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="三、Bug分析及程序优化"><a href="#三、Bug分析及程序优化" class="headerlink" title="三、Bug分析及程序优化"></a>三、Bug分析及程序优化</h2><h3 id="Homework1-2"><a href="#Homework1-2" class="headerlink" title="Homework1"></a>Homework1</h3><h4 id="Bug分析"><a href="#Bug分析" class="headerlink" title="Bug分析"></a>Bug分析</h4><p>第一次作业出现的问题主要是性能问题。在最初的设计中，并未使用并查集，因此程序性能极差。在增添<code>DisjointSet</code>类并将<code>MyNetwork</code>类中相关方法优化后，就可以大幅提高程序性能。</p>
<h4 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h4><p>设计最初时，缺省了一定的程序鲁棒性以及对于性能的追求。现对作业过程中所做优化进行记录：</p>
<ul>
<li><strong>并查集优化函数：</strong>程序中最吃性能的部分是<code>isCircle()</code>、<code>queryBlockSum()</code>两个方法。对于<code>isCircle()</code>方法，直接调用并查集<code>find()</code>查询两个节点的根节点，如果相同，证明来自同一个块，两节点相连。对于<code>queryBlockSum()</code>方法，在<code>DisjointSet</code>类中维护块组属性，在调用<code>queryBlockSum()</code>方法时直接返回块组大小即可。</li>
</ul>
<h3 id="Homework2-2"><a href="#Homework2-2" class="headerlink" title="Homework2"></a>Homework2</h3><h4 id="Bug分析-1"><a href="#Bug分析-1" class="headerlink" title="Bug分析"></a>Bug分析</h4><p>第二次作业暂无bug</p>
<h4 id="优化策略-1"><a href="#优化策略-1" class="headerlink" title="优化策略"></a>优化策略</h4><p>在完成作业并通过强测后听到想到了一些有趣的优化方式，现记录如下：</p>
<ul>
<li><strong>使用小顶堆维护最佳关系：</strong>本次作业的人员最佳关系维护时，可以使用小顶堆的数据结构存储各关系数值。当需要获得最佳关系时，只需返回根节点即可。但增删关系时都需要重新调整构建小顶堆，这部分较占时间。</li>
<li><strong>使用双向广度优先遍历寻找最短路径：</strong>已知路径的起点和终点，可以分别从起点和终点双向执行广度优先遍历，直到遍历的部分有交集。这种方法一定程度上可以减少从一边开始搜索的时候，随着层数的增加，搜索空间变大的情况。但由于程序中节点较少，构成的子图估摸较小，因此双向广度优先遍历在性能上并没有体现出较大水平的提高。</li>
</ul>
<h3 id="Homework3-2"><a href="#Homework3-2" class="headerlink" title="Homework3"></a>Homework3</h3><h4 id="Bug分析-2"><a href="#Bug分析-2" class="headerlink" title="Bug分析"></a>Bug分析</h4><p>第三次作业出现了在调用<code>sendMessage()</code>函数抛出<code>MyTagIdNotFoundException</code>时使用了<code>messageId</code>的bug，本单元作业<code>id</code>种类较多，在调用函数过程需要多加注意。</p>
<h4 id="优化策略-2"><a href="#优化策略-2" class="headerlink" title="优化策略"></a>优化策略</h4><p>第三次作业暂无优化策略</p>
<hr>
<h2 id="四、心得体会"><a href="#四、心得体会" class="headerlink" title="四、心得体会"></a>四、心得体会</h2><p>本单元不需要发泄。（<del>嘴脸!</del>）</p>
<p>那么心得体会部分就主要谈谈这单元完成之后的一些收获和经验吧：</p>
<ul>
<li><strong>架构设计的重要性。</strong>好的，重要的事情说三遍。相较于前两个单元，本单元难度大幅降低，主要原因是去除了架构设计部分。同学们的身份从设计师转变为程序员，只需要按照给定的规格补全代码即可。但我不设计不妨碍我不学习。本单元的整体架构设计较为科学，从中也能看到高内聚低耦合的思想。美中不足的是<code>Network</code>中设计的方法过多，大大增加了该类的长度。</li>
<li><strong>规格的重要性。</strong> 本单元作业中槽点最多的就是<code>JML</code>规格。诚然，这种规格双刃性极大，从好的方面讲，它可以更加精确地让程序员实现功能，详细描述了方法各项限制与前置后置条件；从坏的方面说，它的可读性较差，不能直观的反映要实现的功能。因此，真实设计时可能还是要使用<code>JML</code>+自然语言的形式。</li>
<li><strong>测试的重要性。</strong> 应该说，本单元最重要的一点就是测试，对于工业软件测试的基本概念方法有了一定了解。<ul>
<li>数据构造：本单元三次作业<code>JUnit</code>的测试重点是参数化的随机数据构造。在构建测试前，应该详细考虑可能出现的全部问题，并保证设计出的数据可以涵盖这些方面。</li>
<li>黑箱测试白箱测试：黑箱即不知道真实代码的情况下直接构造数据进行测试，白箱即在知道真实代码的情况下针对代码进行攻击。两种在真实测试中均会使用到，一个是数据导向型的，一个是逻辑导向型的。</li>
<li>单元测试集成测试：单元测试即对每一个方法进行单独测试，集成测试即对程序整体进行各项功能测试。本单元使用<code>JUnit</code>进行的测试即是单元测试，而正常状况下对于程序整体运行测试即是集成测试。</li>
<li>功能测试压力测试回归测试：功能测试即是对程序的各项功能进行全面测试，压力测试即是使用各种临界数据测试程序的鲁棒性，回归测试即是修改代码后要再次进行全面测试。</li>
</ul>
</li>
</ul>
<p>至于对课程的建议，说实话挺想吐槽一下作业描述的朝令夕改的。但是仔细想一想，想要使用<code>JML</code>规格语言这种令人血压飙升的玩意正确全面地描述函数的功能与各项限制确实是一项极其困难的事，读的人都觉得困难，写的人就更觉得困难了，瞬间就能理解学长学姐们的难处了。架构设计方面，还是想说一句，<code>Network</code>里面的方法太多了，很容易就超过<code>checkstyle</code>的行数限制了。</p>
<p>最后，还是要感谢助教lmh学姐的帮助。也希望在之后的学习中能再接再厉，继续进步。</p>
]]></content>
      <categories>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Lab0实验报告</title>
    <url>/2025/03/15/OS/Lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="Lab0实验报告"><a href="#Lab0实验报告" class="headerlink" title="Lab0实验报告"></a>Lab0实验报告</h1><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-0-1"><a href="#Thinking-0-1" class="headerlink" title="Thinking 0.1"></a>Thinking 0.1</h3><ul>
<li><img src="/images/OS/Lab0实验报告/thinking 1-1.png" alt="thinking 1-1"></li>
<li><img src="/images/OS/Lab0实验报告/thinking 1-2.png" alt="thinking 1-2"></li>
<li><code>git commit -m &quot;22373347&quot;</code></li>
<li><img src="/images/OS/Lab0实验报告/thinking 1-3.png" alt="thinking 1-3"></li>
<li><img src="/images/OS/Lab0实验报告/thinking 1-4.png" alt="thinking 1-4"></li>
<li>不一样，第一次执行命令之前README.txt文件是新增文件，执行之后暂存区以含有该文件，所以再次执行会显示为修改后文件。</li>
</ul>
<h3 id="Thinking-0-2"><a href="#Thinking-0-2" class="headerlink" title="Thinking 0.2"></a>Thinking 0.2</h3><ul>
<li><code>add the file</code>对应<code>git add</code></li>
<li><code>stage the file</code>对应<code>git add</code></li>
<li><code>commit</code>对应<code>git commit</code></li>
</ul>
<h3 id="Thinking-0-3"><a href="#Thinking-0-3" class="headerlink" title="Thinking 0.3"></a>Thinking 0.3</h3><ul>
<li><code>git checkout -- print.c</code></li>
<li><code>git reset HEAD print.c</code> + <code>git checkout -- print.c</code></li>
<li><code>git rm --cached hello.txt</code></li>
</ul>
<h3 id="Thinking-0-4"><a href="#Thinking-0-4" class="headerlink" title="Thinking 0.4"></a>Thinking 0.4</h3><p><code>git reset --hard HEAD^</code>和<code>git reset --hard &lt;hash&gt;</code>两条命令都可以进行回溯，其中<code>HEAD^</code>会回溯到上一条提交记录，<code>&lt;hash&gt;</code>会回溯到哈希值所指的提交记录；使用哈希值可以回溯到老版本，也可以在回溯到老版本之后重新回溯到新版本。</p>
<h3 id="Thinking-0-5"><a href="#Thinking-0-5" class="headerlink" title="Thinking 0.5"></a>Thinking 0.5</h3><p><img src="C:\Users\SUN\AppData\Roaming\Typora\typora-user-images\image-20240313163539979.png" alt="image-20240313163539979"></p>
<h3 id="Thinking-0-6"><a href="#Thinking-0-6" class="headerlink" title="Thinking 0.6"></a>Thinking 0.6</h3><ul>
<li><strong>command.sh：</strong></li>
</ul>
<p><img src="/images/OS/Lab0实验报告/thinking 6-1.png" alt="thinking 6-1"></p>
<ul>
<li><strong>result：</strong></li>
</ul>
<p><img src="/images/OS/Lab0实验报告/thinking 6-2.png" alt="thinking 6-2"></p>
<ul>
<li><strong>思考：</strong><code>echo echo Shell Start</code>与<code>echo &#39;echo Shell Start&#39;</code>没有区别，<code>echo echo $c&gt;file1</code>与<code>echo &#39;echo $c&gt;file1&#39;</code>有区别。<code>&#39;&#39;</code>会使其中内容变为字符串，因此前者没有区别，而后者<code>$c</code>有特殊含义，如果不加<code>&#39;&#39;</code>直接执行就会报错。</li>
</ul>
<h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><p>本次实验中，我所遇到的难点主要是三点：<code>git</code>指令的应用，<code>sed</code>、<code>awk</code>指令的多种处理文件的用法，嵌套层的<code>Makefile</code>文件编写。</p>
<ul>
<li><p><strong>git：</strong>版本管理 （git [选项] ’命令‘ 文件）</p>
<ul>
<li>git fetch：抓取库</li>
<li>git checkout branch：查找跳转分支</li>
<li>git add file：添加文件</li>
<li>git commit -m “info”：提交文件</li>
<li>git push：推送文件</li>
<li>git checkout — file：恢复修改还未提交至暂存区的文件</li>
<li>git reset —hard HEAD^/<hash>：回溯提交记录</li>
<li>git log：查看提交记录</li>
</ul>
</li>
<li><p><strong>awk：</strong>处理文本（awk [选项] ‘命令’ 文件）</p>
<ul>
<li>awk ‘pattern action’ file：按照条件pattern进行动作action（其中$n代表分割后的第n项，默认以空格切分）</li>
<li>awk -F’char’ ‘action’ file：按照字符分割文件中每一行字符串，并进行操作（其中$n代表分割后的第n项）</li>
</ul>
</li>
<li><p><strong>sed：</strong>处理文本，数据替换、删除、新增、选取等功能（sed [选项] ‘命令’ 文件）</p>
<ul>
<li>-n：安静模式，仅显示更改的内容</li>
<li>-i：直接修改文件内容，否则只修改不保存并输出到屏幕</li>
<li>[行号]a[内容]：在对应行后新增内容，不加行号时在每一行后都新加内容（最后一行用$表示）</li>
<li>[行号]c[内容]：用当前内容取代对应行内容</li>
<li>[行号]i[内容]：在对应行之前插入内容</li>
<li>[行号]d：删除对应行</li>
<li>[行号]p：输出对应行，多与-n合用</li>
<li>s/re/string/g：按照正则表达式将所有re替换为string（单引号将所有字符认为为字符，双引号可引入外部输入变量）</li>
</ul>
</li>
</ul>
<h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>Lab0主要让我们学习如何使用Linux控制终端来进行基础命令行操作和文件操作，作为这方面的萌新，确实耗费了我不少时间，主要还是对于各种命令的不熟悉和对于脚本初接触。因为指导书所提供的学习内容比较局限，在一些常用的命令介绍上也需要自行查阅（例如awk，sed等），这些命令加上各种选项后种类繁多，令人眼花缭乱。</p>
<p>终端操作和之前进行的在可视化界面上的操作不同，看起来更加繁琐，更加抽象，更加多而杂，但也更加”帅气“。总的来说，命令行的学习让我遇到了不小的困难，但一番学习下来之后也让我感到很充实。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Mips</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象课程Unit4总结</title>
    <url>/2025/03/17/OO/2024%E6%98%A5-OO%E8%AF%BE%E7%A8%8BUnit4%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="2024春-OO课程Unit4总结"><a href="#2024春-OO课程Unit4总结" class="headerlink" title="2024春-OO课程Unit4总结"></a>2024春-OO课程Unit4总结</h1><hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>第四单元作业的主题是图书管理系统的构建，主要学习内容涉及到程序架构设计以及<code>UML</code>图的阅读与绘制。第一次作业主要实现基本的图书管理系统，服务单元主要是书架、借阅处、预约处，仅含有正式书籍，顾客可以获得<code>borrow</code>、<code>return</code>、<code>query</code>、<code>order</code>和<code>pick</code>等服务，同时绘制程序的<code>UML</code>类图；第二次作业增加了图书漂流角服务单元（<code>CornerOffice</code>漂流角类），含有正式与非正式书籍（非正式书籍可以转正），顾客可以获得<code>donate</code>、<code>renew</code>等服务，同时绘制程序的<code>UML</code>类图以及书籍借阅流程的<code>UML</code>状态图；第三次作业增加了信誉积分，顾客可以查询自身信誉积分，借书还书的过程中各种情况会导致客户信誉积分变化，同时绘制程序的<code>UML</code>类图以及书籍预约获取流程的<code>UML</code>顺序图。第四单元并未明确规定代码的架构以及书籍的移动策略，自由度较高，主要练习了程序代码架构高内聚低耦合以及逻辑合理清晰的设计。各种<code>UML</code>图的绘制较为繁琐，反而是本单元中耗时最长的部分。本篇总结主要是记录一下三次作业的具体实现、各种优缺点分析，以及自身一点心得体会。</p>
<hr>
<h2 id="一、作业架构分析"><a href="#一、作业架构分析" class="headerlink" title="一、作业架构分析"></a>一、作业架构分析</h2><h3 id="Homework1"><a href="#Homework1" class="headerlink" title="Homework1"></a>Homework1</h3><h4 id="题目重点重述"><a href="#题目重点重述" class="headerlink" title="题目重点重述"></a>题目重点重述</h4><p>第一次作业主要是实现简单的图书管理系统，包含<code>borrow</code>、<code>return</code>、<code>query</code>、<code>order</code>和<code>pick</code>等顾客操作，以及图书馆在开馆闭馆时自行进行的调整操作。图书馆分区可分为三区，书架区、借阅处、预约处。当顾客进行借阅操作时，携带书籍前往借阅处，借阅处审批顾客是否可以借阅，若可以，则借与顾客，如不可以，则存入借阅处。归还书籍时同理，归还的书籍存入借阅处。当顾客进行查询操作时，书架区需要返回特定书籍编号的库存数量。当顾客进行预约操作时，预约处审批顾客是否可以预约，并在停止营业后进行书籍调整。当顾客进行取预约书籍操作时，预约处需要查询是否有预约信息，若存在，则进行借出。开馆闭馆停止营业时可以进行书籍在图书馆内调整操作，在三个分区转运书籍。书籍分为ABC三类，其中，A类书籍不可以借阅或预约（不可以移动），B类书籍同时只能拥有一本，C类书籍同一书号同时只能拥有一本。</p>
<h4 id="程序UML图"><a href="#程序UML图" class="headerlink" title="程序UML图"></a>程序UML图</h4><p><img src="/images/OO/oo第4单元总结/hw4-1UML图.png" alt="hw4-1UML图"></p>
<p>本次作业中使用<code>RequestDealer</code>类读入并处理需求<code>LibraryRequest</code>，主要功能实现类是<code>Library</code>类，主要交互是在<code>Library</code>和<code>Customer</code>类之间进行。在<code>Library</code>中存入客户名单，以及<code>Shelf</code>、<code>BorrowOffice</code>、<code>AppointOffice</code>三个服务分区，在<code>Library</code>类中进行上层的统一操作。同时设计了<code>BookBuffer</code>类统一存储当前对象的书籍，并配有查询特定书籍数量、是否拥有特定书籍和增删书籍的基本操作。对于预约处的处理，使用预约信息<code>AppointInf</code>作为最小操作单元，每条预约信息均有<code>bookId</code>、<code>customer</code>、<code>date</code>等属性，以判断预约信息的有效性。</p>
<h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><p>类复杂度表格如图所示：其中<code>OCavg</code>指代平均操作复杂度，<code>OCmax</code> 指代最大操作复杂度，<code>WMC</code> 指代加权方法复杂度</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Class</th>
<th>OCavg</th>
<th>OCmax</th>
<th>WMC</th>
</tr>
</thead>
<tbody>
<tr>
<td>AppointInf</td>
<td>1</td>
<td>1</td>
<td>5</td>
</tr>
<tr>
<td>AppointOffice</td>
<td>2</td>
<td>4</td>
<td>14</td>
</tr>
<tr>
<td>BookBuffer</td>
<td>1.88</td>
<td>3</td>
<td><strong>15</strong></td>
</tr>
<tr>
<td>BorrowOffice</td>
<td>1</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>Customer</td>
<td>1.6</td>
<td>4</td>
<td>8</td>
</tr>
<tr>
<td>Library</td>
<td><strong>2.1</strong></td>
<td><strong>5</strong></td>
<td><strong>21</strong></td>
</tr>
<tr>
<td>Main</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>RequestDealer</td>
<td><strong>2.8</strong></td>
<td><strong>6</strong></td>
<td>14</td>
</tr>
<tr>
<td>Shelf</td>
<td>1</td>
<td>1</td>
<td>6</td>
</tr>
</tbody>
</table>
</div>
<p>可以观察到，本次作业设计架构还是较为合理的，整体复杂度水平较低。复杂度最高的是<code>RequestDeal</code>和<code>Library</code>类。这两个类中含有多种方法，且存在多项的分支选择，因此复杂度较高。同时，由于各项客户操作以及书籍转运主要在<code>Library</code>中实现，因此会出现<code>Library</code>复杂度远超其他类的现象。<code>Customer</code>、<code>Shelf</code>、<code>BorrowOffice</code>中方法均是对<code>bookBuffer</code>操作，主体部分在<code>BookBuffer</code>类中实现，因此复杂度较低。</p>
<h4 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h4><p>在重新思考后，发现不将书籍副本实例化为具体对象，将会遗失很多信息（将书本实例化后会更好存储），同时会造成三种<code>Office</code>较难抽象，因此选择进行重构。</p>
<p><img src="/images/OO/oo第4单元总结/hw4-1UML图改.png" alt="hw4-1UML图改"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Class</th>
<th>OCavg</th>
<th>OCmax</th>
<th>WMC</th>
</tr>
</thead>
<tbody>
<tr>
<td>AppointInf</td>
<td>1</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>AppointOffice</td>
<td>1</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>Book</td>
<td>1</td>
<td>1</td>
<td>6</td>
</tr>
<tr>
<td>BookBuffer</td>
<td><strong>2.64</strong></td>
<td><strong>6</strong></td>
<td><strong>29</strong></td>
</tr>
<tr>
<td>BorrowOffice</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>Customer</td>
<td>1.5</td>
<td>4</td>
<td>9</td>
</tr>
<tr>
<td>Library</td>
<td>1.9</td>
<td>4</td>
<td><strong>19</strong></td>
</tr>
<tr>
<td>Main</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>Office</td>
<td>1</td>
<td>1</td>
<td>6</td>
</tr>
<tr>
<td>RequestDealer</td>
<td><strong>2.8</strong></td>
<td><strong>6</strong></td>
<td>14</td>
</tr>
<tr>
<td>ShelfOffice</td>
<td>1</td>
<td>1</td>
<td>4</td>
</tr>
</tbody>
</table>
</div>
<p>可以观察到，类复杂度略有上升。但是由于<code>Book</code>类中可以存储是否预约以及预约信息，因此可以将图书馆中<code>appointOffice</code>、<code>borrowOffice</code>、<code>shelfOffice</code>抽象出一个<code>Office</code>的父类，使得代码复用性更高，操作也更加顺遂。</p>
<h3 id="Homework2"><a href="#Homework2" class="headerlink" title="Homework2"></a>Homework2</h3><h4 id="题目重点重述-1"><a href="#题目重点重述-1" class="headerlink" title="题目重点重述"></a>题目重点重述</h4><p>本次作业在第一次作业基础上，新增了客户捐献、图书漂流角、正式书籍续借等功能。首先定义了正式书籍与非正式书籍，正式书籍可从初始化配置（存储于书架中）以及非正式书籍升级获得（非正式书籍被借阅两次，需要升级为正式书籍），仅存在于书架、预约处、借阅处、客户；非正式书籍可从捐献获得（存储于图书漂流角中），仅存在于图书漂流角、借阅处、客户。书籍的转移路径为书架到借阅处（正式书籍借阅失败）、书架到客户（正式书籍借阅成功）、书架到预约处（正式书籍预约整理）、借阅处到书架（正式书籍返还及非正式书籍升级）、借阅处到图书漂流角（非正式书籍返还）、预约处到书架（预约书籍超时未取返还）、预约处到客户（预约书籍取走）、图书漂流角到借阅处（非正式书籍借阅失败）、图书漂流角到客户（非正式书籍借阅成功）、客户到借阅处（客户归还借阅书籍）。在客户借阅到期的前五天内，通过图书馆预约信息判定后，客户可以续借30天。</p>
<h4 id="程序UML图-1"><a href="#程序UML图-1" class="headerlink" title="程序UML图"></a>程序UML图</h4><p><img src="/images/OO/oo第4单元总结/hw4-2UML图.png" alt="hw4-2UML图"></p>
<p>相比于第一次作业，本次作业整体架构并无较大变化。可以观察到，经过重构抽象后，非正式书籍相关操作实现较为简单。如图书漂流角可直接继承<code>Office</code>类，其全部功能均在父类中已经实现，因此可以直接使用。本次作业中，最大改变是将图书馆系统的操作全部提取出来建立<code>Service</code>接口，实例化各种服务类。在<code>System</code>类中建立<code>Service[]</code>数组储存各种服务，在系统使用各项功能时调用服务类即可。</p>
<p><img src="/images/OO/oo第4单元总结/hw4-2UML状态图.png" alt="hw4-2UML状态图"></p>
<p>本次作业还要求制作书籍的<code>UML</code>状态图。本次画制较为简单，仅做出了初始状态<code>InitState</code>、在图书馆中状态<code>inLibrary</code>、在客户手中状态<code>inCustomer</code>。三种状态的转换方式如图所示，不再过多赘述。</p>
<h4 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h4><p>类复杂度表格如图所示：其中<code>OCavg</code>指代平均操作复杂度，<code>OCmax</code> 指代最大操作复杂度，<code>WMC</code> 指代加权方法复杂度</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Class</th>
<th>OCavg</th>
<th>OCmax</th>
<th>WMC</th>
</tr>
</thead>
<tbody>
<tr>
<td>Main</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>books.Book</td>
<td>1.73</td>
<td><strong>9</strong></td>
<td>19</td>
</tr>
<tr>
<td>books.BookBuffer</td>
<td><strong>2.73</strong></td>
<td>4</td>
<td><strong>41</strong></td>
</tr>
<tr>
<td>informations.Inf</td>
<td>1</td>
<td>1</td>
<td>8</td>
</tr>
<tr>
<td>libraries.Library</td>
<td>1.87</td>
<td>3</td>
<td><strong>28</strong></td>
</tr>
<tr>
<td>libraries.System</td>
<td><strong>3.17</strong></td>
<td><strong>9</strong></td>
<td>19</td>
</tr>
<tr>
<td>offices.AppointOffice</td>
<td>1.4</td>
<td>3</td>
<td>7</td>
</tr>
<tr>
<td>offices.BorrowOffice</td>
<td>1</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>offices.CornerOffice</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>offices.Office</td>
<td>1</td>
<td>1</td>
<td>9</td>
</tr>
<tr>
<td>offices.ShelfOffice</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>services.BorrowService</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>services.ContinueService</td>
<td>1.5</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>services.DonateService</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>services.OrderService</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>services.PickService</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>services.QueryService</td>
<td>1.5</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>services.ReturnService</td>
<td>1.5</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>users.Customer</td>
<td>1.67</td>
<td>5</td>
<td>10</td>
</tr>
</tbody>
</table>
</div>
<p>可以观察到，在增加功能后，本次作业复杂度有较高提升，其中<code>System</code>、<code>BookBuffer</code>类复杂度最高。对于<code>System</code>类，其中的<code>run()</code>方法进行<code>command</code>轮询，<code>requestDeal()</code>方法有较多选项的<code>switch</code>语句，选择不同的服务进行调用，因此整体复杂度较高。其余类复杂度正常，得益于程序的模块化分离。</p>
<h3 id="Homework3"><a href="#Homework3" class="headerlink" title="Homework3"></a>Homework3</h3><h4 id="题目重点重述-2"><a href="#题目重点重述-2" class="headerlink" title="题目重点重述"></a>题目重点重述</h4><p>本次作业在第二次作业的基础上，新增了用户的信誉积分功能。用户初始分数为10分，最高为20分，最低无限制。当用户出现按时归还借阅书籍、捐赠书籍、捐赠书籍转正时获得相应加分；出现逾期还书、预约书籍逾期未取等情况时减去相应减分。当用户的信誉积分小于0时，将限制其借阅、预约、续借等服务。同时新增用户信誉积分查询功能，查询单个客户的信誉积分。</p>
<h4 id="程序UML图-2"><a href="#程序UML图-2" class="headerlink" title="程序UML图"></a>程序UML图</h4><p><img src="/images/OO/oo第4单元总结/hw4-3UML图.png" alt="hw4-3UML图"></p>
<p>UML类图与上一次作业变化不大，主要新增了<code>CreditService</code>服务类。在<code>Book</code>类中新增<code>state</code>属性，表示书籍当前状态，主要是<code>NONE</code>（代表处于图书馆内，没有被预约借阅）、<code>APPOINTED</code>（代表处于预约处，被某位客户预约）、<code>BORROWED</code>（代表被某位客户借阅，处于客户手中），通过新增方法<code>changeState()</code>变换状态。这种改变既可以去除<code>isAppointed</code>、<code>isBorrowed</code>两个属性，整体更加抽象简洁，也可以在未来增加更多书籍状态时更好的拓展。</p>
<p><img src="/images/OO/oo第4单元总结/hw4-3UML顺序图.png" alt="hw4-3UML顺序图"></p>
<p>本次作业还要求制作书籍的<code>UML</code>顺序图，主要模拟客户预定并获取书籍收发消息的流程。本次画图较为简略，仅制出了两个<code>lifeline</code>作为收发消息的对象，分别是<code>:System</code>和<code>:Customer</code>（<code>:</code>后代表类）。当客户发出预约请求时，系统向客户发送消息<code>orderNewBook()</code>表示已接收到请求，并进行各项操作，将书籍变为可获取的状态；客户获取到书籍后，向系统发送消息<code>getOrderedBook()</code>表示已获得书籍。整体流程较为简单，是一个反馈机制。</p>
<h4 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h4><p>类复杂度表格如图所示：其中<code>OCavg</code>指代平均操作复杂度，<code>OCmax</code> 指代最大操作复杂度，<code>WMC</code> 指代加权方法复杂度</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Class</th>
<th>OCavg</th>
<th>OCmax</th>
<th>WMC</th>
</tr>
</thead>
<tbody>
<tr>
<td>Main</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>books.Book</td>
<td>1.82</td>
<td><strong>10</strong></td>
<td>20</td>
</tr>
<tr>
<td>books.BookBuffer</td>
<td><strong>2.73</strong></td>
<td>4</td>
<td><strong>41</strong></td>
</tr>
<tr>
<td>informations.Inf</td>
<td>1</td>
<td>1</td>
<td>8</td>
</tr>
<tr>
<td>libraries.Library</td>
<td>1.87</td>
<td>3</td>
<td><strong>28</strong></td>
</tr>
<tr>
<td>libraries.System</td>
<td><strong>2.88</strong></td>
<td><strong>9</strong></td>
<td>23</td>
</tr>
<tr>
<td>offices.AppointOffice</td>
<td>2.33</td>
<td>7</td>
<td>14</td>
</tr>
<tr>
<td>offices.BorrowOffice</td>
<td>1</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>offices.CornerOffice</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>offices.Office</td>
<td>1</td>
<td>1</td>
<td>9</td>
</tr>
<tr>
<td>offices.ShelfOffice</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>services.BorrowService</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>services.ContinueService</td>
<td>1.5</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>services.CreditService</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>services.DonateService</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>services.OrderService</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>services.PickService</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>services.QueryService</td>
<td>1.5</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>services.ReturnService</td>
<td>1.5</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>users.Customer</td>
<td>2</td>
<td>5</td>
<td>20</td>
</tr>
</tbody>
</table>
</div>
<p>可以观察到，相比于第二次作业，本次作业复杂度无显著变化。本次作业改动较少，并未产生过多新方法，同时新增部分中基本没有多项判断和循环，因此并未对复杂度造成太大影响。</p>
<hr>
<h2 id="二、架构重点实现分析"><a href="#二、架构重点实现分析" class="headerlink" title="二、架构重点实现分析"></a>二、架构重点实现分析</h2><h3 id="Homework1-1"><a href="#Homework1-1" class="headerlink" title="Homework1"></a>Homework1</h3><p>第一次作业程序中主要有三个实现的重点：</p>
<ul>
<li><p><strong>借阅流程的实现：</strong>当顾客进行借阅操作时，首先应该判断书籍是否可以移动，若可以移动则客户携带书籍前往借阅处，并进行进一步审批。借阅处审批顾客是否可以借阅，若可以借阅，则该书籍从<code>shelf</code>删除，并加入客户的<code>books</code>中；如不可以借阅，则该书籍从<code>shelf</code>删除，并加入借阅处的<code>books</code>中。借阅处的操作较为简单，关键在于对客户借阅请求的审批。设计中将该判断分为两部分，分别是书籍是否可以移动以及顾客是否可以借阅。书籍是否移动主要判断<code>shelf</code>中是否有对应剩余的副本，顾客是否可以借阅主要判断<code>customer</code>现在拥有的书籍和借阅请求是否矛盾。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断书籍是否可移动（有余本且不是A类书籍），在Shelf类中进行</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canMove</span><span class="params">(LibraryBookId bookId)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">return</span> books.haveBook(bookId) &amp;&amp; !bookId.isTypeA();</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//判断顾客是否可以借阅或预约书籍，在Customer类中进行</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canBorrowOrAppoint</span><span class="params">(LibraryBookId bookId)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span> (bookId.isTypeB())</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span> !books.haveBTypeBooks();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (bookId.isTypeC())</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span> !books.haveBook(bookId);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>预约流程的实现：</strong>预约流程主要涉及预约操作、取书操作以及停止营业时书籍的内部调整。设计时为预约处设计了两个属性<code>requests</code>和<code>appoints</code>。<code>requests</code>主要存储审批通过的预约请求，<code>appoints</code>主要存储经过内部调整后运送至预约处的书籍的预约信息。在预约环节，仅审核客户的预约资格，如上所示，所有拥有预约资格的请求都应加入请求池中，等待处理；在转运环节，遍历<code>requests</code>，判断书籍是否可以移动以及当前该客户是否可以预约借阅（当客户在预约后进行其他操作并失去拥有书籍的资格时，如此可以保证当其再获得拥有书籍的资格时，预约请求仍能生效，提高客户<code>picked</code>的成功率），对于书籍可移动且当前该客户可预约借阅的请求，转运书籍，并以当前转运的<code>bookId</code>、<code>customer</code>、<code>date</code>创建新的预约信息，存入<code>appoints</code>中，等待客户取书。当客户取书时，遍历<code>appoints</code>找到为其准备的书籍并删除对应的预约信息。</p>
</li>
<li><p><strong>停止营业阶段的书籍转运：</strong>书籍转运主要有两部分组成，即借阅处与书架区、预约处与书架区的转运。请注意，转运操作无强制逻辑要求，可以自行设计转运方案。但最佳方案应有转运至书架区的操作在转运至预约处的操作前进行，以提高对应书籍转运的成功率以及客户获得书籍的成功率。</p>
<ul>
<li>借阅处与书架区间转运：主要是用户借阅失败以及归还的书籍返回书架区，操作较为简单，将借阅处的<code>books</code>清空，并将返回的集合转运添加至书架区的<code>books</code>中即可。该部分操作放在闭馆时进行，这样的好处是每天借阅处的书籍都能及时返回书架区。</li>
<li>预约处与书架区间转运：主要是用户未取走因到时间而失效的预约书籍返回书架区以及因预约从书架区转运至预约处的书籍。对于预约处返回书架区的书籍，遍历<code>appoints</code>，根据预约信息的<code>date</code>，借助<code>LocalDate</code>类提供的<code>isBefore()</code>方法，判断超时需要返回书架区的书籍。对于因预约从书架区转运至预约处的书籍，遍历<code>requests</code>，判断当前需求对应书籍是否可以移动以及客户是否具备取书资质，符合的进行转运。该部分操作放在开馆时进行，这样的好处是当出现进行预约后数天不开馆的情况时，能空除这段时间延长预约有效周期，提高客户<code>picked</code>的成功率。</li>
</ul>
</li>
</ul>
<h3 id="Homework2-1"><a href="#Homework2-1" class="headerlink" title="Homework2"></a>Homework2</h3><p>第二次作业程序中主要有三个实现重点：</p>
<ul>
<li><p><strong>时间判断：</strong>本次作业中，续借请求审核、还书是否超期等判断均需要进行时间判断。在程序中，主要借助于<code>LocalDate</code>类存储操作的时间日期，在时间判断中，主要借助该类中的<code>plusDays()</code>方法来获得截止日期，借助该类中的<code>isBefore()</code>、<code>isAfter()</code>方法来比较日期大小（需注意<code>isBefore()</code>、<code>isAfter()</code>方法不包含当天，即<code>[2024-10-01].isBefore([2024-10-01])</code>是不成立的）。在<code>Inf</code>类中，实现了不在操作时限内方法<code>overOperationLimit()</code>和不在续借时限内方法<code>overContinueLimit()</code>，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不在操作时限内，主要用于归还是否超时判定和预约是否超时判定</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">overOperationLimit</span><span class="params">(LocalDate now)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">//从opDate后一天开始计算，limit天后无效（不包含opDate+limit当天）</span></span><br><span class="line">       <span class="keyword">return</span> opDate.plusDays(limit).isBefore(now);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//不在续借时限内，主要用于是否处于续借时间判定</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">overContinueLimit</span><span class="params">(LocalDate now)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">//从opDate后一天开始计算，limit-4天内无效（不包含opDate+limit-4当天）</span></span><br><span class="line">       <span class="comment">//从opDate后一天开始计算，limit天后无效（不包含opDate+limit当天）</span></span><br><span class="line">       <span class="keyword">return</span> opDate.plusDays(limit - <span class="number">4</span>).isAfter(now) || opDate.plusDays(limit).isBefore(now);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>正式书籍与非正式书籍：</strong>本次作业中，建立了正式书籍和非正式书籍两种书籍类型，具有不同操作，存在于不同位置。同时在借阅处归还后进行书籍返还整理时，应对非正式书籍进行升级，转变为正式书籍，仅改变书籍的类型，不改变书籍的序号。在官方包中，给出了<code>LibraryBookId</code>的<code>toFormal()</code>方法。在该方法中，非正式书籍转为正式书籍时，会返回一个新的<code>LibraryBookId</code>对象。这时候会产生两本原本书籍类型序号均相同的非正式书籍（使用同一个<code>LibraryBookId</code>对象）经过转换后不相同（类型序号均相等，但使用两个不同的<code>LibraryBookId</code>对象）的问题，会对后续书籍存储、书籍类型判断产生影响，因此需要重写<code>LibraryBookId</code>类的<code>equals()</code>、<code>hashCode()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//bookId的toFormal()方法，会产生新对象</span></span><br><span class="line"><span class="keyword">public</span> LibraryBookId <span class="title function_">toFormal</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">       <span class="keyword">switch</span> (<span class="built_in">this</span>.type) </span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">case</span> AU:</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LibraryBookId</span>(LibraryBookId.Type.A, <span class="built_in">this</span>.uid);</span><br><span class="line">           <span class="keyword">case</span> BU:</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LibraryBookId</span>(LibraryBookId.Type.B, <span class="built_in">this</span>.uid);</span><br><span class="line">           <span class="keyword">case</span> CU:</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LibraryBookId</span>(LibraryBookId.Type.C, <span class="built_in">this</span>.uid);</span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">               <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//重写后的equals()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object var1)</span> </span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">this</span> == var1) </span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (var1 != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.getClass() == var1.getClass()) </span><br><span class="line">       &#123;</span><br><span class="line">           <span class="type">LibraryBookId</span> <span class="variable">var2</span> <span class="operator">=</span> (LibraryBookId)var1;</span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">this</span>.type == var2.type &amp;&amp; Objects.equals(<span class="built_in">this</span>.uid, var2.uid);</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">else</span> </span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//重写后的hashCode()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> </span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">return</span> Objects.hash(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="built_in">this</span>.type, <span class="built_in">this</span>.uid&#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>Service</code>接口的实现：</strong>本次作业中，实现了<code>Service</code>的接口，实例化出各种服务，并将其储存在<code>System</code>类中进行调用。<code>Service</code>接口主要实现<code>work()</code>方法，每个实例化的<code>Service</code>内含<code>library</code>属性，并在<code>work()</code>方法中使用。</p>
</li>
</ul>
<h3 id="Homework3-1"><a href="#Homework3-1" class="headerlink" title="Homework3"></a>Homework3</h3><p>第三次作业程序中主要有两个实现重点：</p>
<ul>
<li><strong>借阅超期的扣分机制：</strong>用户每次成功获得书籍，在该书应归还日期的当日闭馆后，若用户仍未归还图书，该用户信用积分减2。请注意，应该在借阅期限当天扣除积分，而不是归还书籍当天扣除。因此在<code>Customer</code>类中新建属性<code>returnBooks</code>表示客户拥有的尚未扣除积分的书籍，在每日结束时对该属性遍历扣除积分，已扣除积分的书籍移除。</li>
<li><strong>整理流程的顺序安排：</strong>按照要求，在闭馆后，应先对借阅超期和预约超期的客户进行分数扣除，再对有捐赠非正式书籍转正的客户进行加分。因此，闭关后整理流程的顺序安排应是：遍历客户，对客户进行借阅逾期积分扣除$\rightarrow$整理预约处书籍，对客户预约逾期未取积分扣除，并将书籍返还书架$\rightarrow$整理借阅处书籍，对有捐赠非正式书籍转正的客户加分，并将书籍返换书籍和图书漂流角$\rightarrow$整理书架，按照预约请求将书籍运送至预约处。</li>
</ul>
<hr>
<h2 id="三、Bug分析及程序优化"><a href="#三、Bug分析及程序优化" class="headerlink" title="三、Bug分析及程序优化"></a>三、Bug分析及程序优化</h2><h3 id="Homework1-2"><a href="#Homework1-2" class="headerlink" title="Homework1"></a>Homework1</h3><h4 id="Bug分析"><a href="#Bug分析" class="headerlink" title="Bug分析"></a>Bug分析</h4><p>本次作业暂无bug。</p>
<h4 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h4><p>本次作业对性能要求较低，暂无优化策略。</p>
<h3 id="Homework2-2"><a href="#Homework2-2" class="headerlink" title="Homework2"></a>Homework2</h3><h4 id="Bug分析-1"><a href="#Bug分析-1" class="headerlink" title="Bug分析"></a>Bug分析</h4><p>本次作业暂无bug。</p>
<h4 id="优化策略-1"><a href="#优化策略-1" class="headerlink" title="优化策略"></a>优化策略</h4><p>本次作业对性能要求较低，暂无优化策略。</p>
<h3 id="Homework3-2"><a href="#Homework3-2" class="headerlink" title="Homework3"></a>Homework3</h3><h4 id="Bug分析-2"><a href="#Bug分析-2" class="headerlink" title="Bug分析"></a>Bug分析</h4><p>本次作业暂无bug。</p>
<h4 id="优化策略-2"><a href="#优化策略-2" class="headerlink" title="优化策略"></a>优化策略</h4><p>本次作业对性能要求较低，暂无优化策略。</p>
<hr>
<h2 id="四、心得体会"><a href="#四、心得体会" class="headerlink" title="四、心得体会"></a>四、心得体会</h2><p>在学习过前三个单元后，第四个单元迎来了完全自由的代码框架设计。不得不说，经过前三个单元的魔鬼训练，笔者学到了许多理念与思想，并运用在了本单元中，比如说本单元中的核心类<code>BookBuffer</code>类，就是参考第二单元中的<code>RequestQueue</code>类进行设计的。同时，按照相像性设计了<code>Office</code>类和<code>Service</code>接口，将一些类进行抽象，并将其存储在<code>System</code>的数组中，可以实现更进一步的方法抽象。</p>
<p>那么心得体会部分就主要谈谈这单元完成之后的一些收获和经验吧：</p>
<ul>
<li><strong>架构设计的重要性。</strong>好的，这已经是第四遍了。相较于第三单元，本单元实现难度大幅降低，设计自由度大幅提高。好的设计逻辑更加鲜明，实现更加抽象，复用性更高。</li>
<li><strong>各类语言的阅读能力。</strong> 第三单元作业出现了<code>JML</code>语言，本单元作业中出现了<code>UML</code>语言。<code>UML</code>语言可视化程度高，阅读更加清晰明白。但是<code>starUML</code>从头构建<code>UML</code>图确实是一件繁琐的事情，耗费大量时间。同时，正常来说，<code>UML</code>图的设计应在程序设计最开始进行，但是在真正实现时，会发现很多细节都有瑕疵，需要不停修改，较为难办。</li>
<li><strong>测试的重要性。</strong> 在第三单元中，最重要的是程序测试，本单元中同样重要。本单元中，由于服务种类众多，组合出很多种情况，又存在如信誉积分这种影响全局的属性，因此需要进行详尽的测试。</li>
</ul>
<p>至于对课程的建议，就留到期末总结中说吧。</p>
<p>最后，还是要感谢助教wwr学长的帮助。也希望在之后的学习中能再接再厉，继续进步。</p>
]]></content>
      <categories>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Lab2实验报告</title>
    <url>/2025/03/15/OS/Lab2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="Lab2实验报告"><a href="#Lab2实验报告" class="headerlink" title="Lab2实验报告"></a>Lab2实验报告</h1><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-2-1"><a href="#Thinking-2-1" class="headerlink" title="Thinking 2.1"></a>Thinking 2.1</h3><ul>
<li>编写c程序时，指针变量存储的地址是虚拟地址；</li>
<li>编写汇编程序时，<code>lw</code>、<code>sw</code>指令使用的是虚拟地址。</li>
</ul>
<h3 id="Thinking-2-2"><a href="#Thinking-2-2" class="headerlink" title="Thinking 2.2"></a>Thinking 2.2</h3><ol>
<li><p>链表操作多项操作具有重复性，使用宏定义封装部分代码，并在链表操作时多次使用，可以大大提高可重用性和简便性。</p>
</li>
<li><p>不同链表比较：</p>
<ul>
<li>单向链表：可以很好的顺序进行，但是不可以访问当前元素之前的元素；</li>
<li>双向链表：既可以正向进行，也可以逆向进行，可以直接访问当前元素之前的和之后的元素，性能较好；</li>
<li>循环链表：可以很好的顺序进行，但是不可以直接访问当前元素之前的元素，需要循环查找（单向循环列表，双向循环列表性能与普通双向链表相当）；</li>
</ul>
<p>本实验中设计的双向链表与经典双向链表不同，本实验中链表不能访问上一个元素，只能访问上一个元素的<code>next</code>指针；即本实验中链表无法访问上一个元素，只能改变上一个元素的连接关系。</p>
</li>
</ol>
<h3 id="Thinking-2-3"><a href="#Thinking-2-3" class="headerlink" title="Thinking 2.3"></a>Thinking 2.3</h3><p>按照实验设计，选择C选项设计方案最佳：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page_list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">le_next</span>;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> **<span class="title">le_prev</span>;</span></span><br><span class="line">        &#125; pp_link;</span><br><span class="line">        u_short pp_ref;</span><br><span class="line">    &#125;* lh_first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>pp_link</code>代表链表的连接单元，内含两种指针，分别是<code>*le_next</code>指向链表下一个元素，<code>**le_prev</code>指向链表上一个元素的<code>*le_next</code>指针，可以直接改变连接顺序。<code>pp_ref</code>代表链表页块计数。<code>*lh_first</code>代表链表的初元素的地址。</p>
<h3 id="Thinking-2-4"><a href="#Thinking-2-4" class="headerlink" title="Thinking 2.4"></a>Thinking 2.4</h3><p>在一次任务中，可能会出现多个进程，同时还可能发生不同进程调用相同的虚拟内存。此时，<code>asid</code>可以保证不会出现不同进程互相错误调用物理地址的问题。同时，其也可以保证系统不会进错TLB，导致TLB发生更换映射，因此也可以提高TLB效率。</p>
<h3 id="Thinking-2-5"><a href="#Thinking-2-5" class="headerlink" title="Thinking 2.5"></a>Thinking 2.5</h3><p><code>tlb_invalidate</code>函数如以下代码块所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tlb_invalidate</span><span class="params">(u_int asid, u_long va)</span> </span><br><span class="line">&#123;</span><br><span class="line">	tlb_out((va &amp; ~GENMASK(PGSHIFT, <span class="number">0</span>)) | (asid &amp; (NASID - <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>tlb_out</code>函数如以下代码块所示：</p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line">LEAF(tlb_out)</span><br><span class="line"><span class="meta">.set</span> <span class="keyword">noreorder</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">mfc0 </span>   <span class="built_in">t0</span>, CP0_ENTRYHI  //从<span class="built_in">EntryHi</span>中获得参数，存入<span class="built_in">t0</span>寄存器中</span><br><span class="line">    <span class="keyword">mtc0 </span>   <span class="built_in">a0</span>, CP0_ENTRYHI  //将<span class="built_in">a0</span>中参数Key放入<span class="built_in">EntryHi</span>寄存器中</span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">tlbp </span> //根据<span class="built_in">EntryHi</span>中的Key，查找TLB中与之对应的表项，并将表项的索引存入Index寄存器</span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">mfc0 </span>   <span class="built_in">t1</span>, CP0_INDEX  //从Index中获得表项索引，存入<span class="built_in">t1</span>寄存器中</span><br><span class="line"><span class="meta">.set</span> reorder</span><br><span class="line">    <span class="keyword">bltz </span>   <span class="built_in">t1</span>, NO_SUCH_ENTRY  //判断表项索引与<span class="number">0</span>的关系，大于等于<span class="number">0</span>时向下进行，小于<span class="number">0</span>时跳转至NO_SUCH_ENTRY</span><br><span class="line"><span class="meta">.set</span> <span class="keyword">noreorder</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">mtc0 </span>   <span class="built_in">zero</span>, CP0_ENTRYHI  //向<span class="built_in">EntryHi</span>中写入<span class="number">0</span></span><br><span class="line">    <span class="keyword">mtc0 </span>   <span class="built_in">zero</span>, CP0_ENTRYLO0  //向<span class="built_in">EntryLo0</span>中写入<span class="number">0</span></span><br><span class="line">    <span class="keyword">mtc0 </span>   <span class="built_in">zero</span>, CP0_ENTRYLO1  //向<span class="built_in">EntryLo1</span>中写入<span class="number">0</span></span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">tlbwi </span> //以Index寄存器中的值为索引，将此时<span class="built_in">EntryHi</span>与<span class="built_in">EntryLo0</span>、<span class="built_in">EntryLo1</span>的值写到索引指定的TLB表项中</span><br><span class="line"><span class="meta">.set</span> reorder</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">NO_SUCH_ENTRY:</span></span><br><span class="line">    <span class="keyword">mtc0 </span>   <span class="built_in">t0</span>, CP0_ENTRYHI  //向<span class="built_in">EntryHi</span>中写入进入函数时原始的<span class="built_in">EntryHi</span>中存放的值</span><br><span class="line">    <span class="keyword">j </span>      <span class="built_in">ra</span></span><br><span class="line">END(tlb_out)</span><br></pre></td></tr></table></figure>
<ul>
<li>在<code>tlb_invalidate</code>函数中调用了<code>tlb_out</code>函数。</li>
<li><code>tlb_invalidate</code>函数主要实现在获得新的页表项进行更新时，对旧有表项进行删除。</li>
<li>对函数<code>tlb_out</code>的解释如前文所示。</li>
</ul>
<h3 id="Thinking-2-6"><a href="#Thinking-2-6" class="headerlink" title="Thinking 2.6"></a>Thinking 2.6</h3><p>X86 和 MIPS 在内存管理上主要有以下几点区别：</p>
<ul>
<li><strong>地址形式：</strong>X86有三种地址形式：逻辑地址、线性地址、物理地址；MIPS有两种地址形式：虚拟地址、物理地址。</li>
<li><strong>内存管理机制：</strong>X86主要采用的是段页式管理系统，MIPS主要采用的是页式管理系统（并使用<code>MMU</code>管理内存）。</li>
<li><strong>TLB 不命中时的处理：</strong>转换失败的虚拟地址，MIPS使用<code>BadVAddr</code>寄存器存放，X86使用<code>CR2</code>存放。<ul>
<li>X86是以<code>CR3</code>作为当前进程的PGD基址，索引获得PFN后，直接输出PA。同时MMU会填充TLB以加快下次转换的速度。</li>
<li>MIPS 触发TLB Refill 异常，内核的 <code>tlb_refill_handler</code> 会以 <code>pgd_current</code> 为当前进程的 <code>PGD</code> 基址，索引获得转换失败的虚拟地址对应的 <code>PTE</code>，并将其填入TLB，然后CPU再用刚刚转换失败的虚拟地址重新访问TLB。</li>
</ul>
</li>
</ul>
<h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><p>本次实验中，我所遇到的难点主要是以下几点：</p>
<ul>
<li><strong>宏定义的多次出现：</strong>本次实验代码中，出现大量宏定义。这样大大简便了代码逻辑性，但是也增加了阅读与编写的难度。尤其在文件众多，指导书中并未明确标注可能使用的宏定义以及其位置的情况下，初次接触内存管理并编写程序的难度极大。</li>
<li><strong>多项函数的互相调用：</strong>本次实验中，出现大量函数。这些函数相互联系，在使用中往往需要互相调用，逻辑难度较高。同时也具有分布分散的问题，导致阅读时间较长。</li>
<li><strong>页表及页链表的使用：</strong>本次实验中，页结构体作为重点。同时实验中大量使用一阶二阶指针，更改内容。指针指向对象复杂，逻辑难度大。页表内部属性较多，需要逐个调整。</li>
<li><strong>二级页表的映射：</strong>实验中主要使用二级页表的结构，一级页表作为页框映射获得二级页表序号，二级页表作为页号映射获得页内容的真实物理地址。映射过程中的数据提取（该部分数据提取哪几位）及数据对应（这些数据又对应下一级数据地址的哪几位）难度较大。</li>
</ul>
<h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>Lab2主要让我们学习有关内存管理与映射的问题，了解MIPS系统中虚拟地址与物理地址的对应关系以及在启动过程中获得与输入数据对应的真实数据。整体而言，Lab2的难度应该说是远大于前两个lab的，涉及到的知识点很多很新，同时又有大量未知的需要自己阅读的宏定义和函数（在不知道使用目的与形参函数的含义情况下上手难度极大），对于小白来说还是比较不友好，也花费了我很长一段时间来完成，不得不说，确实让我焦头烂额。因此，十分感谢那些写博客的学长，看了他们的博客后真的是茅塞顿开。操作系统的学习肯定是艰难的，还需坚定内心，勇于攀登。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Mips</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Lab1实验报告</title>
    <url>/2025/03/15/OS/Lab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="Lab1实验报告"><a href="#Lab1实验报告" class="headerlink" title="Lab1实验报告"></a>Lab1实验报告</h1><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-1-1"><a href="#Thinking-1-1" class="headerlink" title="Thinking 1.1"></a>Thinking 1.1</h3><ul>
<li><p>x86原生工具链和mips交叉编译工具链对比：</p>
<ul>
<li><p>x86原生工具链：</p>
<ul>
<li><p>编译但未链接文件x86程序：</p>
<p><img src="/images/OS/Lab1实验报告/thinking1-1.png" alt="thinking1-1"></p>
</li>
<li><p>链接后文件x86程序：</p>
<p><img src="/images/OS/Lab1实验报告/thinking1-2.png" alt="thinking1-2"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>mips交叉编译工具链：</p>
<ul>
<li>编译但未链接mips程序：</li>
</ul>
<p><img src="/images/OS/Lab1实验报告/thinking1-3.png" alt="thinking1-3"></p>
<ul>
<li>链接后mips程序：</li>
</ul>
<p><img src="/images/OS/Lab1实验报告/thinking1-4.png" alt="thinking1-4"></p>
</li>
</ul>
<ul>
<li><p>objdump传入参数：</p>
<ul>
<li><p><code>-d</code>：—disassemble[=symbol]，反汇编特定指令机器码的节；</p>
</li>
<li><p><code>-D</code>：—disassemble-all，反汇编全部节代码；</p>
</li>
<li><p><code>-S</code>：—source，代码段反汇编同时，将反汇编代码和源代码交替显示；</p>
</li>
<li><p><code>-g</code>：—debugging，显示调试信息；</p>
</li>
<li><p><code>-l</code>：—line-numbers，代码段反汇编同时，显示反汇编代码行数。</p>
</li>
</ul>
</li>
</ul>
<h3 id="Thinking-1-2"><a href="#Thinking-1-2" class="headerlink" title="Thinking 1.2"></a>Thinking 1.2</h3><ul>
<li>解析<code>/target/mos</code>：</li>
</ul>
<p><img src="C:\Users\SUN\AppData\Roaming\Typora\typora-user-images\image-20240320222833054.png" alt="image-20240320222833054"></p>
<ul>
<li><code>readelf</code>解析<code>readelf</code>文件和<code>hello</code>文件：可见有<strong>多项因素</strong>会影响文件是否会被自定义<code>readelf</code>解析，如是<strong>大端项还是小端项</strong>，如<strong>文件位数（32位或64位）</strong></li>
</ul>
<p><img src="/images/OS/Lab1实验报告/thinking2-1.png" alt="thinking2-1"></p>
<p><img src="/images/OS/Lab1实验报告/thinking2-2.png" alt="thinking2-2"></p>
<h3 id="Thinking-1-3"><a href="#Thinking-1-3" class="headerlink" title="Thinking 1.3"></a>Thinking 1.3</h3><p>在文件<code>kernel.lds</code>中，我们设置了<code>.text</code>，<code>.data</code>，<code>.bss</code>的位置（ELF文件中的各节位置），并且设置了函数<code>ENTRY(_start)</code>指定了程序入口（即内核入口），可以正确跳转到内核入口。</p>
<h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><p>本次实验难点主要在于对于ELF文件以及节段页表的理解。</p>
<ol>
<li><code>readelf</code>理解，内部初始位置以及节位置的设定，对于内核完整的内存布局的理解。</li>
<li><code>Elf32_Shdr</code>地址与该节地址的不同（<code>addr=(*shdr).shaddr</code>）。</li>
<li>启动程序<code>start.S</code>中<code>sp指针</code>地址设置以及函数跳转。</li>
<li><code>vprintfmt()</code>函数中各段的意义，以及具体的编程（这段c程序理解应该是Lab1中最难的一点了）。</li>
<li>……</li>
</ol>
<h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>Lab1主要让我们学习有关程序内核的问题（操作系统中程序的启动流程），了解一个c程序从编程到实现间的预处理、编译、链接过程，以及实现简单的<code>printf()</code>函数。整体而言，Lab1的难度应该也是比较大的，涉及到的知识点很多很新，对于小白来说还是比较不友好，也花费了我很长一段时间来完成。但是了解了函数底层的实现原理以及程序的启动问题，让我觉得收获满满，也觉得付出的努力都是值得的。希望以后Lab的学习也能再接再厉，力求彻底理解吧！</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Mips</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Lab3实验报告</title>
    <url>/2025/03/15/OS/Lab3%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="Lab3实验报告"><a href="#Lab3实验报告" class="headerlink" title="Lab3实验报告"></a>Lab3实验报告</h1><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-3-1"><a href="#Thinking-3-1" class="headerlink" title="Thinking 3.1"></a>Thinking 3.1</h3><ul>
<li><code>UVPT</code>是<code>kuseg</code>保存用户当前进程页表信息的虚拟地址区，<code>e-&gt;env_pgdir</code>是进程页目录对应的物理地址。<code>PADDR(e-&gt;env_pgdir) | PTE_V</code>将对应页目录物理地址转换为页表项物理地址并赋予页表有效性信息，存入当前进程对应的<code>pgdir</code>中。</li>
</ul>
<h3 id="Thinking-3-2"><a href="#Thinking-3-2" class="headerlink" title="Thinking 3.2"></a>Thinking 3.2</h3><ul>
<li><code>void *data</code>主要在函数<code>load_icode_mapper</code>、<code>load_icode</code>、<code>load_elf</code>中直接使用或间接涉及。这个参数不可以去除，在产生<code>mapper</code>的时候，可能需要多种额外数据辅助映射，因此需要添加。</li>
</ul>
<h3 id="Thinking-3-3"><a href="#Thinking-3-3" class="headerlink" title="Thinking 3.3"></a>Thinking 3.3</h3><ul>
<li>从<code>binary</code>无法获得<code>ehdr</code></li>
<li>从<code>binary + ph_off</code>无法获得<code>ph</code>或获得的<code>ph-&gt;p_type</code>是<code>PT_LOAD</code></li>
</ul>
<h3 id="Thinking-3-4"><a href="#Thinking-3-4" class="headerlink" title="Thinking 3.4"></a>Thinking 3.4</h3><ul>
<li>虚拟地址</li>
</ul>
<h3 id="Thinking-3-5"><a href="#Thinking-3-5" class="headerlink" title="Thinking 3.5"></a>Thinking 3.5</h3><ul>
<li>0,1,2,3号异常函数均在<code>/kern/genex.S</code>文件中实现</li>
<li>0号异常使用汇编程序，1,2,3号异常函数均使用宏定义进行描述</li>
</ul>
<h3 id="Thinking-3-6"><a href="#Thinking-3-6" class="headerlink" title="Thinking 3.6"></a>Thinking 3.6</h3><ul>
<li>时钟达到每个时钟间断间隔，触发时钟中断。</li>
<li>当时钟周期达到预期执行周期时发生时钟中断。具体实现为<code>Count</code> 寄存器的值与<code>Compare</code> 寄存器的值相等且非0时触发中断（<code>Count</code>每周期递增，代表当前已进行周期数）</li>
<li>时钟周期达到预期执行周期进行更换进程之后发生时钟中断。<code>RESET_KCLOCK</code>宏将 <code>Count</code> 寄存器清零并将 <code>Compare</code>寄存器配置期望的计时器周期数， 完成对Timer配置。在设定时钟周期后，时钟中断将被触发。</li>
</ul>
<h3 id="Thinking-3-7"><a href="#Thinking-3-7" class="headerlink" title="Thinking 3.7"></a>Thinking 3.7</h3><ul>
<li><p>系统切换运行进程代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">(<span class="type">int</span> yield)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">//静态全局变量，储存当前剩余待执行的周期数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span> =</span> curenv; <span class="comment">//当前的环境变量，当前进程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当发生以下四种情况时更换进程，进行时钟中断</span></span><br><span class="line">    <span class="comment">//当前进程已经被执行过(yield != 0)，除非只有一个进程，否则更换进程</span></span><br><span class="line">    <span class="comment">//当前进程执行轮数已达到预期轮数(count == 0)，更换线程</span></span><br><span class="line">    <span class="comment">//当前进程不存在(e == NULL)</span></span><br><span class="line">    <span class="comment">//当前进程状态不处于可以运行的状态(e-&gt;env_status != ENV_RUNNABLE)</span></span><br><span class="line">    <span class="keyword">if</span> (yield != <span class="number">0</span> || count == <span class="number">0</span> || e == <span class="literal">NULL</span> || e-&gt;env_status != ENV_RUNNABLE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果e存在，将该进程移出规划列表</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            TAILQ_REMOVE(&amp;env_sched_list, e, env_sched_link);</span><br><span class="line">            <span class="comment">//如果该进程仍处于需要运行的状态，就将其仍放入规划列表尾端</span></span><br><span class="line">            <span class="keyword">if</span> (e-&gt;env_status == ENV_RUNNABLE)</span><br><span class="line">            &#123;</span><br><span class="line">                TAILQ_INSERT_TAIL(&amp;env_sched_list, e, env_sched_link);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//规划列表中不存在需要运行的列表</span></span><br><span class="line">        <span class="keyword">if</span> (TAILQ_EMPTY(&amp;env_sched_list))</span><br><span class="line">        &#123;</span><br><span class="line">            panic(<span class="string">&quot;schedule: no runnable envs&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        e = TAILQ_FIRST(&amp;env_sched_list); <span class="comment">//更换进程时，选择位于列表头的进程</span></span><br><span class="line">        count = e-&gt;env_pri; <span class="comment">//将待执行周期数设置为预期周期数</span></span><br><span class="line">    &#125;</span><br><span class="line">    count--; <span class="comment">//每个周期进行，待执行周期数减少</span></span><br><span class="line">    env_run(e); <span class="comment">//执行进程e一个周期</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个周期执行之后，均会产生一次时钟中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>每一次时钟中断均会触发一轮判断（是否切换当前执行进程）。</p>
</li>
</ul>
<h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><p>本次实验中，我遇到的难点主要有以下几点：</p>
<ul>
<li>页表地址映射：实验中主要使用二级页表的结构，一级页表作为页框映射获得二级页表序号，二级页表作为页号映射获得页内容的真实物理地址。映射过程中的数据提取（该部分数据提取哪几位）及数据对应（这些数据又对应下一级数据地址的哪几位）难度较大，对于当前地址含义的判断也有一定难度。</li>
<li>进程环境的构建：在实验中，设立了多个函数用于构建env并对构建的env进行多项属性设置。如初始化，为环境分配空余页表，数据拷贝等多项操作，整体理解难度较大，实现难度正常。</li>
</ul>
<h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>Lab3主要让我们学习有关进程与时钟中断的问题，了解MIPS系统中虚拟地址与物理地址的对应关系、建立并初始化新进程、通过时钟中断实现进程的运行与更换。整体而言，受益于Lab3优秀的指导书和清晰明白的代码注释，其难度应该是小于Lab2的。本次实验涉及到的知识点很多很新，同时也有大量未知的需要自己阅读的宏定义和函数（在不知道使用目的与形参函数的含义情况下上手难度极大），对于小白来说还是比较不友好，也花费了我很长一段时间来完成，但各函数与Lab2中宏定义与自定义函数基本一致，有了Lab2长时间的学习就会很好解决，也会很明白。同时，也十分感谢那些写博客的学长，看了他们的博客后真的是茅塞顿开。实验越往后走，陌生的东西越多，还是要摆正心态，世上无难事，只要肯攀登。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Mips</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Lab4实验报告</title>
    <url>/2025/03/15/OS/Lab4%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="Lab4实验报告"><a href="#Lab4实验报告" class="headerlink" title="Lab4实验报告"></a>Lab4实验报告</h1><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-4-1"><a href="#Thinking-4-1" class="headerlink" title="Thinking 4.1"></a>Thinking 4.1</h3><ul>
<li>进入内核态时首先使用<code>SAVE_ALL</code>函数将<code>sp</code>寄存器数据存入<code>k0</code>、<code>k1</code>中，同时使用<code>sp</code>的数据将通用寄存器数据压栈，存入环境控制块中，再次使用时将其出栈即可。</li>
<li>不可以，在调用过程中，将系统调用号存入了<code>a0</code>，因此寄存器中数据发生了改变。<code>a1</code>-<code>a3</code>寄存器没有显式改变，但也未规定不可以发生改变，因此出于正确性考虑，最优方法通过栈中数据使用。</li>
<li>函数中所有数据来源均是环境的数据栈，而数据栈中的数据均是在调用时传入的，因此<code>sys</code>函数与<code>msyscall</code>中参数相同。</li>
<li>修改了<code>Trapframe-&gt;epc += 4</code>，保证返回用户态时可以执行下一条指令；修改了<code>Trapframe-&gt;regs[2] = returnRes</code>，保证<code>v0</code>寄存器中存储返回结果。</li>
</ul>
<h3 id="Thinking-4-2"><a href="#Thinking-4-2" class="headerlink" title="Thinking 4.2"></a>Thinking 4.2</h3><ul>
<li>在设定<code>env</code>的各项参数时有可能出现错误，导致未正确设定<code>env_id</code>，这种<code>env</code>是不可以使用的。该函数在构建进程和查询使用进程的过程中均有使用。如果缺少判断，在实际使用时有可能出现通过<code>envid</code>寻找不到相应<code>env</code>的情况。</li>
</ul>
<h3 id="Thinking-4-3"><a href="#Thinking-4-3" class="headerlink" title="Thinking 4.3"></a>Thinking 4.3</h3><ul>
<li><code>(++i) &lt;&lt; (1 + LOG2NENV)</code>保证返回值一定不为0。</li>
<li>在函数<code>envid2env()</code>中，如果获得的<code>envid</code>为0，那么获得的<code>env</code>就是当前环境<code>curenv</code>。</li>
</ul>
<h3 id="Thinking-4-4"><a href="#Thinking-4-4" class="headerlink" title="Thinking 4.4"></a>Thinking 4.4</h3><p>关于 fork 函数的两个返回值，下面说法正确的是：<br>A、fork 在父进程中被调用两次，产生两个返回值<br>B、fork 在两个进程中分别被调用一次，产生两个不同的返回值<br>C、fork 只在父进程中被调用了一次，在两个进程中各产生一个返回值<br>D、fork 只在子进程中被调用了一次，在两个进程中各产生一个返回值</p>
<ul>
<li>C.函数在两个进程中均要进入，在父进程中完整进行，并返回子进程<code>env_id</code>；子进程中仅复制父进程上下文，并返回0.因此，完整调用仅在父进程中进行了一次。</li>
</ul>
<h3 id="Thinking-4-5"><a href="#Thinking-4-5" class="headerlink" title="Thinking 4.5"></a>Thinking 4.5</h3><ul>
<li><code>UTOP</code>和<code>TLIM</code>之间储存的是和<strong>内核相关</strong>的页表信息。<code>UTOP</code>和<code>USTACKTOP</code>之间是<strong>异常处理栈</strong>和<strong>无效内存</strong>，最终需要被映射的页面<strong>只有<code>USTACKTOP</code>之下的部分</strong>。</li>
</ul>
<h3 id="Thinking-4-6"><a href="#Thinking-4-6" class="headerlink" title="Thinking 4.6"></a>Thinking 4.6</h3><ul>
<li><code>vpt</code>和<code>vpd</code>分别是指向用户页表和用户页目录的指针。用该指针数值（页基地址）加上相对基址偏移即可获得页表项地址。</li>
<li>两个指针分别指向用户地址空间中页表的首地址和页目录的首地址。</li>
<li><code>vpd</code>的值位于<code>UVPT</code>和<code>UVPT+PDMAP</code>之间，说明某个页表可以映射到该页目录。而每个页目录都有对应页表，因此实现了自映射机制。</li>
<li>不行，用户态只能访问页表，不可以修改。</li>
</ul>
<h3 id="Thinking-4-7"><a href="#Thinking-4-7" class="headerlink" title="Thinking 4.7"></a>Thinking 4.7</h3><ul>
<li>用户态程序写入<code>COW</code>页表，触发异常，进入页写入异常的处理程序，并调用<code>pgfault</code>函数处理。如果在该函数中仍写入<code>COW</code>页，将会再次触发异常，出现“异常重入”现象。</li>
<li>异常处理是在用户态下进行的，而用户态只能访问用户空间（低2G空间）内的数据，需要将现场保存在用户空间。</li>
</ul>
<h3 id="Thinking-4-8"><a href="#Thinking-4-8" class="headerlink" title="Thinking 4.8"></a>Thinking 4.8</h3><ul>
<li>减少对于内核态程序的调用，减少对于页表数据的修改，防止程序崩溃影响系统稳定。</li>
</ul>
<h3 id="Thinking-4-9"><a href="#Thinking-4-9" class="headerlink" title="Thinking 4.9"></a>Thinking 4.9</h3><ul>
<li>在<code>syscall_env_alloc</code>中产生子进程并复制数据之前，需要对父进程的页表异常进行处理，防止子进程复制的数据出现异常，因此要在<code>syscall_env_alloc</code>之前调用<code>set_pgfault_handler</code>函数。</li>
</ul>
<h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><p>本次实验中，我遇到的难点主要有以下几点：</p>
<ul>
<li>页表地址映射：实验中主要使用二级页表的结构，一级页表作为页框映射获得二级页表序号，二级页表作为页号映射获得页内容的真实物理地址。映射过程中的数据提取（该部分数据提取哪几位）及数据对应（这些数据又对应下一级数据地址的哪几位）难度较大，对于当前地址含义的判断也有一定难度。</li>
<li><code>mem</code>的关联：在实验中，设立了<code>sys_mem_map()</code>、<code>sys_mem_unmap()</code>函数用来处理进程关联。其中主要使用<code>envid2env()</code>函数，匹配<code>envid</code>与<code>env</code>环境，并将两个页面相匹配。</li>
<li><code>sys</code>函数操作：本次实验中，有多个<code>sys</code>函数操作，涉及到内存的处理、子进程的申请等。这些函数多要调用<code>env</code>相关函数，接口设计与调用较有难度。</li>
</ul>
<h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>Lab4主要让我们学习有关系统调用和申请子进程的问题，了解MIPS系统中虚拟地址与物理地址的对应关系、处理多种系统调用、为具体进程申请子进程并复制进程数据信息。本次实验涉及到的知识点很多很新，同时也有大量未知的需要自己阅读的宏定义和函数（在不知道使用目的与形参函数的含义情况下上手难度极大），继承Lab2和Lab3的函数与知识，逻辑简单，但实现难度较大，也花费了我很长一段时间来完成，但各函数与Lab2、Lab3中宏定义与自定义函数基本一致，有了Lab2、Lab3长时间的学习就会很好解决，也会很明白。同时，也十分感谢那些写博客的学长，看了他们的博客后真的是茅塞顿开。实验越往后走，陌生的东西越多，还是要摆正心态，世上无难事，只要肯攀登。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Mips</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>编译器设计文档</title>
    <url>/2025/03/17/Compiler/%E7%BC%96%E8%AF%91%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h1 id="编译器设计文档"><a href="#编译器设计文档" class="headerlink" title="编译器设计文档"></a>编译器设计文档</h1><h2 id="参考编译器介绍"><a href="#参考编译器介绍" class="headerlink" title="参考编译器介绍"></a>参考编译器介绍</h2><p>本次实验预备阶段主要学习参考了经典的Pascal编译器，现进行一定的介绍。</p>
<h3 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h3><p>课程组提供的Pascal编译器总体结构为词法分析、语法分析、错误处理、语义分析、代码生成和代码优化六个部分。</p>
<h3 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h3><p>该编译器并未进行模块化设计，而是将各函数放在一个文件下，在调用时设定形参实参进行数据的交互。主要函数如下：</p>
<ul>
<li><code>nextch</code> 读取下一个字符</li>
<li><code>test</code> 检查符号合法性</li>
<li><code>error</code> 打印错误信息</li>
<li><code>typ</code>处理类型<ul>
<li><code>typedeclaration</code>处理自定义类型</li>
</ul>
</li>
<li><code>constant</code>处理常量<ul>
<li><code>adjustscale</code>处理实数</li>
</ul>
</li>
<li><code>variabledeclaration</code>处理普通变量</li>
<li><code>procdeclaration</code>处理过程和函数<ul>
<li><code>parameterlist</code> 处理形参</li>
</ul>
</li>
<li><code>statement</code>处理各种语句</li>
<li><code>enter</code>登记符号表<ul>
<li><code>enterreal</code>登记实常量表</li>
<li><code>enterarray</code>登记数组符号表</li>
<li><code>enterblock</code>登记分程序信息入分程序表</li>
</ul>
</li>
<li><code>emit</code>生成中间代码</li>
</ul>
<h3 id="文件组织"><a href="#文件组织" class="headerlink" title="文件组织"></a>文件组织</h3><p>该Pascal编译器全部函数均放在一个文件下，抽象化层次化程度低，复杂程度较高。实际上，可以建立库函数文件（或者像面向对象设计一样建立类，分文件调用），以此降低文件组织的耦合程度。</p>
<hr>
<h2 id="编译器总体设计"><a href="#编译器总体设计" class="headerlink" title="编译器总体设计"></a>编译器总体设计</h2><h3 id="总体结构-1"><a href="#总体结构-1" class="headerlink" title="总体结构"></a>总体结构</h3><p>设计的编译器主要分为前端 <code>Front</code> 、中端 <code>Middle</code> 、后端 <code>Back</code> 三个部分。</p>
<p>其中，前端主要负责词法分析、语法分析部分，有词法分析器 <code>Lexer</code> 、语法分析器 <code>Parser</code> 。中端主要负责语义分析（符号表的构建与管理）与中间代码生成有语义分析器（符号管理器） <code>Manager</code> 、中间代码生成器 <code>Visitor</code> 、代码优化器 <code>Opitimizer</code> 。后端主要负责目标代码生成以及代码优化，有目标代码翻译器 <code>Translator</code> 、代码优化器 <code>Opitimizer</code> 。</p>
<p>整体的结构与流程设计如下所示：</p>
<p><img src="/images/Compiler/编译器设计文档/编译器整体结构图.png" alt="编译器整体结构图" style="zoom: 50%;" /></p>
<h3 id="接口设计-1"><a href="#接口设计-1" class="headerlink" title="接口设计"></a>接口设计</h3><p>前端：</p>
<ul>
<li><code>content</code> ：未经任何处理的待翻译程序字符串；</li>
<li><code>tokens</code> ：经词法分析后获得的单词列表；</li>
<li><code>AST</code> ：经语法分析后获得的抽象语法树（Abstract Syntax Tree，下简称语法树）。</li>
</ul>
<p>中端：</p>
<ul>
<li><code>tables</code> ：经语义分析后获得的符号表项列表，其中列表第一项即是全局符号表项；</li>
<li><code>MCT</code> ：经中间代码生成后获得的中间代码树（Medium Code Tree）。</li>
</ul>
<p>后端：</p>
<ul>
<li><code>OCT</code> ：经目标代码翻译后获得的目标代码树（Object Code Tree）；</li>
<li><code>optim</code> ：经代码优化后获得的目标代码树。</li>
</ul>
<h3 id="文件组织-1"><a href="#文件组织-1" class="headerlink" title="文件组织"></a>文件组织</h3><p>整体文件组织如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├─ Front 前端处理器</span><br><span class="line">├─ Middle 中端处理器</span><br><span class="line">├─ Back 后端处理器</span><br><span class="line">├─ CompileError 编译错误与错误处理器</span><br><span class="line">└─ IO 编译器的输入输出</span><br></pre></td></tr></table></figure>
<p>其中， <code>Front</code> 的文件组织如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├─Lexer 词法分析</span><br><span class="line">│      Lexer.java 词法分析器类</span><br><span class="line">│      Token.java 单词类</span><br><span class="line">└─Parser 语法分析</span><br><span class="line">    │  Parser.java 语法分析器类</span><br><span class="line">    └─Syntax 语法成分</span><br><span class="line">        │  Syntax.java 语法成分接口</span><br><span class="line">        ├─Block 块</span><br><span class="line">        │      Block.java 块类</span><br><span class="line">        │      BlockItem.java 语句块项类</span><br><span class="line">        ├─Const 常量</span><br><span class="line">        │      IntConst.java 数字常量类</span><br><span class="line">        │      CharConst.java 字符常量类</span><br><span class="line">        │      StringConst.java 字符串常量类</span><br><span class="line">        ├─Decl 声明</span><br><span class="line">        │      Decl.java 声明类</span><br><span class="line">        │      ConstDecl.java 常量声明类</span><br><span class="line">        │      VarDecl.java 变量声明类</span><br><span class="line">        ├─Def 定义</span><br><span class="line">        │      ConstDef.java 常量定义类</span><br><span class="line">        │      FuncDef.java 函数定义类</span><br><span class="line">        │      MainFuncDef.java 主函数定义类</span><br><span class="line">        │      VarDef.java 变量定义类</span><br><span class="line">        ├─Expr 表达式</span><br><span class="line">        │      LOrExpr.java 逻辑或表达式类</span><br><span class="line">        │      LAndExpr.java 逻辑与表达式类</span><br><span class="line">        │      EqExpr.java 相等性表达式类</span><br><span class="line">        │      RelExpr.java 关系表达式</span><br><span class="line">        │      Expr.java 普通表达式类</span><br><span class="line">        │      ConstExpr.java 常量表达式类</span><br><span class="line">        │      AddExpr.java 加减表达式类</span><br><span class="line">        │      MulExpr.java 乘除模表达式类</span><br><span class="line">        │      UnaryExpr.java 一元表达式类</span><br><span class="line">        │      PrimaryExpr.java 基本表达式类</span><br><span class="line">        ├─Param 参数</span><br><span class="line">        │      FuncFParams.java 函数形参表类</span><br><span class="line">        │      FuncFParam.java 函数形参</span><br><span class="line">        │      FuncRParams.java 函数实参表类</span><br><span class="line">        ├─Reserved 保留元素</span><br><span class="line">        │      Number.java 数字类</span><br><span class="line">        │      Character.java 字符类</span><br><span class="line">        │      Ident.java 标识符类</span><br><span class="line">        │      ReservedWord.java 保留字类</span><br><span class="line">        │      UnaryOp.java 一元操作符类</span><br><span class="line">        ├─Stmt 语句</span><br><span class="line">        │      Cond.java 条件类</span><br><span class="line">        │      ForStmt.java for语句类</span><br><span class="line">        │      Stmt.java 语句类</span><br><span class="line">        ├─Type 类型</span><br><span class="line">        │      BType.java 数据类型类</span><br><span class="line">        │      FuncType.java 函数类型类</span><br><span class="line">        ├─Unit 单元</span><br><span class="line">        │      CompUnit.java 编译单元类 </span><br><span class="line">        └─Val 值</span><br><span class="line">                ConstInitVal.java 常量初值</span><br><span class="line">                InitVal.java 变量初值</span><br><span class="line">                LVal.java 左值表达式</span><br></pre></td></tr></table></figure>
<p><code>Middle</code> 的文件组织如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├─Manager 符号管理</span><br><span class="line">│  │  Manager.java 符号管理类</span><br><span class="line">│  │  Table.java 符号表项类</span><br><span class="line">│  │  TableViewer.java 符号表观察类</span><br><span class="line">│  └─Symbols 符号</span><br><span class="line">│          Symbol.java 符号类</span><br><span class="line">│          ArraySymbol.java 数组符号类</span><br><span class="line">│          FuncSymbol.java 函数符号类</span><br><span class="line">│          VarSymbol.java 普通变量常量类</span><br><span class="line">└─Visitor 中间代码生成</span><br><span class="line">    │  Visitor.java 中间代码生成器类</span><br><span class="line">    │  VisitorFeature.java 中间代码生成器特征类</span><br><span class="line">    └─LLVMIR 中间代码生成LLVMIR预备部分</span><br><span class="line">        ├─TypeIR MCT节点类型</span><br><span class="line">        │  │  ValueTypeIR.java MCT节点类型类</span><br><span class="line">        │  ├─BasicType 基础类型</span><br><span class="line">        │  │      IntegerTypeIR.java int/char/bool数据类型类</span><br><span class="line">        │  │      LabelTypeIR.java 标签类</span><br><span class="line">        │  │      VoidTypeIR.java void数据类型类</span><br><span class="line">        │  └─CompType 复合类型</span><br><span class="line">        │          ArrayTypeIR.java 数组类型类</span><br><span class="line">        │          FunctionTypeIR.java 函数类型类</span><br><span class="line">        │          PointerTypeIR.java 指针类型类</span><br><span class="line">        └─ValueIR MCT节点</span><br><span class="line">            │  IR.java MCT节点接口</span><br><span class="line">            │  ValueIR.java MCT值类</span><br><span class="line">            ├─Component 中间代码组成</span><br><span class="line">            │      BasicBlockIR.java 中间代码块类</span><br><span class="line">            │      FunctionIR.java 中间代码函数类</span><br><span class="line">            │      ModuleIR.java 中间代码模块类</span><br><span class="line">            ├─Constant 中间代码常数</span><br><span class="line">            │      ConstantArrayIR.java 常数组类</span><br><span class="line">            │      ConstantIR.java 常数类</span><br><span class="line">            │      ConstantStringIR.java 常字符串类</span><br><span class="line">            ├─Instruction 中间代码指令</span><br><span class="line">            │  │  InstructionIR.java 中间代码类</span><br><span class="line">            │  ├─calculate 计算指令</span><br><span class="line">            │  │      BinaryIR.java 二元计算类</span><br><span class="line">            │  │      BTypeTranIR.java 数据类型转换类</span><br><span class="line">            │  │      IcmpIR.java 比较类</span><br><span class="line">            │  ├─jump 跳转指令</span><br><span class="line">            │  │      BrIR.java 跳转类</span><br><span class="line">            │  │      RetIR.java 返回类</span><br><span class="line">            │  └─memory 内存指令</span><br><span class="line">            │          AllocateIR.java 申请内存类</span><br><span class="line">            │          CallIR.java 调用函数类</span><br><span class="line">            │          GetElementIR.java 计算数组元素地址类</span><br><span class="line">            │          LoadIR.java 加载类</span><br><span class="line">            │          StoreIR.java 存储类</span><br><span class="line">            └─Variable 中间代码变量</span><br><span class="line">                    GlobalVariableIR.java 中间代码全局声明类</span><br><span class="line">                    VariableIR.java 变量类</span><br></pre></td></tr></table></figure>
<p><code>Back</code> 的文件组织如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├─Optimizer 代码优化</span><br><span class="line">│      Optimizer.java 优化器类</span><br><span class="line">└─Translator 目标代码生成</span><br><span class="line">    │  Translator.java 目标代码翻译器类</span><br><span class="line">    ├─Mips 目标代码生成MIPS预备部分</span><br><span class="line">    │  │  Mips.java OCT节点类</span><br><span class="line">    │  ├─Component 目标代码组成</span><br><span class="line">    │  │      BlockMips.java 目标代码块类</span><br><span class="line">    │  │      FunctionMips.java 目标代码函数类</span><br><span class="line">    │  │      GlobalMips.java 目标代码全局声明类</span><br><span class="line">    │  │      ModuleMips.java 目标代码模块类</span><br><span class="line">    │  │      SymbolMips.java 目标代码符号类</span><br><span class="line">    │  └─Instruction 目标代码指令</span><br><span class="line">    │      │  InstrMips.java 目标代码指令类</span><br><span class="line">    │      ├─address 地址类指令</span><br><span class="line">    │      │      LwMips.java 加载字类</span><br><span class="line">    │      │      SwMips.java 存储字类</span><br><span class="line">    │      ├─assign 赋值类指令</span><br><span class="line">    │      │      LaMips.java 赋地址值类</span><br><span class="line">    │      │      LiMips.java 赋数值类</span><br><span class="line">    │      │      MfloMips.java 读lo寄存器值类</span><br><span class="line">    │      │      MfhiMips.java 读hi寄存器值类</span><br><span class="line">    │      │      MoveMips.java 赋寄存器值类</span><br><span class="line">    │      ├─binary 二元计算指令</span><br><span class="line">    │      │      AddiuMips.java 带立即数的无符号加法类</span><br><span class="line">    │      │      AdduMips.java 二元无符号加法类</span><br><span class="line">    │      │      SubuMips.java 二元无符号减法类</span><br><span class="line">    │      │      MultMips.java 二元有符号乘法类</span><br><span class="line">    │      │      DivMips.java 二元有符号除法类</span><br><span class="line">    │      │      SltMips.java 二元有符号比较类</span><br><span class="line">    │      ├─bitcalculate 位运算指令</span><br><span class="line">    │      │      AndIMips.java 带立即数的与运算类</span><br><span class="line">    │      │      SllMips.java 逻辑左移类</span><br><span class="line">    │      │      SraMips.java 算术右移类</span><br><span class="line">    │      │      SrlMips.java 逻辑右移类</span><br><span class="line">    │      ├─jump 跳转指令</span><br><span class="line">    │      │      BeqMips.java 相等时跳转立即数地址类</span><br><span class="line">    │      │      BneMips.java 不等时跳转立即数地址类</span><br><span class="line">    │      │      BgezMips.java 大于等于0时跳转立即数地址类</span><br><span class="line">    │      │      BlezMips.java 小于等于0时跳转立即数地址类</span><br><span class="line">    │      │      BgtzMips.java 大于0时跳转立即数地址类</span><br><span class="line">    │      │      BltzMips.java 小于0时跳转立即数地址类</span><br><span class="line">    │      │      JalMips.java 跳转立即数地址并链接类</span><br><span class="line">    │      │      JMips.java 跳转立即数地址类</span><br><span class="line">    │      │      JrMips.java 跳转寄存器地址类</span><br><span class="line">    │      └─system 系统指令</span><br><span class="line">    │              SyscallMips.java 系统调用类</span><br><span class="line">    └─Register 寄存器</span><br><span class="line">            Register.java 寄存器类</span><br><span class="line">            RegisterTable.java 寄存器表类</span><br></pre></td></tr></table></figure>
<p><code>CompilerError</code> 的文件组织如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CompileError.java 编译错误类</span><br><span class="line">   Judgement.java 错误处理类</span><br></pre></td></tr></table></figure>
<p><code>IO</code> 的文件组织如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Printer.java 输出解析类</span><br><span class="line">   Reader.java 输入解析类</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="词法分析设计"><a href="#词法分析设计" class="headerlink" title="词法分析设计"></a>词法分析设计</h2><p>源程序读入后作为长字符串存储在编译器中。词法分析部分的主要任务是将源程序字符串转化为单词。</p>
<p>首先应该建立单词类 <code>Token</code> 。在单词中，应当包含该单词种类、所在行、单词内容。因此设计单词类 <code>Token</code> ，其中包含属性 <code>token</code>、<code>lineNum</code>、<code>type</code>，用于存储必要信息。</p>
<p>在词法分析器 <code>Lexer</code> 中，读入源程序字符串，目标是生成单词列表。其中，部分单词是保留词，需要设置为相应类型。为防止无法分别标识符和部分保留词，首先应建立保留词表，以便分析出新单词后正确判断其类型。开始分析后，可以按照以下分类分析字符串：</p>
<ul>
<li>当前字符是数字：那么下一个单词是数字常量。继续读入字符，直至该字符不是数字为止。该段字符串即是下一个单词，该单词的单词内容即是该段字符串，该单词的类型是 <code>INTCON</code> 。</li>
<li>当前字符是 <code>\&quot;</code> 或 <code>\&#39;</code> ：那么下一个单词是字符串常量或者字符常量。继续读入字符，直至该字符不是对应的 <code>&quot;</code> 或 <code>&#39;</code> 为止。应注意，在读入字符时，有可能出现转义字符 <code>\&quot;</code> 或 <code>\&#39;</code> ，需要进行特殊判断（当前字符是 <code>\</code> 时下一个字符是否是 <code>&quot;</code> 或 <code>&#39;</code> ），不能作为字符或字符串结束标志。该段字符串即是下一个单词，该单词的单词内容即是该段字符串，该单词的类型是 <code>STRCON</code> 或 <code>CHRCON</code> 。</li>
<li>当前字符是字母或 <code>_</code> ：那么下一个单词是标识符或保留字。继续读入字符，直至该字符不是字母、数字或 <code>_</code> 。将该段字符串内容和保留词表比对，判断是否是保留词以及是什么类型的保留词。该段字符串即是下一个单词，该单词的单词内容即是该段字符串，该单词的类型是 <code>IDENFR</code> 或相应的保留词类型。</li>
<li>当前字符是 <code>+-*%;,()[]&#123;&#125;</code> ：那么下一个单词是保留词。这些字符是保证只能单独出现的保留词，因此直接将该字符与保留词表比对，判断是什么类型的保留词。</li>
<li>当前字符是 <code>!=&gt;&lt;</code> ：那么下一个单词是保留词。这些字符可能组合出现，产生不同于当前字符含义的保留词。继续读入字符，直至该字符不是这些字符。将该段字符串内容和保留词表比对，判断是什么类型保留词。</li>
<li>当前字符是 <code>&amp;|</code> ：那么下一个单词是保留词。由于该字符可能出现错误，因此单列出来考虑。继续读入字符，若该字符与当前字符不同，词法分析部分出现错误；若相同则与保留词表比对，判断是什么类型保留词。该单词的类型是 <code>AND</code> 或 <code>OR</code> 。</li>
<li>当前字符是 <code>/</code> ：那么接下来可能是保留词 <code>/</code> 或注释 <code>//</code> 、 <code>/**/</code> 。读入下一个字符，若该字符是 <code>/</code> 或 <code>*</code> ，那么接下来是注释，若不是，则是保留词 <code>/</code> ，类型为 <code>DIV</code>  。如果这两个字符是 <code>//</code> ，继续读入字符，直至读入 <code>\n</code> ；如果这两个字符是 <code>/*</code> ，继续读入字符，直至读入 <code>*/</code> 。 </li>
<li>当前字符是 <code>\n</code> ：源程序进行了换行，当前行数加一。</li>
<li>当前字符是其他字符：跳过即可。</li>
</ul>
<p>获得单词后，将其存入单词列表 <code>tokens</code> 中，并正确输出结果。</p>
<hr>
<h2 id="语法分析设计"><a href="#语法分析设计" class="headerlink" title="语法分析设计"></a>语法分析设计</h2><p>词法分析部分分析出的单词列表存储在编译器中。语法分析部分的主要任务是按照 <code>SysY</code> 语言文法自顶向下将单词列表转化为语法树。</p>
<p><code>SysY</code> 语言文法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">编译单元 CompUnit → &#123;Decl&#125; &#123;FuncDef&#125; MainFuncDef </span><br><span class="line">声明 Decl → ConstDecl | VarDecl </span><br><span class="line">常量声明 ConstDecl → <span class="string">&#x27;const&#x27;</span> BType ConstDef &#123; <span class="string">&#x27;,&#x27;</span> ConstDef &#125; <span class="string">&#x27;;&#x27;</span></span><br><span class="line">基本类型 BType → <span class="string">&#x27;int&#x27;</span> | <span class="string">&#x27;char&#x27;</span> </span><br><span class="line">常量定义 ConstDef → Ident [ <span class="string">&#x27;[&#x27;</span> ConstExp <span class="string">&#x27;]&#x27;</span> ] <span class="string">&#x27;=&#x27;</span> ConstInitVal</span><br><span class="line">常量初值 ConstInitVal → ConstExp | <span class="string">&#x27;&#123;&#x27;</span> [ ConstExp &#123; <span class="string">&#x27;,&#x27;</span> ConstExp &#125; ] <span class="string">&#x27;&#125;&#x27;</span> | StringConst</span><br><span class="line">变量声明 VarDecl → BType VarDef &#123; <span class="string">&#x27;,&#x27;</span> VarDef &#125; <span class="string">&#x27;;&#x27;</span></span><br><span class="line">变量定义 VarDef → Ident [ <span class="string">&#x27;[&#x27;</span> ConstExp <span class="string">&#x27;]&#x27;</span> ] | Ident [ <span class="string">&#x27;[&#x27;</span> ConstExp <span class="string">&#x27;]&#x27;</span> ] <span class="string">&#x27;=&#x27;</span> InitVal</span><br><span class="line">变量初值 InitVal → Exp | <span class="string">&#x27;&#123;&#x27;</span> [ Exp &#123; <span class="string">&#x27;,&#x27;</span> Exp &#125; ] <span class="string">&#x27;&#125;&#x27;</span> | StringConst </span><br><span class="line">函数定义 FuncDef → FuncType Ident <span class="string">&#x27;(&#x27;</span> [FuncFParams] <span class="string">&#x27;)&#x27;</span> Block</span><br><span class="line">主函数定义 MainFuncDef → <span class="string">&#x27;int&#x27;</span> <span class="string">&#x27;main&#x27;</span> <span class="string">&#x27;(&#x27;</span> <span class="string">&#x27;)&#x27;</span> Block</span><br><span class="line">函数类型 FuncType → <span class="string">&#x27;void&#x27;</span> | <span class="string">&#x27;int&#x27;</span> | <span class="string">&#x27;char&#x27;</span></span><br><span class="line">函数形参表 FuncFParams → FuncFParam &#123; <span class="string">&#x27;,&#x27;</span> FuncFParam &#125; </span><br><span class="line">函数形参 FuncFParam → BType Ident [<span class="string">&#x27;[&#x27;</span> <span class="string">&#x27;]&#x27;</span>]</span><br><span class="line">语句块 Block → <span class="string">&#x27;&#123;&#x27;</span> &#123; BlockItem &#125; <span class="string">&#x27;&#125;&#x27;</span> </span><br><span class="line">语句块项 BlockItem → Decl | Stmt </span><br><span class="line">语句 Stmt → LVal <span class="string">&#x27;=&#x27;</span> Exp <span class="string">&#x27;;&#x27;</span></span><br><span class="line">| [Exp] <span class="string">&#x27;;&#x27;</span></span><br><span class="line">| Block</span><br><span class="line">| <span class="string">&#x27;if&#x27;</span> <span class="string">&#x27;(&#x27;</span> Cond <span class="string">&#x27;)&#x27;</span> Stmt [ <span class="string">&#x27;else&#x27;</span> Stmt ]</span><br><span class="line">| <span class="string">&#x27;for&#x27;</span> <span class="string">&#x27;(&#x27;</span> [ForStmt] <span class="string">&#x27;;&#x27;</span> [Cond] <span class="string">&#x27;;&#x27;</span> [ForStmt] <span class="string">&#x27;)&#x27;</span> Stmt </span><br><span class="line">| <span class="string">&#x27;break&#x27;</span> <span class="string">&#x27;;&#x27;</span> | <span class="string">&#x27;continue&#x27;</span> <span class="string">&#x27;;&#x27;</span></span><br><span class="line">| <span class="string">&#x27;return&#x27;</span> [Exp] <span class="string">&#x27;;&#x27;</span></span><br><span class="line">| LVal <span class="string">&#x27;=&#x27;</span> <span class="string">&#x27;getint&#x27;</span><span class="string">&#x27;(&#x27;</span><span class="string">&#x27;)&#x27;</span><span class="string">&#x27;;&#x27;</span></span><br><span class="line">| LVal <span class="string">&#x27;=&#x27;</span> <span class="string">&#x27;getchar&#x27;</span><span class="string">&#x27;(&#x27;</span><span class="string">&#x27;)&#x27;</span><span class="string">&#x27;;&#x27;</span></span><br><span class="line">| <span class="string">&#x27;printf&#x27;</span><span class="string">&#x27;(&#x27;</span>StringConst &#123;<span class="string">&#x27;,&#x27;</span>Exp&#125;<span class="string">&#x27;)&#x27;</span><span class="string">&#x27;;&#x27;</span></span><br><span class="line">语句 ForStmt → LVal <span class="string">&#x27;=&#x27;</span> Exp </span><br><span class="line">表达式 Exp → AddExp </span><br><span class="line">条件表达式 Cond → LOrExp </span><br><span class="line">左值表达式 LVal → Ident [<span class="string">&#x27;[&#x27;</span> Exp <span class="string">&#x27;]&#x27;</span>]</span><br><span class="line">基本表达式 PrimaryExp → <span class="string">&#x27;(&#x27;</span> Exp <span class="string">&#x27;)&#x27;</span> | LVal | Number | Character</span><br><span class="line">数值 Number → IntConst </span><br><span class="line">字符 Character → CharConst </span><br><span class="line">一元表达式 UnaryExp → PrimaryExp | Ident <span class="string">&#x27;(&#x27;</span> [FuncRParams] <span class="string">&#x27;)&#x27;</span> | UnaryOp UnaryExp </span><br><span class="line">单目运算符 UnaryOp → <span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;−&#x27;</span> | <span class="string">&#x27;!&#x27;</span> 注：<span class="string">&#x27;!&#x27;</span>仅出现在条件表达式中 </span><br><span class="line">函数实参表 FuncRParams → Exp &#123; <span class="string">&#x27;,&#x27;</span> Exp &#125; </span><br><span class="line">乘除模表达式 MulExp → UnaryExp | MulExp (<span class="string">&#x27;*&#x27;</span> | <span class="string">&#x27;/&#x27;</span> | <span class="string">&#x27;%&#x27;</span>) UnaryExp </span><br><span class="line">加减表达式 AddExp → MulExp | AddExp (<span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;−&#x27;</span>) MulExp </span><br><span class="line">关系表达式 RelExp → AddExp | RelExp (<span class="string">&#x27;&lt;&#x27;</span> | <span class="string">&#x27;&gt;&#x27;</span> | <span class="string">&#x27;&lt;=&#x27;</span> | <span class="string">&#x27;&gt;=&#x27;</span>) AddExp </span><br><span class="line">相等性表达式 EqExp → RelExp | EqExp (<span class="string">&#x27;==&#x27;</span> | <span class="string">&#x27;!=&#x27;</span>) RelExp </span><br><span class="line">逻辑与表达式 LAndExp → EqExp | LAndExp <span class="string">&#x27;&amp;&amp;&#x27;</span> EqExp</span><br><span class="line">逻辑或表达式 LOrExp → LAndExp | LOrExp <span class="string">&#x27;||&#x27;</span> LAndExp</span><br><span class="line">常量表达式 ConstExp → AddExp 注：使用的 Ident 必须是常量</span><br></pre></td></tr></table></figure>
<p>首先应该建立语法成分接口 <code>Syntax</code> 。后续建立语法树 <code>AST</code> 时所有节点都应该实现 <code>Syntax</code> 接口，以保证统一性。对于每一个语法成分，都应建立一个类，存储它作为语法树节点所有的子节点。</p>
<p>在语法分析器 <code>Parser</code> 中，读入单词列表，目标是生成语法树。按照 <code>SysY</code> 语言文法，自顶向下为每个节点类建立分析函数。同时为了不进行回溯，应在每个分析函数开始部分建立是否为当前语法成分的判断部分（判断首单词是否符合当前推导规则）：</p>
<ul>
<li><code>CompUnit</code> ：语法树的最顶层节点，代表整个待编译程序。其子节点可能为 <code>Decl</code> 、 <code>FuncDef</code> 、 <code>MainFuncDef</code> ，其中，前两部分可能存在若干次，因此使用 <code>for</code>  循环进行解析，直至无法解析出 <code>Decl</code> 或 <code>FuncDef</code> 。对于第三部分  <code>MainFuncDef</code> ，直接解析即可。</li>
<li><code>Decl</code> ：代表声明部分，分为常量声明 <code>ConstDecl</code> 和变量声明 <code>VarDecl</code> 。先假定为常量声明进行解析，若返回值为空，按照变量声明解析即可。</li>
<li><code>FuncDef</code> ：代表普通函数（非主函数）声明部分。当需要解析函数时，首先应该判断是否符合函数定义格式以及是否是主函数。对于函数定义，最大的特征标识是函数名标识符 <code>Ident</code> 后的小括号 <code>(</code> ，如果成立则可以判定为函数。对于是否是主函数的判定，只需要判定函数名标识符 <code>Ident</code> 是否是 <code>main</code> 即可。判定确实为普通函数后，存储该函数的函数类型 <code>FuncType</code> 、函数名标识符 <code>Ident</code> ，并对标识符后的函数形参进行解析及存储（存储形参个数、形参名、形参类型等）。之后对函数主体的块 <code>Block</code> 进行解析即可完成整个函数的解析。</li>
<li><code>MainFuncDef</code> ：代表主函数声明部分。其大体流程与普通函数声明部分相似：判断是否符合函数定义格式以及是否是主函数。对于函数定义，最大的特征标识是函数名标识符 <code>Ident</code> 后的括号 <code>(</code> ，如果成立则可以判定为函数。对于是否是主函数的判定，只需要判定函数名标识符 <code>Ident</code> 是否是 <code>main</code> 即可。需注意，二者都必须进行，否则可能出现被命名为 <code>main</code> 的变量被判定为主函数而导致的解析错误。判定为主函数后，存储相应函数信息，不需要对函数形参进行解析，直接对函数主体的块 <code>Block</code> 进行解析即可完成整个主函数的解析。</li>
<li><code>Block</code> ：代表由大括号包覆的块。其内部含有若干各块组成 <code>BlockItem</code> ，因此使用 <code>for</code>  循环进行解析，直至无法解析出 <code>BlockItem</code> （实际上是到达块的后一个大括号 <code>&#125;</code> ）。最后，将块的后一个大括号 <code>&#125;</code> 解析即可。</li>
<li><code>ConstDecl</code> ：代表常量声明部分。首先应通过当前单词是否是 <code>const</code> 判断是否是常量定义，若不是常量定义则返回空值。如果是常量定义，则存储之后定义的常量的数据类型 <code>BType</code> 。由于一句常量声明中可以存在多条常量定义语句，因此使用 <code>for</code>  循环进行解析，直至无法解析出 <code>ConstDef</code> 。</li>
<li><code>VarDecl</code> ：代表变量声明部分。首先应当判定是否是变量定义：当前单词应该是变量的数据类型 <code>BType</code> ，且不应该出现 <code>BType Ident (</code> 的情况。如果是变量定义，则存储之后定义的变量的数据类型 <code>BType</code> 。由于一句变量声明中可以存在多条变量定义语句，因此使用 <code>for</code>  循环进行解析，直至无法解析出 <code>VarDef</code> 。</li>
<li><code>ConstDef</code> ：代表常量定义部分。首先需要判断是否是常量定义，由于 <code>ConstDef</code> 只能从 <code>ConstDecl</code> 获得，因此只需要通过是否存在定义常量标识符 <code>Ident</code> 判定是否是定义语句即可。如果是常量定义，则存储当前常量标识符 <code>Ident</code> 。该标识符所代表常量可能是常量数组，需要通过标识符后是否是中括号 <code>[</code> 来判断。如果该常量是常量数组，则需要对中括号 <code>[</code> 后的常量表达式 <code>ConstExp</code> 进行解析，以获得该数组的元素个数。如果不是常量数组，正常进行后续操作即可。对于常量定义部分，还需要解析为定义常量所赋的初值。对等号 <code>=</code> 后的常量表达式 <code>ConstExp</code> 进行解析并存储即可。</li>
<li><code>VarDef</code> ：代表变量定义部分。首先需要判断是否是变量定义，由于 <code>VarDef</code> 只能从 <code>VarDecl</code> 获得，因此只需要通过是否存在定义变量标识符 <code>Ident</code> 判定是否是定义语句即可。如果是变量定义，则存储当前变量标识符 <code>Ident</code> 。该标识符所代表变量可能是变量数组，需要通过标识符后是否是中括号 <code>[</code> 来判断。如果该变量是变量数组，则需要对中括号 <code>[</code> 后的变量表达式 <code>VarExp</code> 进行解析，以获得该数组的元素个数。如果不是变量数组，正常进行后续操作即可。对于变量定义部分，还需要判定是否存在为定义变量赋初值的情况，通过标识符 <code>Ident</code> 或中括号 <code>]</code> 后是否存在等号 <code>=</code> 来判断。如果存在，解析为定义变量所赋的初值。对等号 <code>=</code> 后的普通表达式 <code>Exp</code> 进行解析并存储即可。</li>
<li><code>ConstInitVal</code> ：代表常量定义时的初值，可能为字符串常量，常量数组元素集合，常量表达式。对于字符串常量，直接存储即可。对于数组元素集合，通过大括号 <code>&#123;</code> 来判定，如果是则解析后续出现的若干常量表达式即可；对于常量表达式，直接解析即可。</li>
<li><code>InitVal</code> ：代表变量定义时的初值，可能为字符串常量，变量数组元素集合，普通表达式。对于字符串常量，直接存储即可。对于数组元素集合，通过大括号 <code>&#123;</code> 来判定，如果是则解析后续出现的若干普通表达式即可；对于普通表达式，直接解析即可。</li>
<li><code>FuncFParams</code> ：代表函数形参声明部分。函数形参声明可能有若干形参，因此使用 <code>for</code>  循环进行解析，直至无法解析出  <code>FuncFParam</code> 为止。根据解析出的形参个数，判定是否存在函数形参声明部分。即如果解析出的形参个数为0，则不存在函数形参部分。</li>
<li><code>FuncFParam</code> ：代表每个函数形参的定义部分。对于每个函数形参的定义，存储该形参的数据类型 <code>BType</code> 和形参标识符 <code>Ident</code> 。部分形参可能是数组（实际上是有着数组形式的指针），识别标识符后的中括号 <code>[]</code> ，并将类型存储。</li>
<li><code>BlockItem</code> ：代表每个块组成。其可能是声明 <code>Decl</code> 或语句 <code>Stmt</code> 。先假定为声明进行解析，若返回值为空，按照语句解析即可。</li>
<li><code>Stmt</code> ：代表块中可能出现的语句，推导规则比较复杂，大体可以分为三类：赋值型，特殊功能型，块或表达式。对于赋值型，即 <code>LVal &#39;=&#39; Exp &#39;;&#39;</code> , <code>LVal &#39;=&#39; &#39;getint&#39;&#39;(&#39;&#39;)&#39;&#39;;&#39;</code> , <code>LVal &#39;=&#39; &#39;getchar&#39;&#39;(&#39;&#39;)&#39;&#39;;&#39;</code> ，需要通过等号 <code>=</code> 来判定，如果是赋值型，直接存储即可；如果不是赋值型，此时已经对左值表达式 <code>LVal</code> 进行了解析，需要进行回溯，因此在解析前应保留解析位置，以便后期回溯。对于特殊型，可以直接通过关键词判断类型： <code>&#39;if&#39; &#39;(&#39; Cond &#39;)&#39; Stmt [ &#39;else&#39; Stmt ]</code> 可以通过 <code>if</code> 判定，并解析 <code>if</code> 的条件 <code>Cond</code> 和需要执行的语句 <code>Stmt</code> ，如果存在 <code>else</code> ，则额外解析 <code>else</code> 需要执行的语句 <code>Stmt</code> ； <code>&#39;for&#39; &#39;(&#39; [ForStmt] &#39;;&#39; [Cond] &#39;;&#39; [ForStmt] &#39;)&#39; Stmt</code> 可以通过 <code>for</code> 判定，并解析 <code>for</code> 的条件 <code>Cond</code> 和两个 <code>for</code> 语句 <code>ForStmt</code> （如果存在的话），以及需要执行的语句 <code>Stmt</code> ；<code>&#39;;&#39;</code> 、 <code>&#39;break&#39; &#39;;&#39;</code> 和 <code>&#39;continue&#39; &#39;;&#39;</code> 语句中全部是保留词，直接解析即可； <code>&#39;return&#39; [Exp] &#39;;&#39;</code> 可以通过 <code>return</code> 判定，并解析之后可能出现的表达式 <code>Exp</code> ；<code>&#39;printf&#39;&#39;(&#39;StringConst &#123;&#39;,&#39;Exp&#125;&#39;)&#39;&#39;;&#39;</code> 可以通过 <code>printf</code> 判定，存储保留词和字符串常量，并解析之后可能出现的若干表达式 <code>Exp</code> 。对于块或表达式，在排除上述所有情况后，直接解析即可，不会再出现需要回溯的情况。</li>
<li><code>ForStmt</code> ：代表 <code>for</code> 语句，只可能出现左值表达式的赋值。因此解析被赋值的左值表达式 <code>LVal</code> 和待赋值的普通表达式 <code>Exp</code> 即可。需注意，判定是 <code>ForStmt</code> 的标识是赋值的等号 <code>=</code> ，此时已经对左值表达式 <code>LVal</code> 进行了解析，如果不是 <code>ForStmt</code> 则需要进行回溯，因此在解析前应保留解析位置，以便后期回溯。</li>
<li><code>Cond</code> ：代表各类语句的条件，只能是逻辑表达式，按照文法，只能是逻辑或表达式 <code>LOrExp</code> 。因此，直接按照逻辑或表达式 <code>LOrExp</code> 对其解析即可。</li>
<li><code>LOrExp</code> ：代表逻辑或表达式，由逻辑或表达式 <code>LOrExp</code> 、逻辑或符号 <code>||</code> 、逻辑与表达式 <code>LAndExp</code> 组成。由于该文法是左递归文法，如果直接解析会出现无限下降的问题。因此，改写文法，先解析逻辑与表达式 <code>LAndExp</code> ，如果存在逻辑或符号 <code>||</code> ，则将其种类变换为逻辑或表达式 <code>LOrExp</code> ，并按照上述方法继续进行。</li>
<li><code>LAndExp</code> ：代表逻辑与表达式，由逻辑与表达式 <code>LAndExp</code> 、逻辑与符号 <code>&amp;&amp;</code> 、相等性表达式 <code>EqExp</code> 组成。由于该文法是左递归文法，因此，按照 <code>LOrExp</code> 中相似的方法进行解析。</li>
<li><code>EqExp</code> ：代表相等性表达式，由相等性表达式 <code>EqExp</code> 、相等性符号 <code>==</code> 或 <code>!=</code> 、关系表达式 <code>RelExp</code> 组成。由于该文法是左递归文法，因此，按照 <code>LOrExp</code> 中相似的方法进行解析。</li>
<li><code>RelExp</code> ：代表关系表达式，由关系表达式 <code>RelExp</code> 、关系符号 <code>&gt;</code> 或 <code>&lt;</code> 或<code>&gt;=</code> 或 <code>&lt;=</code> 、加减表达式 <code>AddExp</code> 组成。由于该文法是左递归文法，因此，按照 <code>LOrExp</code> 中相似的方法进行解析。</li>
<li><code>ConstExp</code> ：代表常量表达式，只能是加减表达式。因此，直接按照加减表达式 <code>AddExp</code> 对其解析即可。同时应指出，由文法规定，常量表达式中出现的全部标识符必须是常量。</li>
<li><code>Exp</code> ：代表普通表达式，只能是加减表达式。因此，直接按照加减表达式 <code>AddExp</code> 对其解析即可。</li>
<li><code>AddExp</code> ：代表关系表达式，由加减表达式 <code>AddExp</code> 、加减符号 <code>+</code> 或 <code>-</code> 、乘除表达式 <code>MulExp</code> 组成。由于该文法是左递归文法，因此，按照 <code>LOrExp</code> 中相似的方法进行解析。</li>
<li><code>MulExp</code> ：代表乘除表达式，由乘除表达式 <code>MulExp</code> 、乘除符号 <code>*</code> 或 <code>/</code> 或 <code>%</code> 、一元表达式 <code>UnaryExp</code> 组成。由于该文法是左递归文法，因此，按照 <code>LOrExp</code> 中相似的方法进行解析。</li>
<li><code>UnaryExp</code> ：代表一元表达式，可能是带一元符号的一元表达式，基本表达式或函数调用。对于带一元符号的一元表达式，通过医院符号进行判定，若是则解析一元表达式 <code>UnaryExp</code> 即可。对于函数调用，通过标识符后的小括号 <code>(</code> 判定，若是函数调用，则对括号内进行函数实参 <code>FuncRParams</code> 解析。排除函数调用的情况后，一定是基本表达式，对基本表达式 <code>PrimaryExp</code> 进行解析即可。</li>
<li><code>FuncRParams</code> ：代表函数实参。其由若干普通表达式组成，因此使用 <code>for</code>  循环进行解析，直至无法解析出  <code>Exp</code> 为止。</li>
<li><code>PrimaryExp</code> ：代表基本表达式。可能是 <code>int</code> 型常量、 <code>char</code> 型常量、带小括号的普通表达式或左值表达式 <code>LVal</code> 。对于 <code>int</code> 型常量、 <code>char</code> 型常量，按照数据类型直接解析存储即可。对于带小括号的普通表达式，通过小括号 <code>(</code> 判定，若是则对后续普通表达式解析即可。对于左值表达式 <code>LVal</code> ，直接解析即可。</li>
<li><code>LVal</code> ：代表左值表达式，主要是标识符（普通变量常量标识符，变量常量数组标识符，带偏移的变量常量数组标识符）。对于不带偏移的标识符（即不存在 <code>[Exp]</code> ），直接当作标识符 <code>Ident</code> 处理即可。对于带偏移的变量常量数组标识符，在存储标识符的同时也需要对偏移量表达式解析存储。</li>
</ul>
<p>对于每一种实现 <code>Syntax</code> 的语法节点，其应有属性 <code>syntaxes</code> ，表示其含有的全部子节点。获得语法树 <code>AST</code> 各节点后，将其存入父节点的 <code>syntaxes</code> 中，并设置函数，使其可以正确输出必要信息。</p>
<hr>
<h2 id="语义分析设计"><a href="#语义分析设计" class="headerlink" title="语义分析设计"></a>语义分析设计</h2><p>语法分析部分分析出的语法树 <code>AST</code> 会存储在编译器中。语义分析部分的主要任务是解析出现的标识符（函数标识符，常量标识符，变量标识符），构建符号表，以便后续代码生成时方便查阅。</p>
<p>对于各类符号，在不同域定义的标识使用范围不同：在外层定义的标识可以在内层使用，而在内层定义的标识不可以在外层使用。相同层不同域定义的标识不可以互相使用。因此，需要建立一种双向树结构，每个节点代表每个符号表项，相同层节点代表相同层的符号表项。建立符号表项类 <code>Table</code> ，其属性有符号表项序号 <code>id</code> ，符号表项的父符号表项 <code>father</code> ，符号表项所处的层数 <code>floor</code> ，符号表项内存储的符号 <code>symbols</code> 。这样在查找符号时，从当前表项出发，从底向上逐层遍历，直至获得当前符号：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Symbol <span class="title function_">searchDefinition</span><span class="params">(String symbolName)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Symbol symbol : symbols) &#123;</span><br><span class="line">        <span class="keyword">if</span> (symbol.getName().equals(symbolName)) <span class="keyword">return</span> symbol;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (father != <span class="literal">null</span>) <span class="keyword">return</span> father.searchDefinition(symbolName);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要储存的符号有函数，变量，常量，变量数组以及常量数组。每种符号都有其类型和要储存的属性，应该建立类，规定相应属性：</p>
<ul>
<li><code>Symbol</code> ：总的符号类，其他符号类的父类，存储有各类符号的基本信息。包括符号序号 <code>id</code> ，符号所在的符号表项 <code>table</code> ，符号名 <code>name</code> ， 符号对应的单词 <code>token</code> ，符号类型 <code>type</code> （可能为 <code>&quot;intVar&quot;</code> 、 <code>&quot;charVar&quot;</code> 、 <code>&quot;intArray&quot;</code> 、 <code>&quot;charArray&quot;</code> 、 <code>&quot;intFunc&quot;</code> 、 <code>&quot;charFunc&quot;</code> 、 <code>&quot;voidFunc&quot;</code> ）。对于每个属性，建立 <code>set</code> 和 <code>get</code> 方法，并设置函数，使其可以正确输出必要信息。</li>
<li><code>VarSymbol</code> ：变量常量符号类，继承 <code>Symbol</code> 。除去 <code>Symbol</code> 中存储的信息，还应额外存储符号数据类型 <code>bType</code> ，符号是否代表常量 <code>con</code> 。在创建该类时，应给出全部必要信息。</li>
<li><code>ArraySymbol</code> ：变量常量数组符号类，继承 <code>Symbol</code> 。除去 <code>Symbol</code> 中存储的信息，还应额外存储符号数据类型 <code>bType</code> ，符号是否代表常量 <code>con</code> ，数组维度 <code>dim</code> （应指出 <code>SysY</code> 语言规定数组为一维）。在创建该类时，应给出全部必要信息。</li>
<li><code>FuncSymbol</code> ：函数符号类，继承 <code>Symbol</code> 。除去 <code>Symbol</code> 中存储的信息，还应额外存储函数数据类型 <code>funcType</code> ，函数的形参个数 <code>paramNum</code> ，函数各形参的类型 <code>paramTypes</code> （可能为 <code>&quot;intVar&quot;</code> 、 <code>&quot;charVar&quot;</code> 、 <code>&quot;intArray&quot;</code> 、 <code>&quot;charArray&quot;</code> ）。在创建该类时，应给出全部必要信息。</li>
</ul>
<p>完成必需类准备后，可以进行符号的解析与符号表的构建。在语义分析器（符号管理器） <code>Manager</code> 中，读入并遍历语法树 <code>AST</code> ，解析各语法成分，获得新出现的符号，存入相应的符号表项。在遍历过程中，由于函数、块等的存在，符号会出现不同的定义与使用域，因此在遍历过程中，需要注意和维护当前符号所在层数，在层数改变时改变当前符号表（层数增加时新建符号表项，层数减少时转移至当前表项的父符号表项，如不存在则报错）。由于层数改变出现较为频繁，因此封装函数 <code>createTable()</code> 和 <code>quitTable()</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createTable</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Table</span> <span class="variable">father</span> <span class="operator">=</span> nowTable;</span><br><span class="line">    curFloor++;</span><br><span class="line">    curSerial = tables.size(); <span class="comment">// 当前符号表序号</span></span><br><span class="line">    curIndex = <span class="number">0</span>; <span class="comment">// 当前符号表中当前符号序号</span></span><br><span class="line">    nowTable = <span class="keyword">new</span> <span class="title class_">Table</span>(curSerial, father.getId(), father, curFloor);</span><br><span class="line">    tables.add(nowTable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quitTable</span><span class="params">()</span> &#123;</span><br><span class="line">    curFloor--;</span><br><span class="line">    curSerial = nowTable.getFather().getId();</span><br><span class="line">    curIndex = nowTable.getFather().getSize();</span><br><span class="line">    nowTable = nowTable.getFather();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会发生符号表变更的位置是（主）函数定义，带块的 <code>if</code> 和 <code>for</code> ，普通的块。应指出，虽然这几个位置产生表的变化都是因为块，但不可将符号表项的变更放在块的解析中。这是因为函数定义中可能出现形参，需要存入新符号表项中，因此应该具体问题具体分析。对于不带块的 <code>if</code> 和 <code>for</code> ，根据文法，其后只能是 <code>[Exp] &#39;;&#39;</code> ，不能出现新的声明 <code>Decl</code> ，因此不新建符号表。这些符号表项变化主要出现在 <code>MainFuncDef</code> 、 <code>FuncDef</code> 和 <code>Stmt</code> 中。</p>
<ul>
<li><code>MainFuncDef</code> ：主函数内的符号表变化，不含形参。主要是在主函数的块内，因此在进入块前调用 <code>createTable()</code> ，完成块的解析并退出块后调用 <code>quitTable()</code> 。</li>
<li><code>FuncDef</code> ：普通函数内的符号表变化，不含形参。主要是在普通函数的形参声明以及块内，因此在函数进行形参声明前调用 <code>createTable()</code> ，完成块的解析并退出块后调用 <code>quitTable()</code> 。</li>
<li><code>Stmt</code> ：主要是带块的 <code>if</code> 、 <code>for</code> 和 普通的块。在这里，可以进行合并，统一在 <code>Stmt → Block</code> 的过程中进行。在进入块前调用 <code>createTable()</code> ，完成块的解析并退出块后调用 <code>quitTable()</code> 。</li>
</ul>
<p>对于三种符号 <code>FuncSymbol</code> 、 <code>VarSymbol</code> 、 <code>ArraySymbol</code> ，第一种主要在函数定义中出现（ <code>main</code> 函数可以直接获得符号，无需特殊说明），后两种主要在变量常量定义，函数形参解析中出现。</p>
<ul>
<li><code>FuncDef</code> ：根据解析的语法成分，获得函数标识符并建立 <code>FuncSymbol</code> 存储在当前符号表项中。</li>
<li><code>ConstDef</code> / <code>VarDef</code> ：根据解析的语法成分（标识符和数据类型），建立  <code>VarSymbol</code> 或 <code>ArraySymbol</code> 存储在当前符号表项中。</li>
<li><code>FuncFParam</code> ：建立符号的方法基本与 <code>ConstDef</code> / <code>VarDef</code> 相同，建立  <code>VarSymbol</code> 或 <code>ArraySymbol</code> 存储在当前符号表项中。</li>
</ul>
<hr>
<h2 id="错误处理设计"><a href="#错误处理设计" class="headerlink" title="错误处理设计"></a>错误处理设计</h2><p>按照文法设计与实验安排，本次实验中总共有 $13$ 种错误，其中 <code>a</code> 类错误会出现在词法分析部分，<code>i</code> 、 <code>j</code> 、 <code>k</code> 类错误会出现在语法分析部分，其余错误会出现在语义分析部分。同时，为了统一性和复用性，在实验中建立了错误判定器类 <code>Judgement</code> ，判断每类错误时输入必要信息，获得判断结果。同时 <code>Judgement</code> 内含属性 <code>errors</code> ，存储分析过程中抛出的全部错误。现对每种错误进行分析：</p>
<ul>
<li><code>a</code> 类错误：非法符号 <code>&amp;</code> 和 <code>|</code> ，应该将其当做 <code>&amp;&amp;</code> 与 <code>||</code> 进行处理，并在记录单词名称的时候正确记录。这个错误主要在词法分析对 <code>&amp;|</code> 的分析中出现，判断当前字符与下一个字符是否相同即可。由于出现在词法分析部分，为了错误检测的正常运行（以检测出全部错误），按照出现的第一个字符添加或更改字符，将其作为正确单词存入。判断函数输入的必要信息是当前字符、下一个字符以及当前字符所在行数。</li>
<li><code>b</code> 类错误：符号名在当前域下重复定义。应指出，变量在同一级域下重定义会判定错误，不同级作用域下，内层会覆盖外层定义。这个错误主要出现在语义分析符号定义阶段。将当前符号放入当前符号表项搜索，判断是否出现相同名字的符号。判断函数输入的必要信息是当前符号以及当前符号表项。</li>
<li><code>c</code> 类错误：使用未定义的标识符。使用当前符号表项或其父符号表项中不含有的的符号，主要出现在语义分析的语句和表达式的解析中。将当前符号在当前符号表以及父符号表等递归搜索，判断是否出现相同名字的符号。判断函数输入的必要信息是当前标识符单词以及当前符号表项。</li>
<li><code>d</code> 类错误：函数的形参和实参个数不匹配。主要出现在语义分析的函数调用阶段。在函数定义阶段，有对函数的形参进行存储。在调用阶段（ <code>UnaryExp</code> 的解析阶段），以 <code>,</code> 作为分隔符解析函数实参，存储实参的个数。比较形参数组的大小和实参个数即可。判断函数输入的必要信息是当前函数的符号以及实参个数。</li>
<li><code>e</code> 类错误：函数的形参和实参类型不匹配。主要出现在语义分析的函数调用阶段。在函数定义阶段，有对函数的形参进行存储。在调用阶段（ <code>UnaryExp</code> 的解析阶段），以 <code>,</code> 作为分隔符解析函数实参，存储各实参的类型。比较各形参和各实参的类型是否匹配即可。应注意，类型匹配过程中，普通变量常量允许出现数据转换，即 <code>intVar</code> 和 <code>charVar</code> 可以认为是匹配的。其余类型必须完全匹配才可。判断函数输入的必要信息是当前函数的符号以及实参类型数组。</li>
<li><code>f</code> 类错误： <code>void</code> 类型的函数存在不匹配的 <code>return</code> 语句。 <code>void</code> 类型函数如果存在返回语句，返回语句后一定不能出现 <code>Exp</code> 。主要出现在语义分析的语句分析阶段。在语句分析的过程中，如果出现 <code>return</code> ，应解析其后单词，判断是否出现 <code>Exp</code> 。判断函数输入的必要信息是当前函数符号，当前 <code>return</code> 所在行数以及当前 <code>return</code> 是否存在返回值。</li>
<li><code>g</code> 类错误： <code>int</code> 或 <code>char</code> 类型的函数在函数末尾不存在 <code>return</code> 语句。为简化问题，实验规定， <code>int</code> 或 <code>char</code> 类型的函数在函数末尾必须存在 <code>return</code> 语句，即使在 <code>if-else</code> 控制流语句中出现也不能省略。主要出现在语义分析的函数定义阶段。在控制流外，如果出现 <code>return</code> 语句，则存储该语句所在域层数 <code>returnFloor</code> （这表明该变量一定保留的是最后一个 <code>return</code> 语句所在的层数，该变量初始化为 $-1$ ）；如果 <code>returnFloor</code> 的值不等于 <code>funcFloor + 1</code> （为 $-1$ 时证明不存在 <code>return</code> 语句，大于 <code>funcFloor + 1</code> 时证明该 <code>return</code> 语句在控制流内），则证明其存在该类错误。判断函数输入的必要信息是函数符号，最后一个 <code>return</code> 语句所在的层数以及函数块 <code>&#125;</code> 的行号。</li>
<li><code>h</code> 类错误：尝试修改常量的值。主要出现在语义分析的语句和表达式的解析中。在构建语法树时，对于标识符，有属性 <code>con</code> 判断其是否是常量。因此，在赋值时根据该属性判断是否存在错误即可。判断函数输入的必要信息是常量符号以及是否是对该常量赋值。</li>
<li><code>i</code> 类错误：缺少必要的 <code>;</code> 。这个错误主要出现在语法分析部分，在构建语法树的过程中按照正确文法检测相应位置是否存在 <code>;</code> 即可。由于出现在语法分析部分，为了错误检测的正常运行（以检测出全部错误），添加缺少的 <code>;</code> ，以保证当前语法成分的正确性。判断函数输入的必要信息是当前字符、上一个字符所在行数。</li>
<li><code>j</code> 类错误：缺少必要的 <code>)</code> 。这个错误主要出现在语法分析部分，在构建语法树的过程中按照正确文法检测相应位置是否存在 <code>)</code> 即可。由于出现在语法分析部分，为了错误检测的正常运行（以检测出全部错误），添加缺少的 <code>)</code> ，以保证当前语法成分的正确性。判断函数输入的必要信息是当前字符、上一个字符所在行数。</li>
<li><code>k</code> 类错误：缺少必要的 <code>]</code> 。这个错误主要出现在语法分析部分，在构建语法树的过程中按照正确文法检测相应位置是否存在 <code>]</code> 即可。由于出现在语法分析部分，为了错误检测的正常运行（以检测出全部错误），添加缺少的 <code>]</code> ，以保证当前语法成分的正确性。判断函数输入的必要信息是当前字符、上一个字符所在行数。</li>
<li><code>l</code> 类错误： <code>printf</code> 字符串中格式字符数量与表达式个数不匹配。文法规定  <code>printf</code> 函数中可以出现格式字符 <code>%d</code> / <code>%c</code> ，用于输出 <code>int</code> 或 <code>char</code> 类型的算式。该类错误即是格式字符 <code>%d</code> / <code>%c</code> 与要输出的表达式的数量不同。 主要出现在语义分析的语句 <code>printf</code> 的解析中。在 <code>printf</code> 语句解析时，使用正则表达式，获得输出字符串中格式字符的匹配数量，并与解析的表达式个数进行比较。判断函数输入的必要信息是输出字符串以及表达式数量。</li>
<li><code>m</code> 类错误：在非循环块中使用 <code>break</code> 和 <code>continue</code> 语句。主要出现在语义分析的语句 <code>break</code> 和 <code>continue</code> 的解析中。要判断当前语句是否位于循环块中，需要动态维护循环层数 <code>forFloor</code> 。该属性初值为 $0$ ，仅在进入循环时增加，在退出循环时减少。解析 <code>break</code> / <code>continue</code> 语句时，只需要判断循环层数 <code>forFloor</code> 是否大于 $0$ 即可。 判断函数输入的必要信息是<code>break</code> / <code>continue</code> 语句的行号以及循环层数 <code>forFloor</code> 。</li>
</ul>
<p>错误处理主要出现在词法分析、语法分析和语义分析部分。为了尽可能全面地检查出全部错误，按照流程，应保证词法分析和语法分析部分遇到错误不仅需要抛出相应错误，还需要进行修正，以便后续流程进行。错误处理完成后，获取 <code>errors</code> 属性，并输出相应信息。同时 <code>errors</code> 也将作为判断是否能进行代码生成的充分条件。</p>
<hr>
<h2 id="代码生成设计"><a href="#代码生成设计" class="headerlink" title="代码生成设计"></a>代码生成设计</h2><p>在获得语法树 <code>AST</code> 后，可以按照树型结构将其转换为目标代码树。直接转化为目标代码难度较大，因此优先转化为中间代码树，在转换为目标代码树。本次实验中选择的目标代码是MIPS，中间代码是LLVMIR。</p>
<h3 id="中间代码生成设计"><a href="#中间代码生成设计" class="headerlink" title="中间代码生成设计"></a>中间代码生成设计</h3><p>在中间代码生成器 <code>Visitor</code> 中，读入语法分析中生成的抽象语法树 <code>AST</code> 和语义分析中生成的符号表 <code>tables</code> ，目标是生成中间代码树 <code>MCT</code> 。对于特定的语法成分，可以对应生成相应的中间代码节点 <code>IR</code> 。LLVMIR中的成分与结构如下图所示：</p>
<p><img src="/images/Compiler/编译器设计文档/中间代码树结构.png" alt="中间代码树结构" style="zoom:50%;" /></p>
<p>LLVMIR中的成分主要有模块 <code>Module</code> ，对应语法成分中的 <code>CompUnit</code> ；全局值 <code>GlobalValue</code> ，对应语法成分中直接声明的全局变量常量；函数 <code>Function</code> ，对应语法成分中的 <code>FuncDef</code> ；基本块 <code>BasicBlock</code> ，存有需要先后执行的指令（一个基本块中的指令一定是一同执行的）；指令 <code>Instrunction</code> ，LLVMIR的基本指令，也是转化为MIPS指令的中间形式。一些常用的LLVMIR基本指令如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>LLVM IR</th>
<th>使用方法</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>add</code></td>
<td><code>&lt;result&gt; = add &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td>
<td>/</td>
</tr>
<tr>
<td><code>sub</code></td>
<td><code>&lt;result&gt; = sub &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td>
<td>/</td>
</tr>
<tr>
<td><code>mul</code></td>
<td><code>&lt;result&gt; = mul &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td>
<td>/</td>
</tr>
<tr>
<td><code>sdiv</code></td>
<td><code>&lt;result&gt; = sdiv &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td>
<td>有符号除法</td>
</tr>
<tr>
<td><code>srem</code></td>
<td><code>&lt;result&gt; = srem &lt;type&gt; &lt;op1&gt;, &lt;op2&gt;</code></td>
<td>有符号取余</td>
</tr>
<tr>
<td><code>icmp</code></td>
<td><code>&lt;result&gt; = icmp &lt;cond&gt; &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td>
<td>比较指令</td>
</tr>
<tr>
<td><code>and</code></td>
<td><code>&lt;result&gt; = and &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td>
<td>按位与</td>
</tr>
<tr>
<td><code>or</code></td>
<td><code>&lt;result&gt; = or &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td>
<td>按位或</td>
</tr>
<tr>
<td><code>call</code></td>
<td><code>&lt;result&gt; = call [ret attrs] &lt;ty&gt; &lt;name&gt;(&lt;...args&gt;)</code></td>
<td>函数调用</td>
</tr>
<tr>
<td><code>alloca</code></td>
<td><code>&lt;result&gt; = alloca &lt;type&gt;</code></td>
<td>分配内存</td>
</tr>
<tr>
<td><code>load</code></td>
<td><code>&lt;result&gt; = load &lt;ty&gt;, ptr &lt;pointer&gt;</code></td>
<td>读取内存</td>
</tr>
<tr>
<td><code>store</code></td>
<td><code>store &lt;ty&gt; &lt;value&gt;, ptr &lt;pointer&gt;</code></td>
<td>写内存</td>
</tr>
<tr>
<td><code>getelementptr</code></td>
<td><code>&lt;result&gt; = getelementptr &lt;ty&gt;, ptr &lt;ptrval&gt; &#123;, &lt;ty&gt; &lt;idx&gt;&#125;*</code></td>
<td>计算目标元素的位置（数组部分会单独详细说明）</td>
</tr>
<tr>
<td><code>phi</code></td>
<td><code>&lt;result&gt; = phi [fast-math-flags] &lt;ty&gt; [&lt;val0&gt;, &lt;label0&gt;], ...</code></td>
<td>/</td>
</tr>
<tr>
<td><code>zext..to</code></td>
<td><code>&lt;result&gt; = zext &lt;ty&gt; &lt;value&gt; to &lt;ty2&gt;</code></td>
<td>将 <code>ty</code> 的 <code>value</code> 的 type 扩充为 <code>ty2</code>（zero extend）</td>
</tr>
<tr>
<td><code>trunc..to</code></td>
<td><code>&lt;result&gt; = trunc &lt;ty&gt; &lt;value&gt; to &lt;ty2&gt;</code></td>
<td>将 <code>ty</code> 的 <code>value</code> 的 type 缩减为 <code>ty2</code>（truncate）</td>
</tr>
<tr>
<td><code>br</code></td>
<td><code>br i1 &lt;cond&gt;, label &lt;iftrue&gt;, label &lt;iffalse&gt;</code> <br /><code>br label &lt;dest&gt;</code></td>
<td>改变控制流</td>
</tr>
<tr>
<td><code>ret</code></td>
<td><code>ret &lt;type&gt; &lt;value&gt;</code>, <code>ret void</code></td>
<td>退出当前函数，并返回值</td>
</tr>
</tbody>
</table>
</div>
<p>想要对中间代码成分进行分析，首先应为各成分建立类型类 <code>ValurTypeIR</code> 。根据代码生成中出现的变量类型，可将其分为两类，基本类型和复合类型。</p>
<ul>
<li>基本变量类型：<ul>
<li><code>IntegerTypeIR</code> ：位数据类型，含有属性位数 <code>bits</code> ，代表数据所占的位数。 <code>bits = 32</code> ，代表 <code>int</code> 类型； <code>bits = 8</code> ，代表 <code>char</code> 类型； <code>bits = 1</code> ，代表 <code>bool</code> 类型。</li>
<li><code>VoidTypeIR</code> ：<code>void</code> 数据类型，仅 <code>FunctionIR</code> 中会出现。</li>
<li><code>LabelTypeIR</code> ：标签类型，代表当前变量的类型为标签。</li>
</ul>
</li>
<li>复合变量类型：<ul>
<li><code>ArrayTypeIR</code> ：数组类型，含有属性数组元素类型 <code>typeIR</code> 、数组元素个数 <code>elementNum</code> 。其中，本实验中规定数组元素类型 <code>typeIR</code> 仅能为位数据类型 <code>IntegerTypeIR</code> ，即只存在 <code>int</code> / <code>char</code> 类型的数组。</li>
<li><code>PointerTypeIR</code> ：指针类型，含有属性指针对象类型 <code>typeIR</code> 。其中，本实验中规定指针所指对象类型为数组类型 <code>ArrayTypeIR</code> （当含有为数组申请地址的指令时）和位数据类型 <code>IntegerTypeIR</code> （当含有普通地址指令时）。</li>
<li><code>FunctionTypeIR</code> ：函数类型，含有属性函数数据类型 <code>typeIR</code> 、函数形参数据类型 <code>paramTypes</code> 。</li>
</ul>
</li>
</ul>
<p>在建立成分类型类后，为各中间代码成分构建类，并对语法树 <code>AST</code> 遍历解析获得中间代码成分。所有的中间代码节点（除顶层模块），均继承于中间代码值类 <code>ValueIR</code> 。该类主要代表各种中间代码索要使用的值，最常用的子类是 <code>FunctionIR</code> （用于函数调用等指令中）、 <code>BasicBlockIR</code> （用于跳转等指令中）等。构建的中间代码成分类如下：</p>
<ul>
<li><p><code>ModuleIR</code> ：中间代码中的模块，代表整个程序。由于本次实验中涉及的待编译 <code>SysY</code> 语言文件都是单文件，因此 <code>ModuleIR</code> 唯一。其含有属性全局变量声明 <code>globalVariables</code> 、函数声明 <code>functions</code> 。在 <code>CompUnit</code> 解析中获得<code>ModuleIR</code> 。</p>
</li>
<li><p><code>GlobalVariableIR</code> ：中间代码中的全局变量声明。其含有属性变量名 <code>name</code> 、初始值 <code>initValue</code> 、是否是输出字符串 <code>isPrint</code> 。在 <code>Decl</code> 中，根据当前变量常量所在层数判断其是否是全局变量常量。</p>
</li>
<li><p><code>FunctionIR</code> ：中间代码中的函数（包括主函数）。其含有属性函数名 <code>name</code> 、函数参数 <code>params</code> 、函数含有的基本块 <code>blocks</code> 、函数中变量数量 <code>numVar</code> 。在 <code>FuncDef</code> 解析中获得 <code>FunctionIR</code> 。LLVMIR中变量以序号表示，每个函数中的变量编号均从 $1$ 开始，因此可以内置函数 <code>allocVar</code> ，为函数申请新变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> VariableIR <span class="title function_">allocVar</span><span class="params">(ValueTypeIR typeIR)</span> &#123;</span><br><span class="line">    <span class="type">VariableIR</span> <span class="variable">var</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VariableIR</span>(typeIR, numVar, name);</span><br><span class="line">    numVar++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">var</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>BasicBlockIR</code> ：中间代码中的基本块，存储需要一同执行的LLVMIR指令。其含有属性基本块标签 <code>label</code> 、基本块是否可以添加指令 <code>canAddInstr</code> 、基本块含有的指令 <code>instrs</code> 。在 <code>Block</code> 的解析中获得 <code>BasicBlockIR</code> （由于申请到的块在 <code>Block</code> 外可能需要使用，因此将新 <code>BasicBlockIR</code> 的申请放在 <code>FuncDef</code> 或 <code>Stmt</code> 的解析中）。在 <code>if</code> 或 <code>for</code> 这种含有条件 <code>Cond</code> 解析的语句中，需要注意额外新 <code>BasicBlockIR</code> 的申请。 </p>
<blockquote>
<p>对于普通的 <code>Cond</code> 判断，其结构应该是 <code>condBlock-trueBlock-falseBlock</code> 。条件判断块 <code>condBlock</code> 中含有跳转指令 <code>br cond, trueLabel, falseLabel</code> 。在条件 <code>Cond</code> 的解析中，需要满足短路求值原则。即对于逻辑与表达式和逻辑或表达式，当左侧表达式可以确定整体表达式值时，不访问右侧表达式。这意味着，当前访问表达式之前的表达式计算结果为真。对于不同形式的表达式，由于短路求值原则，跳转的标签也有所不同。</p>
<ul>
<li>对于逻辑或表达式 <code>B1 || B2</code> ， <code>B1</code> 对应的基本块 <code>block1</code> 的跳转指令，为真跳转到 <code>trueLabel</code> ，为假跳转到 <code>B2Label</code> ； <code>B2</code> 对应的基本块 <code>block2</code> 的跳转指令，为真跳转到 <code>trueLabel</code> ，为假跳转到 <code>falseLabel</code> 。 </li>
<li>对于逻辑与表达式 <code>B1 &amp;&amp; B2</code> ， <code>B1</code> 对应的基本块 <code>block1</code> 的跳转指令，为真跳转到 <code>B2Label</code> ，为假跳转到 <code>falseLabel</code> ； <code>B2</code> 对应的基本块 <code>block2</code> 的跳转指令，为真跳转到 <code>trueLabel</code> ，为假跳转到 <code>falseLabel</code> 。 </li>
<li>对于逻辑与或组合表达式 <code>B1 &amp;&amp; B2 || B3</code> ， <code>B1</code> 对应的基本块 <code>block1</code> 的跳转指令，为真跳转到 <code>B2Label</code> ，为假跳转到 <code>B3Label</code> ； <code>B2</code> 对应的基本块 <code>block2</code> 的跳转指令，为真跳转到 <code>trueLabel</code> ，为假跳转到 <code>B3Label</code> ； <code>B3</code> 对应的基本块 <code>block3</code> 的跳转指令，为真跳转到 <code>trueLabel</code> ，为假跳转到 <code>falseLabel</code> 。 </li>
<li>对于逻辑与或组合表达式 <code>B1 || B2 &amp;&amp; B3</code> ， <code>B1</code> 对应的基本块 <code>block1</code> 的跳转指令，为真跳转到 <code>trueLabel</code> ，为假跳转到 <code>B2Label</code> ； <code>B2</code> 对应的基本块 <code>block2</code> 的跳转指令，为真跳转到 <code>B3Label</code> ，为假跳转到 <code>falseLabel</code> ； <code>B3</code> 对应的基本块 <code>block3</code> 的跳转指令，为真跳转到 <code>trueLabel</code> ，为假跳转到 <code>falseLabel</code> 。 </li>
</ul>
<p>由于在 <code>Cond</code> 的解析函数中，无法获得具体的表达式的数量，因此只能在逻辑与或表达式的解析中创建新的基本块。在解析与或表达式时，出现与或符号，证明还存在下一个表达式，则在解析当前表达式之前应该建立新的基本块。解析逻辑或表达式新建的基本块（ <code>nextOrBlock</code> ，下一个逻辑或表达式块）应当一同传入逻辑与表达式的解析函数中。同时可以观察到，像 <code>B1 || B2 &amp;&amp; B3</code> 这种形式， <code>B2</code> 后不存在下一个逻辑或表达式块，为假时跳转到 <code>falseLabel</code> 。因此，在逻辑或表达式新建基本块时应判断当前是否是最后一个逻辑或表达式，以决定跳转指令的目标。</p>
</blockquote>
<p>同时，应注意，LLVMIR规定，一个基本块中只能出现一个改变控制流的指令（ <code>br</code> 或 <code>ret</code> ），因此在基本块出现该类指令后将 <code>canAddInstr</code> 置为 <code>false</code> ，后续产生的指令不能再添加到该基本块中。</p>
</li>
<li><p><code>ConstIR</code> ：中间代码中的常量。其含有属性常量数值 <code>value</code> 。</p>
<ul>
<li><code>ConstArrayIR</code> ：中间代码中的数组常量，继承 <code>ConstIR</code> 。其含有属性数组元素 <code>values</code> 。</li>
<li><code>ConstStringIR</code> ：中间代码中的字符串常量，继承 <code>ConstIR</code> 。区别于普通的字符串常量（那将在字符数组的初始化中解决），这个字符串常量专指 <code>printf</code> 中的输出字符串。其含有属性字符串名 <code>name</code> 、字符串值 <code>value</code> 、字符串长度 <code>length</code> 。</li>
</ul>
</li>
<li><p><code>VariableIR</code> ：中间代码中的变量。其含有属性变量名 <code>name</code> 、变量编号 <code>pos</code> 、变量值 <code>value</code> 、是否是全局变量 <code>isGlobal</code> 。对于普通变量和全局变量，其所使用的属性不同：全局变量使用变量名、变量值，局部变量使用变量编号、变量值。</p>
</li>
<li><p><code>InstrIR</code> ：中间代码中的指令。其含有属性操作符号 <code>op</code> 。</p>
<ul>
<li><code>AllocateIR</code> ：申请地址的指令，含有属性申请结果 <code>result</code> 、申请类型 <code>type</code> 。主要出现在变量常量声明中，为要声明的标识申请足够的存储地址。</li>
<li><code>StoreIR</code> ：存储变量的指令，含有属性存储值 <code>value</code> 、存储地址 <code>address</code> 。主要出现在赋值语句中，将新值存储在变量对应的地址。</li>
<li><code>LoadIR</code> ：加载变量的指令，含有属性加载到的值 <code>value</code> 、加载地址 <code>address</code> 。主要出现在对变量的使用语句中，将变量的值从对应地址中取出并参与运算。</li>
<li><code>CallIR</code> ：调用函数的指令，含有属性调用函数 <code>function</code> 、函数返回值 <code>result</code> （函数是 <code>void</code> 型时为空）、函数实参 <code>params</code> 。主要出现在一元表达式的函数调用中，确定调用函数，将解析的表达式作为实参存入指令，获得返回值。</li>
<li><code>GetElementIR</code> ：计算数组元素地址的指令，含有属性元素地址 <code>result</code> 、数组基地址 <code>address</code> 、元素索引 <code>index</code> 。主要出现在数组元素的访问中。</li>
<li><code>BinaryIR</code> ：二元有符号计算指令，含有属性左值 <code>lValue</code> 、右值 <code>rValue</code> 、结果 <code>result</code> 。主要出现在加减乘除表达式的解析中，根据计算类型设置指令类型。</li>
<li><code>BTypeTranIR</code> ：数据类型转换指令，含有属性转换值 <code>value</code> 、转换结果 <code>result</code> 。主要出现在各种数据类型转换的赋值中。</li>
<li><code>IcmpIR</code> ：数据比较指令，含有属性左值 <code>lValue</code> 、右值 <code>rValue</code> 、结果 <code>result</code> 。主要出现在关系表达式和相等性表达式。</li>
<li><code>BrIR</code> ：跳转指令，含有属性是否存在条件 <code>haveCond</code> 、跳转块 <code>block</code> 、跳转条件 <code>cond</code> 、为真时跳转块 <code>trueBlock</code> 、为假时跳转块 <code>falseBlock</code> 。有条件的跳转指令使用跳转条件、为真时跳转块、为假时跳转块；无条件的跳转指令使用跳转块。主要出现在各 <code>BasicBlock</code> 末尾改变控制流。</li>
<li><code>RetIR</code> ：返回指令，含有属性返回结果 <code>result</code> （函数是 <code>void</code> 型时为空）。主要出现在 <code>return</code> 语句的解析中。</li>
</ul>
</li>
</ul>
<p>完成全部预备类构建后，即可遍历语法树 <code>AST</code> ，按照上文中所述的解析方式，构建对应的LLVMIR成分，组成中间代码树 <code>MCT</code> 。</p>
<h3 id="目标代码生成设计"><a href="#目标代码生成设计" class="headerlink" title="目标代码生成设计"></a>目标代码生成设计</h3><p>在目标代码翻译器 <code>Translator</code> 中，读入生成的中间代码树 <code>MCT</code> ，目标是生成目标代码树 <code>OCT</code> 。目标代码的结构与中间代码相似，顶层模块 <code>ModuleMips</code> 、全局声明 <code>GlobalMips</code> 、函数 <code>FunctionIR</code> 、基本块 <code>BlockMips</code> 、指令 <code>InstrMips</code> 。因此，目标代码生成的主要思路是遍历中间代码树，生成对应的目标代码部分。</p>
<p>对于模块 <code>ModuleIR</code> 、全局声明 <code>GlobalVariableIR</code> 、基本块 <code>BasicBlockIR</code> 的遍历解析，难度较小，基本为直译，因此不过多赘述。主要说明函数 <code>FunctionIR</code> 和指令 <code>InstrIR</code> 的翻译。此次实验中使用到的MIPS指令如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>MIPS</th>
<th>使用方法</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>La</code></td>
<td><code>La $1, &lt;label&gt;</code></td>
<td>从标签加载数值</td>
</tr>
<tr>
<td><code>Li</code></td>
<td><code>Li $1, &lt;value&gt;</code></td>
<td>从立即数加载数值</td>
</tr>
<tr>
<td><code>move</code></td>
<td><code>move $1, $2</code></td>
<td>将寄存器值赋给另一寄存器</td>
</tr>
<tr>
<td><code>mfhi</code></td>
<td><code>mfhi $1</code></td>
<td>读 <code>hi</code> 寄存器</td>
</tr>
<tr>
<td><code>mflo</code></td>
<td><code>mflo $1</code></td>
<td>读 <code>lo</code> 寄存器</td>
</tr>
<tr>
<td><code>addu</code></td>
<td><code>addu $1, $2, $3</code></td>
<td>无符号加</td>
</tr>
<tr>
<td><code>addiu</code></td>
<td><code>addiu $1, $2, &lt;value&gt;</code></td>
<td>无符号加立即数</td>
</tr>
<tr>
<td><code>subu</code></td>
<td><code>subu $1, $2, $3</code></td>
<td>无符号减</td>
</tr>
<tr>
<td><code>mult</code></td>
<td><code>mult $1, $2</code></td>
<td>有符号乘</td>
</tr>
<tr>
<td><code>div</code></td>
<td><code>div $1, $2</code></td>
<td>有符号除</td>
</tr>
<tr>
<td><code>slt</code></td>
<td><code>slt $1, $2, $3</code></td>
<td>有符号小于置1</td>
</tr>
<tr>
<td><code>andi</code></td>
<td><code>andi $1, $2, $3</code></td>
<td>与立即数</td>
</tr>
<tr>
<td><code>sll</code></td>
<td><code>sll $1, $2, &lt;offset&gt;</code></td>
<td>逻辑左移</td>
</tr>
<tr>
<td><code>srl</code></td>
<td><code>srl $1, $2, &lt;offset&gt;</code></td>
<td>逻辑右移</td>
</tr>
<tr>
<td><code>sra</code></td>
<td><code>sra $1, $2, &lt;offset&gt;</code></td>
<td>算术右移</td>
</tr>
<tr>
<td><code>lw</code></td>
<td><code>lw $1, &lt;offset&gt;($2)</code></td>
<td>加载字</td>
</tr>
<tr>
<td><code>sw</code></td>
<td><code>sw $1, &lt;offset&gt;($2)</code></td>
<td>存储字</td>
</tr>
<tr>
<td><code>beq</code></td>
<td><code>beq $1, $2, &lt;label&gt;</code></td>
<td>相等时转移</td>
</tr>
<tr>
<td><code>bne</code></td>
<td><code>bne $1, $2, &lt;label&gt;</code></td>
<td>不等时转移</td>
</tr>
<tr>
<td><code>bgez</code></td>
<td><code>bgez $1, &lt;label&gt;</code></td>
<td>大于等于0时转移</td>
</tr>
<tr>
<td><code>blez</code></td>
<td><code>blez $1, &lt;label&gt;</code></td>
<td>小于等于0时转移</td>
</tr>
<tr>
<td><code>bgtz</code></td>
<td><code>bgtz $1, &lt;label&gt;</code></td>
<td>大于0时转移</td>
</tr>
<tr>
<td><code>bltz</code></td>
<td><code>bltz $1, &lt;label&gt;</code></td>
<td>小于0时转移</td>
</tr>
<tr>
<td><code>j</code></td>
<td><code>j &lt;label&gt;</code></td>
<td>跳转</td>
</tr>
<tr>
<td><code>jal</code></td>
<td><code>jal &lt;label&gt;</code></td>
<td>跳转并链接</td>
</tr>
<tr>
<td><code>jr</code></td>
<td><code>jr $1</code></td>
<td>跳转至寄存器</td>
</tr>
<tr>
<td><code>syscall</code></td>
<td><code>syscall</code></td>
<td>系统调用</td>
</tr>
</tbody>
</table>
</div>
<p>对于MIPS指令的翻译，最重要的是寄存器的存储和分配系统的建立。建立寄存器类 <code>Register</code> ，其含有属性名称 <code>name</code> 、编号 <code>id</code> 、是否正在使用 <code>use</code> 、寄存器中值 <code>value</code> 。同时建立寄存器表类 <code>RegisterTable</code> ，负责寄存器的管理。对于寄存器的分配，采用的策略是如果有未在使用的寄存器，即分配该寄存器；如果全部寄存器都在使用，则将 <code>$t0</code> 的值压入数据栈中，分配 <code>$t0</code> 。对于该种分配方法，核心是寄存器应该在何时释放。寄存器的释放原则是每次存入寄存器的值只能使用一次，使用后立即释放（出于正确性考虑，再使用寄存器前，应检查该寄存器内数据是否是当前变量），以防止寄存器数量不够用以及控制流改变引发的寄存器冲突问题。寄存器的释放过程在指令中进行。</p>
<p>由于每一个 <code>VariableIR</code> 可能被不止一次使用，因此应该建立中间代码变量符号表，以便后续使用。建立中间代码符号类 <code>SymbolMips</code> ，其含有属性变量名 <code>name</code> 、是否是全局声明 <code>isGlobal</code> 、是否是立即数 <code>isImm</code> 、是否是绝对地址 <code>isAbsolute</code> 、分配的寄存器 <code>register</code> 、数值 <code>value</code> 、存储的相对地址 <code>addrOffset</code> 。对于普通变量或立即数，填写相应属性即可。对于代表地址的变量，则需要要特殊处理。对于存储全局声明标签的变量，需要标记 <code>isAbsolute</code> 为真，后续使用时可能出现相对地址与绝对地址之间的转化。</p>
<p>在完成预备类的构建后，进行 <code>InstrIR</code> 的翻译：</p>
<ul>
<li><code>AllocateIR</code> ：为变量申请地址，不增加MIPS指令，只改变当前的 <code>offset</code> 。为变量构建中间代码变量符号，并将当前相对 <script type="math/tex">sp</script> 的偏移量 <code>offset</code> 赋值给相应属性即可。按照申请的地址大小，增加 <code>offset</code> 的值（ <code>int</code> / <code>char</code> 型均按照一个字节存储，变量为数组时按照元素数量改变 <code>offset</code> 的值）。</li>
<li><code>StoreIR</code> ：存储变量，使用 <code>sw $1, &lt;offset&gt;($2)</code> 即可。应注意判断存储到的指针变量类型：若该变量是相对地址，则使用 <code>sw $1, &lt;offset&gt;($sp)</code> ；若该变量是绝对地址，则使用 <code>sw $1, 0($2)</code> 。完成存储后，释放分配给值变量和地址变量的寄存器。</li>
<li><code>LoadIR</code> ：加载变量，使用 <code>lw $1, &lt;offset&gt;($2)</code> 即可。对于待加载的指针变量类型的判定和 <code>StoreIR</code> 相同。完成加载后，释放分配给地址变量的寄存器。</li>
<li><code>CallIR</code> ：调用函数，使用 <code>jal &lt;label&gt;</code> 跳转到函数位置即可。</li>
<li><code>GetElementIR</code> ：计算数组元素地址， <code>elementAddr = baseAddr + index * 4</code> ， <code>elementAddr</code> 统一使用绝对地址。如果基地址为绝对地址，直接使用 <code>sll</code> 和 <code>addu</code> 指令计算即可。如果基地址为相对地址，则需要额外加 <code>$sp</code> 。完成计算后，释放分配给基地址变量和索引变量的寄存器。</li>
<li><code>BinaryIR</code> ：二元有符号计算，使用对应的二元计算指令即可。应注意，为防止计算中的数值溢出，加减指令应使用 <code>addu</code> 和 <code>subu</code> 。对于乘除模，使用 <code>mult</code> 、 <code>div</code> 指令搭配 <code>mfhi</code> 、 <code>mflo</code> 指令即可。完成计算后，释放分配给算式左值右值的寄存器。</li>
<li><code>BTypeTranIR</code> ：数据类型转换，由于 <code>int</code> / <code>char</code> 型均按照一个字节存储，理论上结果变量使用值变量的寄存器即可。但应注意，对于 <code>trunc</code> 指令，将 <code>int</code> 型缩减到 <code>char</code> 型，高24位数据应当舍弃。因此若为 <code>trunc</code> 指令，则添加 <code>andi $1, $2, 0xff</code> 。</li>
<li><code>IcmpIR</code> ：二元有符号比较，按照比较类型添加指令即可。由于LLVMIR中是先比较得到结果再进行跳转，而MIPS中只有 <code>slt</code> 一种比较指令，其他类型比较只有直接的跳转指令。因此为了不破坏LLVMIR指令的原子性，需要使用组合的 <code>slt</code> 指令。将 <code>&lt;=</code> / <code>&gt;=</code> 转化为 <code>!&gt;</code> / <code>!&lt;</code> ， <code>==</code> / <code>!=</code> 转化为 <code>!&gt; &amp;&amp; !&lt;</code> / <code>&gt; || &lt;</code> ，使用 <code>slt</code> 搭配逻辑运算指令即可实现其他类型的比较。完后比较后，释放分配给比较式左值右值的寄存器。</li>
<li><code>BrIR</code> ：各类跳转。对于 <code>br label</code> ，可直接翻译为 <code>j &lt;label&gt;</code> ；对于 <code>br cond, trueLabel, falseLabel</code> ，可翻译为 <code>beq cond, 0, &lt;falseLabel&gt;</code> 与 <code>j &lt;trueLabel&gt;</code> 的组合。对于后者，完成比较后，释放分配给条件的寄存器。</li>
<li><code>RetIR</code> ：函数返回。对于存在返回值的 <code>RetIR</code> 指令，首先需要将返回值赋值给 <code>$v0</code> 及 <code>$v1</code> 。由于文法中规定，返回值至多为一个值，因此只使用 <code>$v0</code> 即足够。完成赋值后， <code>jr $ra</code> 返回调用前下一条指令即可。</li>
</ul>
<p>由于MIPS中只存在全局寄存器和数据栈，不存在函数形参和实参的概念，因此 <code>FunctionMips</code> 的处理与 <code>FunctionIR</code> 的处理有所不同。在调用函数时，首先应进行压栈，将目前全部寄存器中的数据压入栈中，并按照压栈的数据数量改变 <code>$sp</code> 的值，防止函数解析时改变寄存器值而造成的错误。将实参解析后存入 <code>$a0 - $a3</code> 寄存器中，如果实参数量超过 $4$ 个，则将多余的实参压栈。进入函数解析后，首先应将 <code>$sp</code> 和实参取出并存在栈中。由于可能存在参数数量超过 $4$ 个的情况， <code>$a0</code> 对应的参数应当存入 <code>offset = 4</code> 的地址，会造成形参的污染，因此形参的存储应从后向前进行。函数解析中如果出现调用其他函数的情况，重复上述操作即可。行进到 <code>ret</code> 语句时取出 <code>$sp</code> ，并加入 <code>jr $ra</code> 。完成函数解析并返回调用前下一条指令后，将调用前压入栈中的数据从栈中取出（在出栈前可以先释放全部临时寄存器，以防函数遗留数据导致寄存器后期无法使用），并按照压栈的数据数量改变 <code>$sp</code> 的值。</p>
<hr>
<h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><h3 id="中间代码优化"><a href="#中间代码优化" class="headerlink" title="中间代码优化"></a>中间代码优化</h3><p>中间代码优化主要有以SSA形式建立中间语言、死代码删除、GVN&amp;GCN建立、常量提取等。由于时间原因，本次实验中编译器未进行中间代码优化。</p>
<h3 id="目标代码优化"><a href="#目标代码优化" class="headerlink" title="目标代码优化"></a>目标代码优化</h3><p>目标代码优化主要有指令选择、图着色寄存器分配、乘除法优化、基本块合并和窥孔优化。本次实验中，主要完成了指令选择、无用指令删除、乘除法优化。</p>
<h4 id="指令选择"><a href="#指令选择" class="headerlink" title="指令选择"></a>指令选择</h4><p>为了实现更多功能，以及更加方便翻译高级语言，MIPS提供了大量的伪指令使用，例如<code>subi</code>、<code>move</code>、<code>ble</code> 等，能够缩短指令的条数，增加代码的可读性。但实际上，伪指令会被翻译为多条实际指令进行使用。以 <code>subi</code> 为例，一条 <code>subi $1, $2, 1000</code> 的指令，会被MIPS的模拟器Mars翻译为 <code>addi $3, $0, 0x3e8</code> 和 <code>sub $1, $2, $3</code> 两条指令；但是如果直接使用 <code>addi $1, $2, -1000</code> 的指令，不会被翻译为额外指令，可以提高程序执行效率。因此，将全部 <code>subi</code> 指令替换为 <code>addi</code> 指令。程序中涉及到 <code>subi</code> 指令的部分主要是调用函数时 <code>$sp</code> 的改变，将这部分指令替换即可。</p>
<p>在目标代码翻译的过程中，出于保护LLVMIR指令原子性的考虑，将 <code>IcmpIR</code> 翻译为 <code>slt</code> 和逻辑运算指令搭配的形式，如 <code>%res = icmp eq i32 %1, %2</code> ，翻译为MIPS指令就是 <code>slt $t2, $t1, $t0</code> 、 <code>slt $t1, $t0, $t1</code> 、 <code>or $t2, $t2, $t1</code> 、 <code>xor $t2, $t2, 1</code> 四条指令，最终寄存器 <code>$t2</code> 存储的就是比较结果。由于比较式出现在 <code>Cond</code> 中，其后通常伴随着跳转指令，因此可以对其进行优化。比如说源代码 <code>if(i == 1) &#123;...&#125;</code> ，直接生成LLVMIR指令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%main_var2 = load i32, i32* %main_var1</span><br><span class="line">%main_var3 = icmp eq i32 %main_var2, 1</span><br><span class="line">br i1 %main_var3, label %trueLabel, label %falseLabel</span><br><span class="line">trueLabel:</span><br><span class="line">...</span><br><span class="line">falseLabel:</span><br></pre></td></tr></table></figure>
<p>优化前优化后的MIPS指令如下：</p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 优化前：</span></span><br><span class="line"><span class="keyword">lw </span>$<span class="built_in">t0</span>, <span class="number">4</span>($<span class="built_in">sp</span>)</span><br><span class="line"><span class="keyword">move </span>$<span class="built_in">t1</span>, $<span class="built_in">t0</span></span><br><span class="line">li $<span class="built_in">t0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">slt </span>$<span class="built_in">t2</span>, $<span class="built_in">t1</span>, $<span class="built_in">t0</span></span><br><span class="line"><span class="keyword">slt </span>$<span class="built_in">t1</span>, $<span class="built_in">t0</span>, $<span class="built_in">t1</span></span><br><span class="line"><span class="keyword">or </span>$<span class="built_in">t2</span>, $<span class="built_in">t2</span>, $<span class="built_in">t1</span></span><br><span class="line"><span class="keyword">xor </span>$<span class="built_in">t2</span>, $<span class="built_in">t2</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">beq </span>$<span class="built_in">t2</span>, $<span class="built_in">zero</span>, falseLabel</span><br><span class="line"><span class="symbol">trueLabel:</span></span><br><span class="line">...</span><br><span class="line"><span class="symbol">falseLabel:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#优化后</span></span><br><span class="line"><span class="keyword">lw </span>$<span class="built_in">t0</span>, <span class="number">4</span>($<span class="built_in">sp</span>)</span><br><span class="line"><span class="keyword">move </span>$<span class="built_in">t1</span>, $<span class="built_in">t0</span></span><br><span class="line">li $<span class="built_in">t0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">bne </span>$<span class="built_in">t1</span>, $<span class="built_in">t0</span>, falseLabel</span><br><span class="line"><span class="symbol">trueLabel:</span></span><br><span class="line">...</span><br><span class="line"><span class="symbol">falseLabel:</span></span><br></pre></td></tr></table></figure>
<p>其他比较类型 <code>!= | &gt;= | &lt;=</code> 与上述优化相似。</p>
<h4 id="无用指令删除"><a href="#无用指令删除" class="headerlink" title="无用指令删除"></a>无用指令删除</h4><p>在MIPS指令中，每个基本块不强制要求出现改变控制流的跳转指令，如果该块不存在跳转指令，则默认按照顺序执行。由于在目标代码翻译的过程中，对于带条件的 <code>br</code> 指令 <code>br cond, trueLabel, falseLabel</code> ，采取的翻译模式是 <code>beq cond, 0, &lt;falseLabel&gt;</code> 与 <code>j &lt;trueLabel&gt;</code> 的组合，而通常来讲 <code>j &lt;trueLabel&gt;</code> 跳转到的 <code>trueBlock</code> 即是下一个基本块。同时，在中间代码生成的过程中，可能会出现仅含有 <code>br</code> 指令的基本块。这类块在目标代码翻译中会被翻译为 <code>j &lt;label&gt;</code> ，且通常跳转到下一个基本块。在这些情况中，会出现多余的跳转指令。因此可以特判跳转指令，如果跳转到的 <code>&lt;label&gt;</code> 和下一个块的标签相同，则省略这条跳转指令。</p>
<h4 id="乘除法优化"><a href="#乘除法优化" class="headerlink" title="乘除法优化"></a>乘除法优化</h4><p>在MIPS指令中，乘除法计算指令 <code>mult</code> 和 <code>div</code> 消耗时间相比 <code>sll</code> 、<code>srl</code> 等移位指令， <code>addu</code> 、<code>subu</code> 等计算指令过大，需要进行一定优化。按照程序设置，在中间代码生成的过程中，当表达式左右两侧都为常量值时，会直接计算出结果。因此在目标代码翻译的过程中，只可能出现两个变量计算或一个变量一个常量值计算。乘除法优化基于一个变量一个常量值计算进行，主要原理是通过判定常量值是否是特定数值，优化乘除计算指令。在优化过程中，我们保证除数为正，当除数为负数时添加 <code>subu $1, $0, $1$</code> 即可。</p>
<h5 id="乘法优化"><a href="#乘法优化" class="headerlink" title="乘法优化"></a>乘法优化</h5><ul>
<li>数值为 $0$ ：可以直接对结果寄存器赋 $0$ 值。</li>
<li>数值为 $2$ 的幂数：使用 <code>sll</code> 指令，计算该常量对于 $2$ 的幂次，左移相应位数。</li>
<li>数值与小于它的最大 $2$ 的幂数差小于 $4$ ：按照实验设定， <code>mult</code> 的时间消耗是 <code>sll</code> 、 <code>addu</code> 的 $5$ 倍，因此部分乘数可以分解为 <code>sll + n * addu</code> 的形式，如数值为 <code>10 = 8 + 2</code> ，此时将 <code>x * 10</code> 就可以转变为 <code>x &lt;&lt; 3 + x + x</code> ，时间变短。数值与大于它的最小 $2$ 的幂数差小于 $4$ 的同理，分解为 <code>sll + n * subu</code> 的形式。</li>
<li>其他数值：无法进行优化，正常添加指令即可。</li>
</ul>
<h5 id="除法优化"><a href="#除法优化" class="headerlink" title="除法优化"></a>除法优化</h5><ul>
<li><p>数值为1：可以直接对结果寄存器赋原值。</p>
</li>
<li><p>数值为2的幂数：使用 <code>sra</code> 指令，计算该常量对于2的幂次，右移相应位数。移位计算的结果是除法结果向下取整，如 $2.3 \rightarrow 2$ 、 $-2.3 \rightarrow -3$ 。若被除数小于 $0$ ，除法结果应当是移位计算结果加1。因此，首先使用 <code>srl $2, $1, 31</code> 获得被除数的符号位，并与移位结果相加（若被除数为正，符号位为 $0$ ，除法结果等于移位计算结果；若被除数为负，符号位为 $1$ ，除法结果等于移位计算结果加 $1$ ）。</p>
</li>
<li><p>其他数值：按照实验设定， <code>div</code> 指令的时间消耗远大于 <code>mult</code> 的，因此可以借助乘法来优化除法。基本原理是先对原被除数乘一个大数，再右移获得最终结果。这个大数既要保证乘之后可以保证原除法结果，又要保证除法结果已经全部位于 <code>hi</code> 寄存器中。对于被除数 $n$ 、除数 $d$ 、大数 $m$ ，存在关系： $\lfloor\frac{n}{d}\rfloor = \lfloor\frac{n\cdot m}{2^{N+l}}\rfloor$ ，其中大数 $m$ 满足 $2^{N+l} \leqslant m \cdot d \leqslant 2^{N+l} + 2 ^ l$ ，常数 $N = 32$ 保证该大数满足要求。为简化大数 $m$ 的取值，设定 $l = 1$ 。可以得到代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.pow(<span class="number">2</span>, <span class="number">32</span> + l) / valueAbs);</span><br><span class="line"><span class="keyword">if</span> (!(Math.pow(<span class="number">2</span>, <span class="number">32</span> + l) &lt;= ((<span class="type">long</span>) m) * valueAbs &amp;&amp; </span><br><span class="line">		((<span class="type">long</span>) m) * valueAbs &lt;= Math.pow(<span class="number">2</span>, <span class="number">32</span> + l) + Math.pow(<span class="number">2</span>, l))) &#123;</span><br><span class="line">	m++;</span><br><span class="line">&#125; <span class="comment">// 保证m满足条件</span></span><br><span class="line"><span class="type">SymbolMips</span> <span class="variable">rSym</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SymbolMips</span>(m);</span><br><span class="line">symUseReg(rSym);</span><br><span class="line">curBlock.addInstr(<span class="keyword">new</span> <span class="title class_">MultMips</span>(lSym.getRegister(), rSym.getRegister()));</span><br><span class="line">curBlock.addInstr(<span class="keyword">new</span> <span class="title class_">MfhiMips</span>(resSym.getRegister()));</span><br><span class="line">curBlock.addInstr(<span class="keyword">new</span> <span class="title class_">SraMips</span>(resSym.getRegister(), resSym.getRegister(), l));</span><br><span class="line">curBlock.addInstr(<span class="keyword">new</span> <span class="title class_">SrlMips</span>(lSym.getRegister(), lSym.getRegister(), <span class="number">31</span>));</span><br><span class="line">curBlock.addInstr(<span class="keyword">new</span> <span class="title class_">AdduMips</span>(resSym.getRegister(), resSym.getRegister(), lSym.getRegister()));</span><br><span class="line">rSym.getRegister().freeReg();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>对于乘法优化，左值右值为常量时均可进行；对于除法优化，被除数为常量时不能进行，除数为常量时可以进行。</p>
<hr>
<h2 id="实验感想"><a href="#实验感想" class="headerlink" title="实验感想"></a>实验感想</h2><p>本次实验确实是一次量大难度高的任务，极具挑战性。在实验中，需要按照流程建立一套编译程序，从读入程序字符串出发，直到翻译为机器码，并能够执行获得结果。实验的架构设计是较为明确的，课程组提供的流程十分科学，可以进行模块化开发，词法分析、语法分析、符号表建立、中间代码生成、目标代码翻译，每一个模块相互独立，建立接口实现两两之间的信息交互。本次实验更像是在学完各种课程后的一次实战演练，将之前在计算机组成、操作系统等课中学到的各类知识结合运用起来。实验涉及的知识点很多，字符串解析、层次分析法、有限状态机等。可以使用的设计理念也有很多，如单例模式、工厂模式、观察者模式等。本次实验也是继OO课设后第一次自行设计实现大型项目，十分强调程序的层次化模块化抽象化，不仅锻炼了我的编码能力，还锻炼了我的架构设计思维。在实现编译流程后，还进行了一定的代码优化工作。这些工作向我展示了编译程序的底层优化逻辑，从程序结构和底层机器码的角度出发，既有对于无用部分的删除，也有偏硬方面的优化。美中不足的是，由于各项课程事务繁多，无法再对设计的编译器做进一步优化。整体来说，实验难度很大，从高级语言、LLVMIR到MIPS，结构理念都有很大的不同，每一次转换都是一种挑战，每一个语言下的Bug都曾令我困扰良久。但看着完成的七八千行代码，以及可以成功编译执行的各个代码文件，内心十分有成就感。文档末尾，是对一学期课程的反思与告别。也想感谢理论课老师、两位帮助我颇多的助教和每一位一同进步的同学，使得我能够在这条艰难的路上一直走下去。</p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>Mips</tag>
        <tag>LLVMIR</tag>
      </tags>
  </entry>
  <entry>
    <title>Lab5实验报告</title>
    <url>/2025/03/15/OS/Lab5%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="Lab5实验报告"><a href="#Lab5实验报告" class="headerlink" title="Lab5实验报告"></a>Lab5实验报告</h1><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-5-1"><a href="#Thinking-5-1" class="headerlink" title="Thinking 5.1"></a>Thinking 5.1</h3><ul>
<li><strong>引发问题：</strong>外设数据更新在缓存写入之后，因此若通过kseg0读入，会导致缓存部分数据在外设数据更新之后写入，导致数据丢失。</li>
<li><strong>设备区别：</strong>串口设备访问频繁，IDE磁盘访问频率低，更像cache和内存的区别。</li>
</ul>
<h3 id="Thinking-5-2"><a href="#Thinking-5-2" class="headerlink" title="Thinking 5.2"></a>Thinking 5.2</h3><ul>
<li><p>文件结构体的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> f_name[MAXNAMELEN]; <span class="comment">// filename</span></span><br><span class="line">	<span class="type">uint32_t</span> f_size; <span class="comment">// file size in bytes</span></span><br><span class="line">	<span class="type">uint32_t</span> f_type; <span class="comment">// file type</span></span><br><span class="line">	<span class="type">uint32_t</span> f_direct[NDIRECT];</span><br><span class="line">	<span class="type">uint32_t</span> f_indirect;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f_dir</span>;</span> <span class="comment">// the pointer to the dir where this file is in, valid only in memory.</span></span><br><span class="line">	<span class="type">char</span> f_pad[FILE_STRUCT_SIZE - MAXNAMELEN - (<span class="number">3</span> + NDIRECT) * <span class="number">4</span> - <span class="keyword">sizeof</span>(<span class="type">void</span> *)];</span><br><span class="line">&#125; __attribute__((aligned(<span class="number">4</span>), packed));</span><br></pre></td></tr></table></figure>
<p>磁盘块容量4KB，每个文件控制块<code>f_pad[i]</code>对齐为256B，因此一个磁盘有16个文件控制块。</p>
</li>
<li><p>一个目录最多含1024个磁盘块，因此最多含16384个文件。</p>
</li>
<li><p>一个文件最多含1024个磁盘块，一次最多含16384个文件。</p>
</li>
</ul>
<h3 id="Thinking-5-3"><a href="#Thinking-5-3" class="headerlink" title="Thinking 5.3"></a>Thinking 5.3</h3><ul>
<li>块缓存地址范围是<code>[0x10000000, 0x50000000)</code>，总共1GB。</li>
</ul>
<h3 id="Thinking-5-4"><a href="#Thinking-5-4" class="headerlink" title="Thinking 5.4"></a>Thinking 5.4</h3><ul>
<li><code>DISKMAP</code>：磁盘起始地址</li>
<li><code>DISKMAX</code>：磁盘存储最大大小</li>
<li><code>BLOCK_SIZE</code>：块大小</li>
<li><code>SECT_SIZE</code>：磁盘每个扇区大小</li>
<li><code>MAXNAMELEN</code>：文件名最大长度</li>
<li><code>MAXPATHLEN</code>：路径名最大长度</li>
<li><code>MAXFILESIZE</code>：文件最大大小</li>
<li><code>NDIRECT</code>：直接指针数量</li>
<li><code>NINDIRECT</code>：间接指针数量</li>
<li><code>struct File</code>：文件结构体定义</li>
</ul>
<h3 id="Thinking-5-5"><a href="#Thinking-5-5" class="headerlink" title="Thinking 5.5"></a>Thinking 5.5</h3><ul>
<li><p>进程所有文件描述符和定位指针均存储在某一用户空间范围内，因此调用<code>fork()</code>后父子进程会共享文件描述符和定位指针。</p>
</li>
<li><p>测试代码：（参考往届学长代码）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printk.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> r, fdnum, n;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">200</span>];</span><br><span class="line">    fdnum = open(<span class="string">&quot;/newmotd&quot;</span>, O_RDWR | O_ALONE);</span><br><span class="line">    <span class="keyword">if</span> ((r = fork()) == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">    	n = read(fdnum, buf, <span class="number">5</span>);</span><br><span class="line">    	printk(<span class="string">&quot;child processing&#x27;s value is %s\n&quot;</span>, buf);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">    	n = read(fdnum, buf, <span class="number">5</span>);</span><br><span class="line">    	printk(<span class="string">&quot;father processing&#x27;s value is %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Thinking-5-6"><a href="#Thinking-5-6" class="headerlink" title="Thinking 5.6"></a>Thinking 5.6</h3><ul>
<li><p>文件控制块结构体、文件描述符结构体、文件内容结构体代码定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> f_name[MAXNAMELEN];	<span class="comment">//文件名称字符串</span></span><br><span class="line">	<span class="type">uint32_t</span> f_size;			<span class="comment">//文件大小</span></span><br><span class="line">	<span class="type">uint32_t</span> f_type;			<span class="comment">//文件类型</span></span><br><span class="line">	<span class="type">uint32_t</span> f_direct[NDIRECT]; <span class="comment">//文件直接指针</span></span><br><span class="line">	<span class="type">uint32_t</span> f_indirect;		<span class="comment">//文件间接指针</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f_dir</span>;</span>			<span class="comment">//文件所处目录</span></span><br><span class="line">	<span class="type">char</span> f_pad[FILE_STRUCT_SIZE - MAXNAMELEN - (<span class="number">3</span> + NDIRECT) * <span class="number">4</span> - <span class="keyword">sizeof</span>(<span class="type">void</span> *)];</span><br><span class="line">    							<span class="comment">//为使一个磁盘块含有证书个文件结构体，填充剩余字节</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> &#123;</span></span><br><span class="line">	u_int fd_dev_id; <span class="comment">//文件对应设备编号</span></span><br><span class="line">	u_int fd_offset; <span class="comment">//文件指针指向的地址</span></span><br><span class="line">	u_int fd_omode;  <span class="comment">//文件的打开方式</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> <span class="title">f_fd</span>;</span>     <span class="comment">//文件描述符</span></span><br><span class="line">	u_int f_fileid;		<span class="comment">//文件全局编号</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">f_file</span>;</span> <span class="comment">//文件控制块</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件控制块<code>File</code>：主要用于存储文件具体信息，如文件名、大小、类型等。</p>
</li>
<li><p>文件描述符<code>Fd</code>：主要用于记录已打开文件当前的状态，方便直接对文件进行申请和操作等。</p>
</li>
<li><p>文件<code>Filefd</code>：主要用于存储更多的文件信息，包含文件描述符和文件控制块。在使用中有时会将<code>Fd*</code>类型指针强制转化为<code>Filefd*</code>类型指针，从而获取更多的文件信息。</p>
</li>
</ul>
<h3 id="Thinking-5-7"><a href="#Thinking-5-7" class="headerlink" title="Thinking 5.7"></a>Thinking 5.7</h3><ul>
<li><p>图中主要有两种箭头：</p>
<ul>
<li>黑三角黑实线箭头：同步消息</li>
<li>开三角黑虚线箭头：返回消息</li>
</ul>
</li>
<li><p>具体流程为发送方发出同步消息，并暂停活动等待返回消息，接收者获得消息并处理无误后发送返回消息。不同进程间的消息发送接收主要通过<code>IPC</code>实现，具体是调用<code>fsipc()</code>函数。</p>
</li>
</ul>
<h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><p>本次实验中，我遇到的难点主要有以下几点：</p>
<ul>
<li>读写设备信息：本次实验最重要的函数是设备信息的获取与修改。根据传入的信息长度<code>len</code>判断是否符合标准，不符合标准需要返回<code>-E_INVAL</code>报错；再判断当前准备访问的物理地址是否处于设备信息存储物理地址范围内；没有问题后使用<code>iowrite()、ioread()</code>或<code>memcpy()</code>函数进行数据的更改。</li>
<li>用户态下驱动内核态对磁盘读写：用户态下对磁盘读写操作首先需要设置<code>temp</code>，对<code>NSECT</code>、<code>LBAL</code>、<code>LBAM</code>、<code>LBAH</code>、<code>DEVICE</code>和<code>STATUS</code>寄存器进行更改，写入相应数值。再将<code>MALTA_IDE_DATA</code>写入对应的<code>dst</code>或读入对应的<code>src</code>位置。</li>
<li>创造文件<code>create_File()</code>操作：本次实验中，需要实现创造文件的函数。这个函数本身实现难度并不是很大，主要是对于<code>struct File</code>结构体定义的理解全面性。具体操作包含将块序号<code>blocknum</code>赋予文件直接指针或间接指针对应的数据，根据文件名称是否为空判断当前地址的文件是否被使用。如果存在未使用的文件，就返回当前文件；如果不存在，就新申请一个未使用的块并返回。</li>
</ul>
<h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>Lab5主要让我们学习有关文件创造与系统使用的问题，了解MIPS系统中虚拟地址与物理地址的对应关系、进行设备读写并尝试通过设备读写更改文件内容。本次实验涉及到的知识点很多很新，同时也有大量未知的需要自己阅读的宏定义和函数（在不知道使用目的与形参函数的含义情况下上手难度极大），继承前三个lab的函数与知识，逻辑清晰，但实现难度较大，也花费了我很长一段时间来完成。程序完成后的debug也非常痛苦，主要问题是不知道哪个函数出现了问题（最终通过了print大法找出），并且有一些地方发现多种看似矛盾的写法都可以正确通过测试。也十分感谢那些写博客的学长（虽然发现了两篇有所不同的博客，也没有尝试是否都是正确的），看了他们的博客后真的是茅塞顿开。实验越往后走，陌生的东西越多，还是要摆正心态，世上无难事，只要肯攀登。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Mips</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Lab6实验报告</title>
    <url>/2025/03/15/OS/Lab6%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="Lab6实验报告"><a href="#Lab6实验报告" class="headerlink" title="Lab6实验报告"></a>Lab6实验报告</h1><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-6-1"><a href="#Thinking-6-1" class="headerlink" title="Thinking 6.1"></a>Thinking 6.1</h3><ul>
<li><p>更改前的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> (fork()) </span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 子进程 - 作为管道的读者 */</span></span><br><span class="line">			close(fildes[<span class="number">1</span>]); <span class="comment">/* 关闭不用的写端 */</span></span><br><span class="line">			read(fildes[<span class="number">0</span>], buf, <span class="number">100</span>); <span class="comment">/* 从管道中读数据 */</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;child-process read:%s&quot;</span>,buf); <span class="comment">/* 打印读到的数据 */</span></span><br><span class="line">			close(fildes[<span class="number">0</span>]); <span class="comment">/* 读取结束，关闭读端 */</span></span><br><span class="line">			<span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">default</span>: <span class="comment">/* 父进程 - 作为管道的写者 */</span></span><br><span class="line">			close(fildes[<span class="number">0</span>]); <span class="comment">/* 关闭不用的读端 */</span></span><br><span class="line">			write(fildes[<span class="number">1</span>], <span class="string">&quot;Hello world\n&quot;</span>, <span class="number">12</span>); <span class="comment">/* 向管道中写数据 */</span></span><br><span class="line">			close(fildes[<span class="number">1</span>]); <span class="comment">/* 写入结束，关闭写端 */</span></span><br><span class="line">			<span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更改后的代码：将子进程与父进程部分调换即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> (fork()) </span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 父进程 - 作为管道的写者 */</span></span><br><span class="line">			close(fildes[<span class="number">0</span>]); <span class="comment">/* 关闭不用的读端 */</span></span><br><span class="line">			write(fildes[<span class="number">1</span>], <span class="string">&quot;Hello world\n&quot;</span>, <span class="number">12</span>); <span class="comment">/* 向管道中写数据 */</span></span><br><span class="line">			close(fildes[<span class="number">1</span>]); <span class="comment">/* 写入结束，关闭写端 */</span></span><br><span class="line">			<span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">default</span>: <span class="comment">/* 子进程 - 作为管道的读者 */</span></span><br><span class="line">			close(fildes[<span class="number">1</span>]); <span class="comment">/* 关闭不用的写端 */</span></span><br><span class="line">			read(fildes[<span class="number">0</span>], buf, <span class="number">100</span>); <span class="comment">/* 从管道中读数据 */</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;child-process read:%s&quot;</span>,buf); <span class="comment">/* 打印读到的数据 */</span></span><br><span class="line">			close(fildes[<span class="number">0</span>]); <span class="comment">/* 读取结束，关闭读端 */</span></span><br><span class="line">			<span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Thinking-6-2"><a href="#Thinking-6-2" class="headerlink" title="Thinking 6.2"></a>Thinking 6.2</h3><ul>
<li>关系式<code>pageref(rfd) + pageref(wfd) = pageref(pipe)</code> 在非原子的 <code>close</code> 函数调用时不能保证成立；作为非原子操作，在该函数进行时，有可能出现时钟中断，更换进程的问题，从而导致函数出现问题。</li>
</ul>
<h3 id="Thinking-6-3"><a href="#Thinking-6-3" class="headerlink" title="Thinking 6.3"></a>Thinking 6.3</h3><ul>
<li><p>系统调用一定是原子操作。在系统调用 <code>syscall</code> 对应的异常处理程序 <code>handle_sys</code> 中，使用了汇编宏定义 <code>CLI</code> 来禁用全局中断，因此系统调用时不会被中断，是原子操作。<code>CLI</code>宏定义具体代码如下：</p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="meta">.macro</span> CLI</span><br><span class="line">    <span class="keyword">mfc0 </span>   <span class="built_in">t0</span>, CP0_STATUS</span><br><span class="line">    li      <span class="built_in">t1</span>, (STATUS_CU0 <span class="title">| 0x1)</span></span><br><span class="line"><span class="title">    or      t0, t1</span></span><br><span class="line"><span class="title">    xor     t0, 0x1</span></span><br><span class="line"><span class="title">    mtc0    t0, CP0_STATUS</span></span><br><span class="line"><span class="title">.endm</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Thinking-6-4"><a href="#Thinking-6-4" class="headerlink" title="Thinking 6.4"></a>Thinking 6.4</h3><ul>
<li>可以解决。关系式<code>pageref(rfd) + pageref(wfd) = pageref(pipe)</code>中，<code>ref(pipe)</code>先减小，<code>ref(fd)</code>后减小，因此如果先解除<code>p[0]</code>的映射，将会永远达不到取等的临界条件。</li>
<li><code>dup</code>函数是类似的，不过变为增加，也会出现与<code>close</code>类似的问题，<code>pipe</code>的引用次数总比<code>fd</code>要高。当管道的<code>dup</code>进行到一半时， 若先映射<code>fd</code>，再映射 <code>pipe</code> ，就会使得<code>fd</code>的引用次数的加一先于<code>pipe</code>。这就导致在两个<code>map</code>的间隙，会出现<code>pageref(pipe) == pageref(fd)</code>的情况。这个问题也可以通过调换两个map的顺序来解决。</li>
</ul>
<h3 id="Thinking-6-5"><a href="#Thinking-6-5" class="headerlink" title="Thinking 6.5"></a>Thinking 6.5</h3><ul>
<li>整体流程：分配文件标识符<code>fd</code>、按照路径打开文件、编辑文件标识符、匹配存储单元、返回文件标识符特征值。</li>
<li>读取加载方法：对于普通文件，我们需要编译形成<code>ELF</code>文件，之后才可以运行。</li>
<li>实现方式：对于bss段中和text&amp;data段共同占据一个页面的部分，分配页面并设置初值为0；对于bss段其它部分，仅使分配页面而不映射到任何内容。</li>
</ul>
<h3 id="Thinking-6-6"><a href="#Thinking-6-6" class="headerlink" title="Thinking 6.6"></a>Thinking 6.6</h3><ul>
<li><p>在<code>user/init.c</code>中完成，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stdin should be 0, because no file descriptors are open yet</span></span><br><span class="line"><span class="keyword">if</span> ((r = opencons()) != <span class="number">0</span>) &#123;</span><br><span class="line">	user_panic(<span class="string">&quot;opencons: %d&quot;</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// stdout</span></span><br><span class="line"><span class="keyword">if</span> ((r = dup(<span class="number">0</span>, <span class="number">1</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	user_panic(<span class="string">&quot;dup: %d&quot;</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Thinking-6-7"><a href="#Thinking-6-7" class="headerlink" title="Thinking 6.7"></a>Thinking 6.7</h3><ul>
<li>shell命令是外部命令，在执行shell命令时，进程通过<code>fork()</code>函数产生一个子进程，即子shell，之后子shell运行该命令所对应的可执行文件。</li>
<li>linux中的内部命令实际上是shell程序的一部分，其中包含一些比较简单的linux系统命令。这些命令由shell程序识别并在shell程序内部完成运行，通常在linux系统加载运行时shell就被加载并驻留在系统内存中。</li>
</ul>
<h3 id="Thinking-6-8"><a href="#Thinking-6-8" class="headerlink" title="Thinking 6.8"></a>Thinking 6.8</h3><ul>
<li>shell中进行了2次<code>spawn</code>，分别用于执行<code>ls.b</code>和<code>cat.b</code>；</li>
<li>shell中进行了2次进程销毁，这2个进程分别是shell执行<code>ls.b</code>和<code>cat.b</code>时通过<code>spawn</code>生成的子进程。</li>
</ul>
<h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><p>本次实验中，我遇到的难点主要有以下几点：</p>
<ul>
<li><p><code>pipe</code>相关的内存使用：本次实验中一个重点是管道的实现。出现管道时，为当前进程分出子进程，用父进程处理管道左端，用子进程处理管道右端。子进程和父进程的内存空间中分别为写端<code>fd</code>和读端<code>fd</code>分配了一个虚拟页，由于两个进程的<code>fork</code>关系，子进程和父进程的读端所在的虚拟页映射到了同一个物理页，同样他们的写端所在的虚拟也也都映射到了同一个物理页，因此可以实现读写的统一性。</p>
</li>
<li><p><code>spawn</code>函数：在该函数中，主要有6部分，分别是读取文件描述符<code>fd</code>、读取<code>ELF</code>文件头部、使用<code>fork</code>生成子进程、初始化子进程的数据栈、读取文件中的项目头部、读取并匹配文件的<code>ELF</code>数据、加载<code>segment</code>。各部分均需实现报错后的逐层输出。难点主要在于各部分函数的使用以及整体的实现逻辑。</p>
</li>
</ul>
<h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>Lab6主要让我们学习有关管道和<code>shell</code>的问题，了解MIPS系统中虚拟地址与物理地址的对应关系、多文件的读取与更改的内容。本次实验对比前几次lab内容较少，同时由于指导书和注释的详细，完成难度不大。但是由于前面lab遗留的前后程序不适配问题，导致出现bug且较难查明的问题，耗时较久。十分感谢助教学长的帮助和那些写博客的学长（虽然发现了两篇有所不同的博客，也没有尝试是否都是正确的），看了他们的博客后真的是茅塞顿开。作为最后一个常规lab，整个os学习也算是有始有终地完成了。整个学期下来困难很多，但是学到了很多知识和算法，提升也很大。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Mips</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Challenge-Shell任务文档</title>
    <url>/2025/03/15/OS/Challenge-Shell%E4%BB%BB%E5%8A%A1%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h1 id="Challenge-Shell任务文档"><a href="#Challenge-Shell任务文档" class="headerlink" title="Challenge-Shell任务文档"></a>Challenge-Shell任务文档</h1><hr>
<h2 id="实现不带-b-后缀指令"><a href="#实现不带-b-后缀指令" class="headerlink" title="实现不带 .b 后缀指令"></a>实现不带 <code>.b</code> 后缀指令</h2><blockquote>
<p>你需要实现不带 <code>.b</code> 后缀的指令，但仍需兼容带有 <code>.b</code> 后缀的指令，如 <code>ls</code> 与 <code>ls.b</code> 都应能够正确列出当前目录下的文件。</p>
</blockquote>
<p>外部指令的执行实际上是在<code>spawn</code>函数中打开可执行的指令文件创建新进程，并将其装载在新建子进程中，运行指令文件中的主程序。实现思路是更改文件打开程序，当文件名对应文件存在时直接打开即可，不存在时文件名末尾加<code>.b</code>再次尝试打开。</p>
<p>在<code>spawn()</code>函数中更改文件打开方式，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//user/lib/spawn.c spawn()</span></span><br><span class="line"><span class="keyword">if</span> ((fd = open(prog, O_RDONLY)) &lt; <span class="number">0</span>) <span class="comment">//尝试打开文件</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> newProg[<span class="number">128</span>];</span><br><span class="line">	<span class="keyword">for</span> (len = <span class="number">0</span>; len &lt; <span class="number">128</span> &amp;&amp; prog[len] != <span class="string">&#x27;\0&#x27;</span>; len++)</span><br><span class="line">	&#123;</span><br><span class="line">		newProg[len] = prog[len];</span><br><span class="line">	&#125;</span><br><span class="line">	newProg[len++] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">	newProg[len++] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">	newProg[len++] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">//若打开文件失败则在文件名尾加上.b并再次尝试</span></span><br><span class="line">	<span class="keyword">if</span> ((fd = open(newProg, O_RDONLY)) &lt; <span class="number">0</span>) <span class="comment">//再次尝试打开文件，若失败则证明不存在该指令，返回报错信息</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> fd;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="实现指令条件执行"><a href="#实现指令条件执行" class="headerlink" title="实现指令条件执行"></a>实现指令条件执行</h2><blockquote>
<p>你需要实现 Linux shell 中的 <code>&amp;&amp;</code> 与 <code>||</code>。 对于 <code>command1 &amp;&amp; command2</code>，<code>command2</code> 被执行当且仅当 <code>command1</code> 返回 0；对于 <code>command1 || command2</code>，<code>command2</code> 被执行当且仅当 <code>command1</code> 返回非 0 值。</p>
<blockquote>
<p>注: 评测中保证不出现括号。并且需要注意的是，在 bash 中 <code>&amp;&amp;</code> 与 <code>||</code> 的优先级相同，按照从左到右的顺序求值。</p>
<p>例如 <code>cmd1 || cmd2 &amp;&amp; cmd3</code>，若 <code>cmd1</code> 返回 0，则 <code>cmd1</code> 执行后 <code>cmd2</code> 不会被执行，<code>cmd3</code> 会被执行；若 <code>cmd1</code> 返回非 0 且 <code>cmd2</code> 返回非 0，则 <code>cmd3</code> 将不会被执行。</p>
<p>提示：你可能需要修改 MOS 中对用户进程 <code>exit</code> 的实现，使其能够返回值。</p>
</blockquote>
</blockquote>
<p>当<code>cmd</code>执行分为多层，会出现<code>parsercmd</code>进程，<code>runcmd</code>进程，而每种进程又有负责执行的子进程和整体的父进程。指令执行结束后，会返回执行结果，并退出进程。实现思路是将每个指令的执行结果发送给父进程，并在<code>parser</code>环节使用，总体上计算标志之前的全部指令运行结果，并判断是否执行当前指令。</p>
<p>在<code>include/env.h</code>的进程结构体中加入返回值定义，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line">	<span class="type">int</span> env_return_value; <span class="comment">//子进程返回值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在内核态中添加子进程返回值的系统调用函数，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//kern/syscall_all.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_return_value</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">	try(envid2env(curenv-&gt;env_parent_id, &amp;e, <span class="number">0</span>));</span><br><span class="line">	e-&gt;env_return_value = value; <span class="comment">//设置父进程获得的子进程返回值</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在用户态中添加相应的调用系统调用函数的信息发送函数，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//user/lib/syscall_lib.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">syscall_return_value</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> msyscall(SYS_return_value, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更改<code>exit()</code>函数，使其在退出进程的同时向父进程发送程序执行返回值，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//user/lib/libos.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(LAB) || LAB &gt;= 5</span></span><br><span class="line">	close_all();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	debugf(<span class="string">&quot;child: 0x%x send %d to parent: 0x%x\n&quot;</span>, env-&gt;env_id, value, env-&gt;env_parent_id);</span><br><span class="line">	syscall_return_value(value);</span><br><span class="line">	syscall_env_destroy(<span class="number">0</span>);</span><br><span class="line">	user_panic(<span class="string">&quot;unreachable code&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更改<code>libmain()</code>函数，使其获得程序执行结束的返回值，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//user/lib/libos.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">libmain</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">	env = &amp;envs[ENVX(syscall_getenvid())];</span><br><span class="line">	<span class="type">int</span> return_value = main(argc, argv); <span class="comment">//程序执行结果</span></span><br><span class="line">	<span class="built_in">exit</span>(return_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>_gettoken()</code>函数中增加运算符与<code>&amp;&amp;</code>和或<code>||</code>的解析，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//user/sh.c _gettoken()</span></span><br><span class="line"><span class="keyword">if</span> (*s == <span class="string">&#x27;&amp;&#x27;</span> &amp;&amp; *(s + <span class="number">1</span>) == <span class="string">&#x27;&amp;&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">	*p1 = s;</span><br><span class="line">	*s++ = <span class="number">0</span>;</span><br><span class="line">	*s++ = <span class="number">0</span>;</span><br><span class="line">	*p2 = s;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;y&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*s == <span class="string">&#x27;|&#x27;</span> &amp;&amp; *(s + <span class="number">1</span>) == <span class="string">&#x27;|&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">	*p1 = s;</span><br><span class="line">	*s++ = <span class="number">0</span>;</span><br><span class="line">	*s++ = <span class="number">0</span>;</span><br><span class="line">	*p2 = s;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;h&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更改<code>parsercmd()</code>函数的参数，使其可以传递上一个操作和之前全部命令执行结果，并增加与或运算的解析处理，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//user/sh.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parsecmd</span><span class="params">(<span class="type">char</span> **argv, <span class="type">int</span> *rightpipe, <span class="type">int</span> last, <span class="type">int</span> flag)</span> &#123; </span><br><span class="line">    <span class="comment">//last表示上一个运算符（0代表&amp;，1代表|），flag代表之前所有命令执行结果运算后的结果</span></span><br><span class="line">    <span class="comment">//解析时遇到的符号是带判断指令的后一个符号，因此需要传入上一个符号</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//user/sh.c parsercmd()</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;y&#x27;</span>:;</span><br><span class="line">			<span class="keyword">if</span> (last == <span class="number">0</span> &amp;&amp; flag != <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> parsecmd(argv, rightpipe, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">			&#125; <span class="comment">//如果上一个指令是&amp;且之前算式运算结果为false，则跳过</span></span><br><span class="line">			<span class="keyword">if</span> (last == <span class="number">1</span> &amp;&amp; flag == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> parsecmd(argv, rightpipe, <span class="number">0</span>, flag);</span><br><span class="line">			&#125; <span class="comment">//如果上一个指令是|且之前算式运算结果为true，则跳过</span></span><br><span class="line">			r  = fork();</span><br><span class="line">			<span class="keyword">if</span> (r == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> argc;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				wait(r);</span><br><span class="line">				<span class="keyword">if</span> (!iscons(<span class="number">1</span>))</span><br><span class="line">				&#123;</span><br><span class="line">					dup(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (!iscons(<span class="number">0</span>))</span><br><span class="line">				&#123;</span><br><span class="line">					dup(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="type">int</span> nextFlag = 	(last == <span class="number">2</span>) ? env-&gt;env_return_value :</span><br><span class="line">								(last == <span class="number">0</span> &amp;&amp; (flag == <span class="number">0</span> &amp;&amp; env-&gt;env_return_value == <span class="number">0</span>)) ? <span class="number">0</span> :</span><br><span class="line">								(last == <span class="number">1</span> &amp;&amp; (flag == <span class="number">0</span> || env-&gt;env_return_value == <span class="number">0</span>)) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">return</span> parsecmd(argv, rightpipe, <span class="number">0</span>, nextFlag);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:;</span><br><span class="line">			<span class="keyword">if</span> (last == <span class="number">0</span> &amp;&amp; flag != <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> parsecmd(argv, rightpipe, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (last == <span class="number">1</span> &amp;&amp; flag == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> parsecmd(argv, rightpipe, <span class="number">1</span>, flag);</span><br><span class="line">			&#125;</span><br><span class="line">			r = fork();</span><br><span class="line">			<span class="keyword">if</span> (r == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> argc;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				wait(r);</span><br><span class="line">				<span class="keyword">if</span> (!iscons(<span class="number">1</span>))</span><br><span class="line">				&#123;</span><br><span class="line">					dup(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (!iscons(<span class="number">0</span>))</span><br><span class="line">				&#123;</span><br><span class="line">					dup(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="type">int</span> nextFlag = 	(last == <span class="number">2</span>) ? env-&gt;env_return_value :</span><br><span class="line">								(last == <span class="number">0</span> &amp;&amp; (flag == <span class="number">0</span> &amp;&amp; env-&gt;env_return_value == <span class="number">0</span>)) ? <span class="number">0</span> :</span><br><span class="line">								(last == <span class="number">1</span> &amp;&amp; (flag == <span class="number">0</span> || env-&gt;env_return_value == <span class="number">0</span>)) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">return</span> parsecmd(argv, rightpipe, <span class="number">1</span>, nextFlag);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>更改<code>parsercmd()</code>函数的参数后，还应更改其余解析位置的<code>return parsecmd(argv, rightpipe, lastOp, flag)</code>。应注意，管道处传递时应该保持上一次的符号和之前的结果。</p>
<p>在<code>runcmd()</code>函数中更改<code>exit()</code>的返回值以及<code>parsercmd()</code>的参数，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//user/sh.c runcmd()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">runcmd</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">	gettoken(s, <span class="number">0</span>);</span><br><span class="line">	<span class="type">char</span> *argv[MAXARGS];</span><br><span class="line">	<span class="type">int</span> rightpipe = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> argc = parsecmd(argv, &amp;rightpipe, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (argc == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	argv[argc] = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> child = spawn(argv[<span class="number">0</span>], argv);</span><br><span class="line">	close_all();</span><br><span class="line">	<span class="keyword">if</span> (child &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		wait(child);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		debugf(<span class="string">&quot;spawn %s: %d\n&quot;</span>, argv[<span class="number">0</span>], child);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (rightpipe) &#123;</span><br><span class="line">		wait(rightpipe);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(env-&gt;env_return_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="实现更多指令"><a href="#实现更多指令" class="headerlink" title="实现更多指令"></a>实现更多指令</h2><blockquote>
<p>你需要实现 <code>touch</code>，<code>mkdir</code>，<code>rm</code> 指令，只需要考虑如下情形：</p>
<ul>
<li><code>touch</code>:</li>
</ul>
<blockquote>
<ul>
<li><code>touch &lt;file&gt;</code>：创建空文件 <code>file</code>，若文件存在则放弃创建，正常退出无输出。 若创建文件的父目录不存在则输出 <code>touch: cannot touch &#39;&lt;file&gt;&#39;: No such file or directory</code>。 例如 <code>touch nonexistent/dir/a.txt</code> 时应输出 <code>touch: cannot touch &#39;nonexistent/dir/a.txt&#39;: No such file or directory</code>。</li>
</ul>
</blockquote>
<ul>
<li><code>mkdir</code>:</li>
</ul>
<blockquote>
<ul>
<li><code>mkdir &lt;dir&gt;</code>：若目录已存在则输出 <code>mkdir: cannot create directory &#39;&lt;dir&gt;&#39;: File exists</code>，若创建目录的父目录不存在则输出 <code>mkdir: cannot create directory &#39;&lt;dir&gt;&#39;: No such file or directory</code>，否则正常创建目录。</li>
<li><code>mkdir -p &lt;dir&gt;</code>：当使用 <code>-p</code> 选项时忽略错误，若目录已存在则直接退出，若创建目录的父目录不存在则递归创建目录。</li>
</ul>
</blockquote>
<ul>
<li><code>rm</code>:</li>
</ul>
<blockquote>
<ul>
<li><code>rm &lt;file&gt;</code>：若文件存在则删除 <code>&lt;file&gt;</code>，否则输出 <code>rm: cannot remove &#39;&lt;file&gt;&#39;: No such file or directory</code>。</li>
<li><code>rm &lt;dir&gt;</code>：命令行输出: <code>rm: cannot remove &#39;&lt;dir&gt;&#39;: Is a directory</code>。</li>
<li><code>rm -r &lt;dir&gt;|&lt;file&gt;</code>：若文件或文件夹存在则删除，否则输出 <code>rm: cannot remove &#39;&lt;dir&gt;|&lt;file&gt;&#39;: No such file or directory</code>。</li>
<li><code>rm -rf &lt;dir&gt;|&lt;file&gt;</code>：如果对应文件或文件夹存在则删除，否则直接退出。</li>
</ul>
</blockquote>
</blockquote>
<p>文件的增删主要在内核态进行，因此构建新的<code>serv</code>函数，用于创建和删除文件。实现思路是在用户态创建相应<code>fsipc</code>函数，并使用<code>ipc</code>向<code>fs</code>发送消息进行调用，在内核态创建对应服务函数，调用最底层的<code>file</code>相关函数实现文件的构建与删除。创建指令文件<code>touch.c</code>、<code>mkdir.c</code>、<code>rm.c</code>，并实现相应程序。</p>
<p>在<code>fs</code>中创建新的底层文件操作函数，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fs/fs.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_create</span><span class="params">(<span class="type">char</span> *path, <span class="keyword">struct</span> File **file)</span> &#123;</span><br><span class="line">	<span class="type">char</span> name[MAXNAMELEN];</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">dir</span>, *<span class="title">f</span>;</span></span><br><span class="line">	<span class="keyword">if</span> ((r = walk_path(path, &amp;dir, &amp;f, name)) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_FILE_EXISTS;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (r != -E_NOT_FOUND || dir == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dir_alloc_file(dir, &amp;f) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">strcpy</span>(f-&gt;f_name, name);</span><br><span class="line">	*file = f;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_remove</span><span class="params">(<span class="type">char</span> *path)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f</span>;</span></span><br><span class="line">	<span class="keyword">if</span> ((r = walk_path(path, <span class="number">0</span>, &amp;f, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	file_truncate(f, <span class="number">0</span>);</span><br><span class="line">	f-&gt;f_name[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	file_flush(f);</span><br><span class="line">	<span class="keyword">if</span> (f-&gt;f_dir) &#123;</span><br><span class="line">		file_flush(f-&gt;f_dir);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">//remove的函数之前已经构建，可以直接使用</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_noDir_remove</span><span class="params">(<span class="type">char</span> *path)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f</span>;</span></span><br><span class="line">	<span class="keyword">if</span> ((r = walk_path(path, <span class="number">0</span>, &amp;f, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (f-&gt;f_type == FTYPE_DIR)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> -E_RM_DIR;</span><br><span class="line">	&#125; <span class="comment">//当待删除文件是</span></span><br><span class="line">	file_truncate(f, <span class="number">0</span>);</span><br><span class="line">	f-&gt;f_name[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	file_flush(f);</span><br><span class="line">	<span class="keyword">if</span> (f-&gt;f_dir) &#123;</span><br><span class="line">		file_flush(f-&gt;f_dir);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">//remove的函数之前已经构建，可以直接使用，此函数的区别是不能删除文件夹</span></span><br></pre></td></tr></table></figure>
<p>在<code>user/include/fsreq.h</code>中构建增删文件传递信号的相应结构体，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> <span class="comment">//创建信号宏定义</span></span><br><span class="line">	...</span><br><span class="line">	FSREQ_CREATE,</span><br><span class="line">    FSREQ_REMOVE, <span class="comment">//代表任意文件</span></span><br><span class="line">	FSREQ_NDREMOVE,</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_remove</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> req_path[MAXPATHLEN];</span><br><span class="line">	<span class="type">int</span> rm_type;</span><br><span class="line">&#125;; <span class="comment">//remove的结构体之前已经构建，可以直接使用</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_create</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> req_path[MAXPATHLEN];</span><br><span class="line">	<span class="type">uint32_t</span> f_type; <span class="comment">//代表文件类型，普通文件或文件夹</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在<code>fs</code>中创建新的服务函数，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fs/serv.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">serve_create</span><span class="params">(u_int envid, <span class="keyword">struct</span> Fsreq_create *rq)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f</span>;</span></span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	r = file_create(rq-&gt;req_path, &amp;f); <span class="comment">//调用文件创造函数</span></span><br><span class="line">	<span class="keyword">if</span> (r &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	f-&gt;f_type = rq-&gt;f_type;</span><br><span class="line">	ipc_send(envid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">serve_remove</span><span class="params">(u_int envid, <span class="keyword">struct</span> Fsreq_remove *rq)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	r = file_remove(rq-&gt;req_path);</span><br><span class="line">	ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125; <span class="comment">//remove的函数之前已经构建，可以直接使用</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">serve_noDir_remove</span><span class="params">(u_int envid, <span class="keyword">struct</span> Fsreq_remove *rq)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	r = file_noDir_remove(rq-&gt;req_path);</span><br><span class="line">	ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125; <span class="comment">//remove的函数之前已经构建，可以直接使用，此函数的区别是不能删除文件夹</span></span><br></pre></td></tr></table></figure>
<p>在用户态下创建对应<code>fsipc</code>函数，用于<code>ipc</code>信号发送，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//user/lib/fsipc.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fsipc_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">uint32_t</span> type)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_create</span> *<span class="title">req</span>;</span></span><br><span class="line">	req = (<span class="keyword">struct</span> Fsreq_create *)fsipcbuf;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strlen</span>(path) &gt;= MAXPATHLEN) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">strcpy</span>((<span class="type">char</span> *)req-&gt;req_path, path);</span><br><span class="line">	req-&gt;f_type = type;</span><br><span class="line">	<span class="keyword">return</span> fsipc(FSREQ_CREATE, req, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fsipc_remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strlen</span>(path) == <span class="number">0</span> || <span class="built_in">strlen</span>(path) &gt; MAXPATHLEN)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_remove</span> *<span class="title">req</span> =</span> (<span class="keyword">struct</span> Fsreq_remove *)fsipcbuf;</span><br><span class="line">	<span class="built_in">strcpy</span>((<span class="type">char</span> *)req-&gt;req_path, path);</span><br><span class="line">	<span class="keyword">return</span> fsipc(FSREQ_REMOVE, req, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fsipc_noDir_remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strlen</span>(path) == <span class="number">0</span> || <span class="built_in">strlen</span>(path) &gt; MAXPATHLEN)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_remove</span> *<span class="title">req</span> =</span> (<span class="keyword">struct</span> Fsreq_remove *)fsipcbuf;</span><br><span class="line">	<span class="built_in">strcpy</span>((<span class="type">char</span> *)req-&gt;req_path, path);</span><br><span class="line">	<span class="keyword">return</span> fsipc(FSREQ_NDREMOVE, req, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在用户态创建具体文件操作函数，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//user/lib/file.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">uint32_t</span> type)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fsipc_create(path, type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fsipc_remove(path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">nd_remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fsipc_noDir_remove(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建三个命令文件，调用文件操作函数，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//user/touch.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    r = create(argv[<span class="number">1</span>], FTYPE_REG);</span><br><span class="line">	<span class="keyword">if</span> (r &lt; <span class="number">0</span> &amp;&amp; r != -E_FILE_EXISTS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;touch: cannot touch &#x27;%s&#x27;: No such file or directory\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//user/mkdir.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r = create(argv[<span class="number">1</span>], FTYPE_DIR);</span><br><span class="line">        <span class="keyword">if</span> (r == -E_FILE_EXISTS)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;mkdir: cannot create directory &#x27;%s&#x27;: File exists\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (r &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;mkdir: cannot create directory &#x27;%s&#x27;: No such file or directory\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> name[MAXPATHLEN] = &#123;&#125;;</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> *c = argv[<span class="number">2</span>]; *c != <span class="string">&#x27;\0&#x27;</span>; c++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (*c == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                name[pos] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                r = create(name, FTYPE_DIR);</span><br><span class="line">                name[pos] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                name[pos] = *c;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (name[pos] != <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            name[pos] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            r = create(name, FTYPE_DIR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">//-p类型迭代建立文件夹</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//user/rm.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r = nd_remove(argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (r == -E_RM_DIR)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;rm: cannot remove &#x27;%s&#x27;: Is a directory\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (r &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;rm: cannot remove &#x27;%s&#x27;: No such file or directory\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;-r&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            r = remove(argv[<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">if</span> (r &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;rm: cannot remove &#x27;%s&#x27;: No such file or directory\n&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            r = remove(argv[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">//-r-rf类型，可以删除文件夹</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="实现反引号"><a href="#实现反引号" class="headerlink" title="实现反引号"></a>实现反引号</h2><blockquote>
<p>你需要使用反引号实现指令替换。只需要考虑 <code>echo</code> 进行的输出，你需要将反引号内指令执行的所有标准输出替换为 <code>echo</code> 的参数。</p>
</blockquote>
<p>题目只需考虑<code>echo</code>指令的反引号输出，其等同于直接执行反引号内指令。实现思路是在指令解析环节，如果遇到反引号，则将当前解析的<code>argv</code>数组退格，重新解析<code>cmd</code>。</p>
<p>在<code>_gettoken()</code>函数中增加反引号的解析，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//user/sh.c _gettoken()</span></span><br><span class="line"><span class="keyword">if</span> (*s == <span class="string">&#x27;`&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">	*p1 = s;</span><br><span class="line">	*s++ = <span class="number">0</span>;</span><br><span class="line">	*p2 = s;</span><br><span class="line">	<span class="type">char</span> *str = s;</span><br><span class="line">	<span class="keyword">for</span> (; *str &amp;&amp; *str != <span class="string">&#x27;`&#x27;</span>; str++);</span><br><span class="line">	<span class="keyword">if</span> (*str == <span class="string">&#x27;`&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		*str = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;`&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>parsercmd()</code>函数中增加反引号的解析处理，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//user/sh.c parsercmd()</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;`&#x27;</span>:</span><br><span class="line">	<span class="keyword">if</span> ((gettoken(<span class="number">0</span>, &amp;t)) != <span class="string">&#x27;w&#x27;</span>) &#123;</span><br><span class="line">		debugf(<span class="string">&quot;syntax error: ` not followed by word\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125; <span class="comment">//如果反引号后不是指令，则报错并退出</span></span><br><span class="line">	argv[argc - <span class="number">1</span>] = t;</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="实现注释功能"><a href="#实现注释功能" class="headerlink" title="实现注释功能"></a>实现注释功能</h2><blockquote>
<p>你需要使用 <code>#</code> 实现注释功能，例如 <code>ls | cat # this is a comment meow</code>，<code>ls | cat</code> 会被正确执行，而后面的注释则会被抛弃。</p>
</blockquote>
<p>对于一行多条指令，注释符优先级最高，<code>#</code>之后的指令均不需要解析或执行。实现思路是在指令解析环节，如果遇到注释符号，使用<code>fork</code>函数创建子进程，并使用子进程返回之前解析出的命令，主进程等待子进程解析完毕后直接退出。</p>
<p>在<code>parsercmd()</code>函数中增加注释符的解析处理，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//user/sh.c parsercmd()</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">	r = fork();</span><br><span class="line">	<span class="keyword">if</span> (r == <span class="number">0</span>) <span class="comment">//r是子进程，则返回解析的argc</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> argc;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		wait(r);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="实现历史指令"><a href="#实现历史指令" class="headerlink" title="实现历史指令"></a>实现历史指令</h2><blockquote>
<p>你需要实现 shell 中保存历史指令的功能，可以通过 <code>Up</code> 和 <code>Down</code> 选择所保存的指令并执行。你需要将历史指令保存到根目录的 <code>.mosh_history</code> 文件中（一条指令一行），为了评测的方便，我们设定 <code>$HISTFILESIZE=20</code>（bash 中默认为 500），即在 <code>.mosh_history</code> 中至多保存最近的 20 条指令。你还需要支持通过 <code>history</code> 命令输出 <code>.mosh_history</code> 文件中的内容。</p>
<blockquote>
<p>注：在 bash 中，<code>history</code> 为 shell built-in command，我们规定需要将 <code>history</code> 实现为 built-in command。</p>
</blockquote>
</blockquote>
<p>实现历史指令可以在用户态建立数组，存储当前指令、当前指令数目、当前光标位置，在访问时进行使用。具体思路是创建相关全局变量，并在命令解析环节按照输入的方向键调整光标以及控制台输出，实现历史指令的输出与执行。</p>
<p>在<code>user/sh.c</code>中定义相关变量，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//user/sh.c</span></span><br><span class="line"><span class="type">int</span> nCmds = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> lenCmds[<span class="number">500</span>];</span><br><span class="line"><span class="type">int</span> index;</span><br><span class="line"><span class="type">char</span> curCmd[<span class="number">1024</span>];</span><br></pre></td></tr></table></figure>
<p>在<code>user/sh.c</code>中创建相关的存取指令函数，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//user/sh.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">saveCmd</span><span class="params">(<span class="type">char</span> *cmd)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r, fd;</span><br><span class="line">	<span class="keyword">if</span> ((r = open(<span class="string">&quot;/.mosh_history&quot;</span>, O_WRONLY | O_APPEND)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ((r = create(<span class="string">&quot;/.mosh_history&quot;</span>, FTYPE_REG)) &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			user_panic(<span class="string">&quot;failed to create .mosh_history\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ((r = open(<span class="string">&quot;/.mosh_history&quot;</span>, O_WRONLY | O_APPEND)) &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			user_panic(<span class="string">&quot;failed to open .mosh_history\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="comment">//尝试打开.mosh_history文件，如果该文件不存在则新建</span></span><br><span class="line">	fd = r;</span><br><span class="line">	<span class="keyword">if</span> ((r = write(fd, cmd, <span class="built_in">strlen</span>(cmd))) != <span class="built_in">strlen</span>(cmd))</span><br><span class="line">	&#123;</span><br><span class="line">		user_panic(<span class="string">&quot;fail to write cmd in .mosh_history\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((r = write(fd, <span class="string">&quot;\n&quot;</span>, <span class="number">1</span>)) != <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		user_panic(<span class="string">&quot;fail to write \n in .mosh_history\n&quot;</span>);</span><br><span class="line">	&#125; <span class="comment">//向.mosh_history文件写入指令并换行</span></span><br><span class="line">	lenCmds[nCmds] = <span class="built_in">strlen</span>(cmd) + <span class="number">1</span>;</span><br><span class="line">	nCmds++;</span><br><span class="line">	close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getCmd</span><span class="params">(<span class="type">int</span> serial, <span class="type">char</span> *cmd)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r, fd;</span><br><span class="line">	<span class="type">char</span> buf[MAXFILESIZE];</span><br><span class="line">	<span class="keyword">if</span> ((r = open(<span class="string">&quot;/.mosh_history&quot;</span>, O_RDONLY)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		user_panic(<span class="string">&quot;failed to open .mosh_history\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	fd = r;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; serial; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ((r = read(fd, buf, lenCmds[i])) != lenCmds[i])</span><br><span class="line">		&#123;</span><br><span class="line">			user_panic(<span class="string">&quot;failed to read line%d of .mosh_history\n&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="comment">//读取serial前的内容，摒弃</span></span><br><span class="line">	<span class="keyword">if</span> ((r = read(fd, cmd, lenCmds[serial])) != lenCmds[serial])</span><br><span class="line">	&#123;</span><br><span class="line">		user_panic(<span class="string">&quot;failed to read serial line of .mosh_history\n&quot;</span>);</span><br><span class="line">	&#125; <span class="comment">//读取序号为serial的内容，并将其写入cmd数组中</span></span><br><span class="line">	cmd[lenCmds[serial] - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在解析指令环节增加<code>savecmd()</code>的函数，应注意全局变量的使用要求处于同一进程内，因此需要将其放置在主解析进程中，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//user/sh.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		...</span><br><span class="line">		readline(buf, <span class="keyword">sizeof</span> buf);</span><br><span class="line">		<span class="keyword">if</span> (buf[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>) saveCmd(buf);</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在解析一行指令环节添加对于上下键带来的光标以及控制台显示操作，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//user/sh.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">readline</span><span class="params">(<span class="type">char</span> *buf, u_int n)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r, lastLen;</span><br><span class="line">	index = nCmds; <span class="comment">//保证每次输入指令时索引都指向当前指令</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">if</span> (buf[i] == <span class="string">&#x27;\b&#x27;</span> || buf[i] == <span class="number">0x7f</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (buf[i] == <span class="string">&#x27;\033&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">switch</span> (getDirect())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;\033[1B&quot;</span>); <span class="comment">//向下进行一格以抵消向上</span></span><br><span class="line">					<span class="keyword">if</span> (index == nCmds)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="built_in">strcpy</span>(curCmd, buf); <span class="comment">//记录输入的最后一条指令</span></span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (index &gt; <span class="number">0</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						index--;</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;\033[2K&quot;</span>); <span class="comment">//删除当前本行的输出显示</span></span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;\033[%dD&quot;</span>, lastLen); <span class="comment">//移动光标</span></span><br><span class="line">						getCmd(index, buf);</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">						lastLen = <span class="built_in">strlen</span>(buf);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;\033[1A&quot;</span>);</span><br><span class="line">					<span class="keyword">if</span> (index &lt; nCmds)</span><br><span class="line">					&#123;</span><br><span class="line">						index++;</span><br><span class="line">						<span class="keyword">if</span> (index == nCmds)</span><br><span class="line">						&#123;</span><br><span class="line">							<span class="built_in">strcpy</span>(buf, curCmd);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span></span><br><span class="line">						&#123;</span><br><span class="line">							getCmd(index, buf);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;\033[2K&quot;</span>);</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;\033[%dD&quot;</span>, lastLen);</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">						lastLen = <span class="built_in">strlen</span>(buf);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> </span><br><span class="line">					&#123;</span><br><span class="line">						<span class="built_in">strcpy</span>(buf, curCmd);</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;\033[2K&quot;</span>);</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;\033[%dD&quot;</span>, lastLen);</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">						lastLen = <span class="built_in">strlen</span>(buf);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getDirect</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">char</span> temp1, temp2;</span><br><span class="line">	read(<span class="number">0</span>, &amp;temp1, <span class="number">1</span>);</span><br><span class="line">	read(<span class="number">0</span>, &amp;temp2, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (temp1 == <span class="string">&#x27;[&#x27;</span>) <span class="keyword">return</span> temp2; <span class="comment">//\033[A表示上键，\033[B表示下键</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>runcmd()</code>函数中添加内置指令<code>history</code>，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//user/sh.c runcmd()</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;history&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> r, fd;</span><br><span class="line">	<span class="type">char</span> buf;</span><br><span class="line">       <span class="keyword">if</span> ((r = open(<span class="string">&quot;/.mosh_history&quot;</span>, O_RDONLY)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		user_panic(<span class="string">&quot;fail to open file : .mosh_history\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	fd = r;</span><br><span class="line">	<span class="keyword">while</span> ((r = read(fd, &amp;buf, <span class="number">1</span>)) == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, buf);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="实现一行多指令"><a href="#实现一行多指令" class="headerlink" title="实现一行多指令"></a>实现一行多指令</h2><blockquote>
<p>你需要实现使用 <code>;</code> 将多条指令隔开从而从左至右依顺序执行每条指令的功能。</p>
</blockquote>
<p>对于一行多指令，在解析过程中，应该<code>fork</code>出多个子进程，并行解析处理指令，并返回给<code>runcmd</code>进程，进行执行操作。实现思路是在指令解析环节，如果遇到<code>;</code>，使用<code>fork</code>函数创建子进程，并使用子进程返回之前解析出的命令，主进程等待子进程解析完毕后继续执行解析操作，直至结束。</p>
<p>在<code>parsercmd()</code>函数中增加多指令标识符<code>;</code>的解析处理，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//user/sh.c parsercmd()</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;;&#x27;</span>:</span><br><span class="line">	r = fork();</span><br><span class="line">	<span class="keyword">if</span> (r == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> argc;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		wait(r);</span><br><span class="line">		<span class="keyword">if</span> (!iscons(<span class="number">1</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			dup(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!iscons(<span class="number">0</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			dup(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">		&#125; <span class="comment">//在实现过程中，发现遇到重定向会产生输入位置混乱的现象，因此调整device的输入位置</span></span><br><span class="line">		<span class="keyword">return</span> parsecmd(argv, rightpipe, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="实现追加重定向"><a href="#实现追加重定向" class="headerlink" title="实现追加重定向"></a>实现追加重定向</h2><blockquote>
<p>你需要实现 shell 中 <code>&gt;&gt;</code> 追加重定向的功能，即在文件末尾进行追加输入。</p>
</blockquote>
<p>追加重定向的实现与重定向基本一致，只需要更改文件的打开权限，定义追加权限即可。实现思路是新定义追加权限，在重定向打开文件时给予追加权限，以使其可以在原文件内容上进行追加输入。</p>
<p>在<code>serve_open()</code>函数中，增加追加权限打开操作，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fs/serv.c serve_open()</span></span><br><span class="line"><span class="keyword">if</span>((rq-&gt;req_omode &amp; O_APPEND) == O_APPEND) </span><br><span class="line">&#123;</span><br><span class="line">	ff-&gt;f_fd.fd_offset = ff-&gt;f_file.f_size; <span class="comment">//当打开方式是扩展时修改偏移量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>_gettoken()</code>函数中增加追加重定向的解析，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//user/sh.c _gettoken()</span></span><br><span class="line"><span class="keyword">if</span> (*s == <span class="string">&#x27;&gt;&#x27;</span> &amp;&amp; *(s + <span class="number">1</span>) == <span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">	*p1 = s;</span><br><span class="line">	*s++ = <span class="number">0</span>;</span><br><span class="line">	*s++ = <span class="number">0</span>;</span><br><span class="line">	*p2 = s;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>parsercmd()</code>函数中增加追加重定向的解析处理，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//user/sh.c parsercmd()</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">	<span class="keyword">if</span> ((gettoken(<span class="number">0</span>, &amp;t)) != <span class="string">&#x27;w&#x27;</span>) &#123;</span><br><span class="line">		debugf(<span class="string">&quot;syntax error: &gt;&gt; not followed by word\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((r = open(t, O_RDWR | O_APPEND)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ((r = create(t, FTYPE_REG)) &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			debugf(<span class="string">&quot;failed to create %s in &gt;&gt;\n&quot;</span>, t);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ((r = open(t, O_RDWR | O_APPEND)) &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			debugf(<span class="string">&quot;failed to open %s in &gt;&gt;\n&quot;</span>, t);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fd = r;</span><br><span class="line">	dup(fd, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> ((r = close(fd)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="实现引号支持"><a href="#实现引号支持" class="headerlink" title="实现引号支持"></a>实现引号支持</h2><blockquote>
<p>你需要实现引号支持，比如 <code>echo &quot;ls &gt;&quot;</code>，shell 在解析时需要将双引号内的内容看作是单个字符串。</p>
</blockquote>
<p>在解析环节中，数组<code>argv</code>中存储的是各个<code>w</code>，如在<code>echo aaa</code>中就会有两个<code>w: &quot;echo&quot; &quot;aaa&quot;</code>。将双引号及其内部内容解析为一个<code>w</code>，即可将其看作单个字符串。实现思路是在解析过程中，遇到双引号时，开始存储，直到遇到下一个双引号，并将之中的内容当作一个整体存储到<code>argv</code>数组中，供运行阶段使用。</p>
<p>在<code>_gettoken()</code>函数中增加双引号的解析，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//user/sh.c _gettoken()</span></span><br><span class="line"><span class="keyword">if</span> (*s == <span class="string">&#x27;\&quot;&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">	s++;</span><br><span class="line">	*p1 = s;</span><br><span class="line">	<span class="keyword">while</span> (*s &amp;&amp; *s != <span class="string">&#x27;\&quot;&#x27;</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		s++;</span><br><span class="line">	&#125;</span><br><span class="line">	*s = <span class="number">0</span>;</span><br><span class="line">	s++;</span><br><span class="line">	*p2 = s; <span class="comment">//需注意，p2代表下一个token的起始位置</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;w&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="实现前后台任务管理"><a href="#实现前后台任务管理" class="headerlink" title="实现前后台任务管理"></a>实现前后台任务管理</h2><blockquote>
<ul>
<li>你需要支持 mosh 运行后台进程，当命令的末尾添加上 <code>&amp;</code> 符号时，该命令应该在后台执行。</li>
<li>实现 <code>jobs</code> 指令列出当前 shell 中所有后台任务的状态。你需要为任务创建 ID（每次启动 mosh 时，任务从 1 开始编号，每个新增任务编号应加 1），并且通过 <code>jobs</code> 指令输出包括：任务 ID（<code>job_id</code>）、任务的运行状态（<code>status</code>：可能的取值为 <code>Running</code>，<code>Done</code>）、任务的进程 ID（<code>env_id</code>）与运行任务时输入的指令（<code>cmd</code>）。请以 <code>printf(&quot;[%d] %-10s 0x%08x %s&quot;, job_id, status, env_id, cmd)</code> 的格式进行输出。</li>
<li>实现 <code>fg</code> 将后台任务带回前台继续运行，用户通过 <code>fg &lt;job_id&gt;</code> 的方式将对应任务带回前台。</li>
<li>实现 <code>kill</code> 指令，用户通过 <code>kill &lt;job_id&gt;</code> 来实现结束后台任务。</li>
</ul>
<p>在 <code>fg</code> 或 <code>kill</code> 指令中，若 <code>job_id</code> 对应的后台任务不存在则输出 <code>printf(&quot;fg/kill: job (%d) do not exist\n&quot;, job_id)</code>，若 <code>job_id</code> 对应的 ID 为 <code>envid</code> 的进程状态不为 <code>Running</code> 则输出 <code>printf(&quot;fg/kill: (0x%08x) not running\n&quot;, envid)</code>。</p>
</blockquote>
<p>前后台任务管理主要是在内核态中进行，实现<code>jobs</code>指令时获取全部任务信息，实现<code>fg</code>指令时将任务调至前台等待其完成，实现<code>kill</code>指令时将任务进程结束。实现思路是在内核态中建立结构体数组，并创建系统调用函数，实现任务的管理与展示。</p>
<p>在<code>include/env.h</code>中定义任务结构体，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//include/env.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Job</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> job_id;</span><br><span class="line">    <span class="type">int</span> env_id;</span><br><span class="line">    <span class="type">char</span> status[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> cmd[<span class="number">1024</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在<code>kern/syscall_all.c</code>中实现系统调用函数，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//kern/syscall_all.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_job_list</span><span class="params">(<span class="keyword">struct</span> Job <span class="built_in">list</span>[], <span class="type">int</span> *num)</span> &#123;</span><br><span class="line">	*num = nJobs;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nJobs; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">list</span>[i] = jobs[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_job_begin</span><span class="params">(u_int env_id, <span class="type">char</span> cmd[])</span> &#123;</span><br><span class="line">	jobs[nJobs].job_id = nJobs + <span class="number">1</span>;</span><br><span class="line">	jobs[nJobs].env_id = env_id;</span><br><span class="line">	<span class="built_in">strcpy</span>(jobs[nJobs].status, <span class="string">&quot;Running&quot;</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(jobs[nJobs].cmd, cmd);</span><br><span class="line">	nJobs++;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_job_end</span><span class="params">(u_int env_id)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nJobs; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (jobs[i].env_id == env_id)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">strcpy</span>(jobs[i].status, <span class="string">&quot;Done&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_job_turn</span><span class="params">(<span class="type">int</span> job_id, <span class="type">int</span> *env_id)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (job_id &lt; <span class="number">0</span> || job_id &gt; nJobs)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> -E_NO_JOB;</span><br><span class="line">	&#125; <span class="comment">//新定义错误没有该任务</span></span><br><span class="line">	<span class="type">int</span> curenv_id = jobs[job_id - <span class="number">1</span>].env_id;</span><br><span class="line">	*env_id = curenv_id;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(jobs[job_id - <span class="number">1</span>].status, <span class="string">&quot;Running&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> -E_NO_RUNJOB;</span><br><span class="line">	&#125; <span class="comment">//新定义错误该任务不处于运行状态</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">	try(envid2env(curenv_id, &amp;e, <span class="number">0</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_job_kill</span><span class="params">(<span class="type">int</span> job_id, <span class="type">int</span> *env_id)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (job_id &lt; <span class="number">0</span> || job_id &gt; nJobs)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> -E_NO_JOB;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> curenv_id = jobs[job_id - <span class="number">1</span>].env_id;</span><br><span class="line">	*env_id = curenv_id;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(jobs[job_id - <span class="number">1</span>].status, <span class="string">&quot;Running&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> -E_NO_RUNJOB;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">strcpy</span>(jobs[job_id - <span class="number">1</span>].status, <span class="string">&quot;Done&quot;</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">	try(envid2env(curenv_id, &amp;e, <span class="number">0</span>));</span><br><span class="line">	printk(<span class="string">&quot;[%08x] destroying %08x\n&quot;</span>, curenv-&gt;env_id, e-&gt;env_id);</span><br><span class="line">	env_destroy(e);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_cgetc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> ch;</span><br><span class="line">	ch = scancharc();</span><br><span class="line">	<span class="keyword">return</span> ch;</span><br><span class="line">&#125; <span class="comment">//需要调整原本的cgetc函数，去除无输入下的忙等待</span></span><br></pre></td></tr></table></figure>
<p>在用户态中添加相应的调用系统调用函数的信息发送函数，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//kern/syscall_lib.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">syscall_job_list</span><span class="params">(<span class="keyword">struct</span> Job <span class="built_in">list</span>[], <span class="type">int</span> *num)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> msyscall(SYS_job_list, <span class="built_in">list</span>, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">syscall_job_begin</span><span class="params">(u_int env_id, <span class="type">char</span> cmd[])</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> msyscall(SYS_job_begin, env_id, cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">syscall_job_end</span><span class="params">(u_int env_id)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> msyscall(SYS_job_end, env_id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">syscall_job_turn</span><span class="params">(<span class="type">int</span> job_id, <span class="type">int</span> *env_id)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> msyscall(SYS_job_turn, job_id, env_id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">syscall_job_kill</span><span class="params">(<span class="type">int</span> job_id, <span class="type">int</span> *env_id)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> msyscall(SYS_job_kill, job_id, env_id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">syscall_cgetc</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> ch;</span><br><span class="line">	<span class="keyword">while</span> ((ch = msyscall(SYS_cgetc)) == <span class="number">0</span>) &#123;</span><br><span class="line">		syscall_yield();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ch;</span><br><span class="line">&#125; <span class="comment">//需要调整原本的cgetc函数，去除无输入下的忙等待</span></span><br></pre></td></tr></table></figure>
<p>在<code>parsercmd()</code>函数中增加后台任务的解析处理，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//user/sh.c parsercmd()</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;&amp;&#x27;</span>:</span><br><span class="line">	r = fork();</span><br><span class="line">	<span class="keyword">if</span> (r == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ((last == <span class="number">0</span> &amp;&amp; flag != <span class="number">0</span>) || (last == <span class="number">1</span> &amp;&amp; flag == <span class="number">0</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> argc;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!iscons(<span class="number">1</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			dup(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!iscons(<span class="number">0</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			dup(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> parsecmd(argv, rightpipe, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">	&#125; <span class="comment">//父进程不需要等待执行解析的子进程</span></span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>在<code>runcmd()</code>函数中实现三条内部指令，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//user/sh.c runcmd()</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;jobs&quot;</span>) == <span class="number">0</span>) </span><br><span class="line">|| (<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>) == <span class="number">0</span>) </span><br><span class="line">|| (<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;kill&quot;</span>) == <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">       <span class="type">int</span> r, env_id, num;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;jobs&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">Job</span> <span class="title">list</span>[1024];</span></span><br><span class="line">		syscall_job_list(<span class="built_in">list</span>, &amp;num);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;[%d] %-10s 0x%08x %s\n&quot;</span>, <span class="built_in">list</span>[i].job_id, <span class="built_in">list</span>[i].status, <span class="built_in">list</span>[i].env_id, <span class="built_in">list</span>[i].cmd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> job_id = turn_to_num(argv[<span class="number">1</span>]);</span><br><span class="line">		r = syscall_job_turn(job_id, &amp;env_id);</span><br><span class="line">		wait(env_id);</span><br><span class="line">		<span class="keyword">if</span> (r == -E_NO_JOB)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;fg: job (%d) do not exist\n&quot;</span>, job_id);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (r == -E_NO_RUNJOB)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;fg: (0x%08x) not running\n&quot;</span>, env_id);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;kill&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> job_id = turn_to_num(argv[<span class="number">1</span>]);</span><br><span class="line">		r = syscall_job_kill(job_id, &amp;env_id);</span><br><span class="line">		<span class="keyword">if</span> (r == -E_NO_JOB)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;kill: job (%d) do not exist\n&quot;</span>, job_id);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (r == -E_NO_RUNJOB)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;kill: (0x%08x) not running\n&quot;</span>, env_id);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为每条指令添加起始的任务初始化以及任务结束，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//user/sh.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">runcmd</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (child &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		syscall_job_begin(child, cmd); <span class="comment">//应确保spawn出的子进程正确后进行任务初始化</span></span><br><span class="line">		wait(child);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		debugf(<span class="string">&quot;spawn %s: %d\n&quot;</span>, argv[<span class="number">0</span>], child);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//user/lib/libos.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">libmain</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">	syscall_job_end(env-&gt;env_id);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Mips</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/03/12/helloworld/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<p><img src="/images/nihao/helloworld/butterfly-icon.png" alt="icon"></p>
<p><img src="/images/nihao/helloworld/butterfly-icon.png" alt="icon"/></p>
]]></content>
      <categories>
        <category>hello</category>
      </categories>
      <tags>
        <tag>nihao</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象课程总结</title>
    <url>/2025/03/17/OO/2024%E6%98%A5-OO%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="2024春-OO课程总结"><a href="#2024春-OO课程总结" class="headerlink" title="2024春-OO课程总结"></a>2024春-OO课程总结</h1><h2 id="架构设计思维演进"><a href="#架构设计思维演进" class="headerlink" title="架构设计思维演进"></a>架构设计思维演进</h2><p>经过整个课程四个单元迭代式的学习演进，笔者在架构设计方面学到了很多，最重要的应该是分离式、模块化、层次化、安全性设计。现进行一定的记录：</p>
<h3 id="第一单元-字符串解析的简单计算器实现"><a href="#第一单元-字符串解析的简单计算器实现" class="headerlink" title="第一单元 字符串解析的简单计算器实现"></a>第一单元 字符串解析的简单计算器实现</h3><ul>
<li><strong>递归下降法设计：</strong>递归下降法是将原对象分为多个层次，每个层次相互独立处理，将本层次划分为多个下一层次的元素，并进入下一个层次进行处理。在第一单元中表现为原式分为多项式、单项式、因子，按照<code>+/-</code>将多项式拆分为单项式，按照<code>*</code>将单项式分为因子，在因子层面，如果因子带有<code>()</code>则按照多项式处理（这就会出现多项式类继承因子类的行为）。</li>
<li><strong>分离式设计：</strong>分离式设计应该是面向对象设计思想中极为重要的一点。这种思想有多种含义，包括程序功能模块化设计（如本单元中字符串解析为各个元素与字符串中元素计算功能分离）、层次化设计（如本单元中分为多项式、单项式、因子，后面可能还有更多层次，各个层次相互分离）等。</li>
</ul>
<h3 id="第二单元-多线程对应的电梯系统实现"><a href="#第二单元-多线程对应的电梯系统实现" class="headerlink" title="第二单元 多线程对应的电梯系统实现"></a>第二单元 多线程对应的电梯系统实现</h3><ul>
<li><strong>线程控制安全：</strong>主要有两种方式，普通的锁<code>synchronized</code>和读写锁，区别主要在于读写锁可以支持多个读线程同时对临界资源进行访问而<code>synchronized</code>方法则不行，两者会带来一定程度上的性能区别。线程安全是多线程设计中最需要考虑的问题，对于临界资源的访问都应确保通过锁的使用是安全的。</li>
<li><strong>线程休眠唤醒：</strong>为保证在不进行任何动作时空余计算资源，在线程没有请求时进行休眠操作，并在出现请求时将其唤醒。具体操作主要是使用<code>wait()</code>和<code>notifyAll()</code>函数（请注意，这两个函数都是对临界资源进行操作的，即当前线程休眠和共享临界资源的全部线程唤醒）。休眠唤醒中需要关注程序的结束问题，比如部分线程休眠后无法被唤醒（如部分线程休眠而进行中的线程结束）就会导致程序无法结束。</li>
<li><strong>临界资源共享：</strong>我们知道，进程包含资源和执行单元，而这种执行单元就是线程。也就是说线程只包含少量资源，通过函数调用执行操作，因此需要为其包含的资源提供共享的临界资源，并通过这些临界资源控制线程。这从本质上说也是一种分离式设计。</li>
</ul>
<h3 id="第三单元-JML架构对应的社交网络实现"><a href="#第三单元-JML架构对应的社交网络实现" class="headerlink" title="第三单元 JML架构对应的社交网络实现"></a>第三单元 JML架构对应的社交网络实现</h3><ul>
<li><strong>上层接口实现：</strong>在最上层类中建立多个函数接口，降低访问时间消耗与逻辑复杂度。</li>
<li><strong>特定属性动态维护：</strong>对于某些特定的属性，可以进行动态维护，降低访问时间消耗。</li>
<li><strong>规格和实现分离：</strong>本单元主要学习<code>JML</code>规格，将架构设计与代码实现分离，由架构设计师设计出程序架构，并书写<code>JML</code>架构语言，由程序员按照<code>JML</code>语言完成具体代码。</li>
</ul>
<h3 id="第四单元-自由设计的图书馆系统实现"><a href="#第四单元-自由设计的图书馆系统实现" class="headerlink" title="第四单元 自由设计的图书馆系统实现"></a>第四单元 自由设计的图书馆系统实现</h3><ul>
<li><strong>抽象思想的实现：</strong>在设计中，应注意方法的复用性。可以将程序中的部分对象进行进一步抽象，以提高程序复用性。如本单元设计中，将<code>Shelf</code>、<code>Appoint</code>、<code>Borrow</code>、<code>Corner</code>等具体的类继承<code>Office</code>类，在上层存储时存储为<code>Office</code>数组，在调用时按照序号进行使用。服务类也是如此，将其实现为<code>Service</code>接口，在上层存储时存储为<code>Service</code>数组，在调用时按照序号进行使用。</li>
<li><strong>对于信息的解析存储：</strong>对于一些对象的关键信息，应进行存储。如本单元的书籍对象，其含有借阅信息、预约信息、和捐赠信息等关键属性，需要建立关键类并存储这些信息以便后续使用。</li>
<li><strong>分离式设计与多层次设计：</strong>本单元中，分离式设计以及信息可见性是很关键的问题。将功能实现与查询接口相分离，将图书馆中不同部分的功能实现相分离，将<code>System</code>、<code>Library</code>、<code>Office</code>、<code>BookBuffer</code>等层次分离，对于这些分离的模块设计接口，仅接口信息可见，保护信息的可见性和程序的安全性。</li>
</ul>
<hr>
<h2 id="测试思维演进"><a href="#测试思维演进" class="headerlink" title="测试思维演进"></a>测试思维演进</h2><p>四个单元中，对自身程序进行了多次测试，以满足程序正确性的要求。</p>
<ul>
<li>数据构造器：通过编写<code>python</code>程序，实现自动随机生成大量数据，并放入程序中进行验证。</li>
<li>多情况全面评判：测试最核心的点在于数据的覆盖性，因此数据不在于数据量大，而是在于数据的覆盖面广。构造数据前，全面考虑可能出现的情况，并进行相应的特殊数据构造。</li>
<li>强数据测试：程序除去正确性，还应注意运行时间等性能问题，不应出现大数据量时程序无法在限制时间内获得正确结果的情况。</li>
<li><code>JUnit</code>单元测试：<code>JUnit</code>主要是对特定方法进行测试，通过书写测试程序，检查方法使用时是否会出现结果以及对象变化的问题。其主要是从特定的方法层面测试，而非全面的程序逻辑测试。同时也进行了参数化数据构造，实现自动化生成数据测试。</li>
<li>多种测试方法并行：黑箱测试、白箱测试，单元测试、集成测试，功能测试，压力测试，回归测试等测试方法，对程序的整体功能实现和代码实现逻辑与限制进行了测试。详细部分已经在第三单元中阐释，不过多赘述。</li>
</ul>
<hr>
<h2 id="课程收获"><a href="#课程收获" class="headerlink" title="课程收获"></a>课程收获</h2><p>对比CO和OS课，OO课可以说是我最上心的课了，因为面向对象这种思想不论是在工程实践还是生活中都有极高的实用价值。包括说本学期在日常中自己写一些具体问题的程序，都在刻意的训练自己这种思考问题的方式，以期更能适应未来的生产生活。</p>
<p>现对自己在面向对象中学到的东西做一些总结：</p>
<ul>
<li>架构设计：面向对象课程中最大的收获应该就是架构设计了，在这之中学习到了许多构建架构的思想，如分离式模块化设计、分层式迭代设计、出于程序安全性考虑的特殊设计。总结下来就是一种低内聚高耦合的思想，设置多种闭合模块，再暴露出特定接口，以模块为单位实现元功能和组合成为更复杂的函数，提高了程序安全性、修改的简便性和函数的复用性。这种思想在各个领域都有表现，就像局域网等。同时，面向对象是对于类进行操作，而架构设计本身也是一种分类的过程，分成多层次或依赖或独立的各种类。分类标准也是一项大收获，过去更多按照从属关系分类，类中方法也更多以具体实现为导向；而现在也会通过一些接口实现和类继承，从业务角度出发，不仅以操作者分，还以相似动作分。</li>
<li>性能优化：除去第四单元，前三个单元都对程序性能有具体要求。如第一单元中，对于计算式的展开、同类项的合并具有很高的要求；第二单元中，对于电梯调度（单个轿厢与多电梯调配）策略有很高要求（影子电梯或多目标规划）；第三单元中，对于动态维护、大顶堆等排序方法、<code>DPS/BPS</code>等图论方法的实践。在整个学习中，既有架构设计等整体性学习，又有性能优化等局部性练习。</li>
<li>工程开发流程：各单元的迭代练习比较有工程开发的味道，从前期架构设计到后期具体实现，都有很大难度的训练。整体学习中，对各部分都有所锻炼，相信在未来真正面对实际问题时，不会那么无头苍蝇乱撞，或者设计出需要不停重构的架构了。</li>
<li>程序测试：在几个单元中，学习并使用了多种测试方法。通过黑白箱测试，实现数据测试和逻辑测试的双重验证；通过单元测试、集成测试，实现局部与整体的双重验证；通过构造极限数据点的压力测试，实现对于程序的边界测试。这些测试方法，或者说测试思想，对于未来书写代码具有重要意义。</li>
</ul>
<p>还有很多更加细节的知识点，如多线程的设计与并行控制、<code>JML</code>构造语言的阅读书写、<code>UML</code>图的阅读绘制，等等等等。甚至可以说，这些思想也可以应用到生活中的做人做事中，比方说遇到各种事情时都可以将其划分为层次鲜明、互相独立的小问题，通过实现小功能去组合解决大问题。</p>
<p>那么，依旧是致谢环节。感谢各位风趣幽默又不缺乏细节的讲解架构设计和功能实现的老师，感谢每一位帮助我找出bug共度难关的学长学姐和同学，也感谢那个虽不完美但仍对一切充满信心充满热情的自己。衷心希望OO课程未来更进一步，祝好！</p>
]]></content>
      <categories>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库知识点整理</title>
    <url>/2025/03/17/DB/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h2><ol>
<li><p>文件系统：数据以文件形式保存在外存，存取以记录为单位，程序数据有一定独立性，文件与数据一一对应，数据共享性差冗余度大（存储消耗大，容易造成数据不一致性）</p>
<p>数据库系统：数据集成及共享（核心技术：数据模型、数据独立性）</p>
</li>
<li><p>数据库系统管理特点：全组织的复杂数据结构，数据冗余度小易扩充，数据和程序的独立性、映像功能、统一的数据控制、最小存取单位是数据项</p>
</li>
<li><p>数据库中模型分为两类：概念模型（信息模型）、数据模型（层次、网状、关系模型）。概念模型用于现实世界到信息世界，数据模型以计算机系统的形式对数据建模。</p>
</li>
<li><p>数据模型：抽象和表示现实世界中的是数据和信息。（严格定义的概念集合）</p>
<p>概念模型：基于信息世界主要概念，表达应用中各种语义。</p>
</li>
<li><p>概念模型基本概念：</p>
<ul>
<li><p>实体（Entity）：客观存在并可区分的事物；</p>
</li>
<li><p>属性（Attribute）：实体所具有的某一特性；</p>
</li>
<li><p>码（Key）：唯一标识实体的属性集；</p>
</li>
<li><p>域（Domain）：某个/些属性的取值范围（一组具有相同数据类型值的集合）；</p>
</li>
<li><p>实体型（Entity Type）：表示一类实体，用实体名和实体属性来表示；</p>
</li>
<li><p>联系（Relation）：实体之间的相互关联，分为一对一、一对多、多对多。</p>
</li>
</ul>
</li>
<li><p>E-R图：描述现实世界的信息及信息之间的联系。用矩形表示实体型，椭圆表示实体属性，菱形表示实体间联系。</p>
<p>联系的语义扩充： 存在依赖：实体型B如果依赖实体型A的存在才能存在，称实体型B为弱实体。（如人与子女）</p>
<p>​                                标识依赖：实体型必须通过与其联系的另一实体型共同标识才能确定其唯一性。（如学校与学生）</p>
<p>​                                实体的子类：子类继承父类属性，并附加新属性。</p>
</li>
<li><p>数据模型三要素：数据结构、数据操作、完整性约束。</p>
<p>数据结构：包含对象的类型、内容、性质，以及对象之间的联系。（数据静态特性）</p>
<p>数据操作：对各种对象的实例数值允许执行的操作集合，包括操作及操作规则，主要有检索和更新两大类。（数据动态特性）</p>
<p>数据约束条件：完整性规则（数据模型中数据极其联系所有的制约和依存规则）的集合。</p>
</li>
<li><p>数据模型分类：层次模型（树结构）、网状模型（图结构）、关系模型（二维表）。</p>
</li>
<li><p>数据独立性：应用程序与数据结构之间相互独立的关系。</p>
<p>数据的物理独立性：数据存储结构变化时，数据逻辑结构不变，从而应用不变。</p>
<p>数据的逻辑独立性：数据逻辑结构改变时应用不变。</p>
</li>
<li><p>数据库系统体系结构上具有三级模式两级映像的结构特征。</p>
<p>三级模式：模式、外模式、内模式</p>
<p>两级映像：外模式-模式，模式-内模式 </p>
<p>结构：应用-外模式-模式-内模式-数据库</p>
</li>
<li><p>模式：用模式DDL（Data Description Language）写出的一个数据库逻辑定义的全部语句，也称逻辑模式、概念模式，数据库中全体数据的逻辑结构和特性的描述。三级模式的核心，只定义数据的逻辑结构（数据记录结构、数据之间的联系）、数据安全性完整性要求，不涉及数据的具体处理（具体语言和程序）。</p>
</li>
<li><p>外模式：用外模式DDL定义，也称子模式、用户模式，是个别用户的数据视图。通常是模式的子集，对应于应用（一个应用只能启用一个外模式）。</p>
</li>
<li><p>内模式：用内模式DDL定义，也称存储模式，是数据在数据库系统内部的表示。</p>
</li>
<li><p>外模式-模式映像：通过改变映像适应模式变化，使得外模式不变。（数据的逻辑独立性）</p>
<p>模式-内模式映像：通过改变映像适应内模式变化，使得模式不变。（数据的物理独立性）</p>
</li>
<li><p>三级模式两级映像可以保障数据独立性、简化用户接口、有利于数据共享、有利于数据安全保密。</p>
</li>
<li><p>DBMS：数据库管理系统，在操作系统支持下控制。</p>
<p>功能：数据定义、数据存取、数据库运行管理、数据组织管理存储、数据库建立维护</p>
<p>DDL：数据定义语言； DML：数据操纵语言； DCL：数据管理语言。</p>
</li>
<li><p>DBA：建库用库改进，随时监测库性能。</p>
</li>
</ol>
<h2 id="第二章-关系数据库"><a href="#第二章-关系数据库" class="headerlink" title="第二章 关系数据库"></a>第二章 关系数据库</h2><ol>
<li><p>关系：笛卡尔积$D_1\times D_2 \times … \times D_n$的子集称为在域上的关系，用$R(D_1, D_2,…,D_n)$表示， $R$ 是关系的名字， $n$ 是关系的目或度。</p>
</li>
<li><p>关系可以表示为二维表，每一行是一个元组，每一列是一个域。</p>
</li>
<li><p>属性：每个列附加一个名称，且属性的名字是唯一的。</p>
</li>
<li><p>关系的性质：</p>
<ul>
<li>列是同质的，每一列中分量来自同一域，是同一类型数据；</li>
<li>不同列可以来自同一域，不同列必须有不同属性名；</li>
<li>列顺序行顺序无关紧要；</li>
<li>每一分量必须是不可再分的数据。（满足这一条件称作满足第一范式<code>1NF</code>的）</li>
</ul>
</li>
<li><p>关系模型的数据结构是关系（二维表）。</p>
</li>
<li><p>候选码：关系中某一组属性，其值唯一标识了一个元组，并具有最小性，则称该属性组为候选码。</p>
<p>主码：若关系中有多个候选码，则选定一个候选码为主码。</p>
<p>全码：若关系中仅有一个候选码，且这个候选码包含关系的所有属性，则称为全码。</p>
<p>所有候选码中的属性称为主属性，不包含在任何候选码中的属性称为非主属性。</p>
</li>
<li><p>关系模式：关系的描述称为关系模式，可表示为 $R(U,D,dom,F)$ ，$U$表示属性名集合，$D$表示属性来自域的集合，$dom$表示属性向域的映射集合，$F$表示属性间数据依赖关系集合。也可简记为$R(A_1,A_2,…,A_n)$。</p>
<p>关系模式是相对确定的，关系是变化的。关系是关系模式在某一时刻的状态或内容。</p>
</li>
<li><p>关系数据库的型：关系模式的集合构成关系数据库模式。</p>
<p>关系数据库的值：关系的集合构成具体的关系数据库。</p>
</li>
<li><p>关系模型的完整性约束：实体完整性，参照完整性，用户定义完整性。</p>
<p>实体完整性：必须有属性或属性组合作为主码，主码值不可为空或部分为空（不在域内的值）。</p>
<p>参照完整性：F是关系R的一个非主码属性，如果其与关系S的主码K相对应（两个码定义于一个域上），则称F是R的外码，且R与S可能是同一关系。R中每一元组的F值等于S中某一元组的K值，或为空。（实际上是关系相同对象的对应）</p>
<p>用户定义完整性：用户针对具体的应用环境定义的完整性约束条件。</p>
</li>
<li><p>关系模型的数据操作：操作方式特点是集合操作，操作对象与结果都是集合。操作基础是关系运算（代数方式，逻辑方式）。</p>
</li>
<li><p>关系演算（逻辑方式）： 元组关系演算：${t\,|\,\Phi(t)}$，$t$为元组</p>
<p>​                                            域关系演算：${x_1,x_2,…,x_k\,|\,\Phi(x_1,x_2,…,x_k)}$，$x_1,x_2,…,x_k$为域变量</p>
</li>
<li><p>关系代数（代数方式）： 常规：并，交，差，笛卡尔积</p>
<p>​                                            特有：选择，投影，连接，自然连接，求商</p>
</li>
<li><p>选择：在关系中选择满足给定条件的元组。（$\sigma_{F}(R)$）</p>
</li>
<li><p>投影：从关系中取出若干属性，删去重复元组组成新关系，即取出若干元组不重复的列。（$\Pi_{A_1,A_2,…,A_n}(R)$）</p>
</li>
<li><p>连接：关系R和S在属性X和Y上的连接，从两关系笛卡尔积上选择X和Y间满足比较条件$\theta$的元组。（$R \underset{X\theta Y}{\Join} S$）</p>
<ul>
<li>$\theta$为$=$时，是等值连接</li>
<li>$\theta$为$&gt;$时，是大于连接</li>
<li>$\theta$为$&lt;$时，是小于连接</li>
</ul>
</li>
<li><p>自然连接：关系R和S从笛卡尔积上选择相同属性列上取值相等的元组，并删去相同属性列。（$R \Join S$）</p>
</li>
<li><p>求商：关系$R(X,Y)$和关系$S(Z)$，其中$Y$、$Z$具有相同属性数。商是$R$在$X$上投影的子集，该集合满足和$S(Z)$的笛卡尔积包含在$R(X,Y)$中。（$R \div S$）</p>
</li>
<li><p>元组关系运算：表示为${t\,|\,\Phi(t)}$。其中$t$为元组，若元组变量前有全称量词$\forall$或存在量词$\exists$，则称为约束元组变量，反之称为自由元组变量（$t[i]$为该元组的第$i$个分量）。$\Phi(t)$为元组关系演算公式，由原子公式和运算符组成，简称公式。</p>
<p>运算符次序：算术比较运算符&gt;$\exist$&gt;$\forall$&gt;$\urcorner$&gt;$\and$&gt;$\or$</p>
</li>
<li><p>域关系运算：表示为${x_1,x_2,…,x_k\,|\,\Phi(x_1,x_2,…,x_k)}$。其中$x_i$为域，若域变量前有全称量词$\forall$或存在量词$\exists$，则称为约束域变量，反之称为自由域变量。</p>
</li>
<li><p>安全运算：关系运算中不产生无限关系和无穷验证的运算（其表达式称为安全表达式，其限制称为安全约束）。</p>
</li>
<li><p>关系代数是安全运算，关系演算则不一定是。</p>
</li>
<li><p>关系运算中通常采用的安全约束方法是：对运算式$\Phi$定义一个有限符号集$DOM(\Phi)$，使表中所有元素都属于该有限集。</p>
</li>
</ol>
<h2 id="第三章-关系数据库标准语言"><a href="#第三章-关系数据库标准语言" class="headerlink" title="第三章 关系数据库标准语言"></a>第三章 关系数据库标准语言</h2><ol>
<li><p>分类：DDL（定义），DML（操纵，有联机交互方式和宿主语言方式），DCL（控制）。</p>
</li>
<li><p>特点：一体化（将所有功能融到一种查询语言），非过程化（只提干什么），面向集合的操作方式，可独立可与主语言嵌套使用。</p>
</li>
<li><p>优越性原因：数据结构简单，建立在关系运算数学基础上。</p>
</li>
<li><p>优点：</p>
<ul>
<li>严格的数学概念，有严格设计理论；</li>
<li>概念单一，操作语言一致性；</li>
<li>数据结构简单直观，语言简洁；</li>
<li>存取对用户透明，数据独立性高，安全保密性高。</li>
</ul>
<p>缺点：</p>
<ul>
<li>查询效率低，不如层次、网状；</li>
<li>查询需要优化，开发难度增加。</li>
</ul>
</li>
<li><p>基本表：实际存在，每个表可用一个存储文件表示。</p>
</li>
<li><p>导出表：从基本表导出，有视图和快照。（视图是虚表，不实际存储在数据库中；快照指某一时间点数据库中表的数据）</p>
</li>
<li><p>查询：<code>SELECT-FROM-WHERE</code> （<code>SELECT</code>后加<code>DISTINCT</code>去除重复行；<code>WHERE</code>后是选取条件）</p>
</li>
<li><p>比较运算符：<code>=</code>,<code>&gt;</code>,<code>&gt;=</code>,<code>&lt;</code>,<code>&lt;=</code>,<code>!=</code>, <code>BETWEEN AND</code>（在范围内）</p>
</li>
<li><p>排序检索：<code>ORDER BY</code> 列名 <code>ASC(升序)/DESC(倒序)</code>，作为最后一个子句出现。</p>
<p>多属性排序：<code>ORDER BY A ASC, B DESC</code></p>
</li>
<li><p>连表检索：<code>FROM</code>后有多个表，<code>WHERE</code>后有连接条件和选取条件。</p>
<p>表自连接：<code>FROM</code>后将表定义为不同名称，其余同上。</p>
<blockquote>
<p><strong>检索所有比小明年龄大的学生姓名、年龄。</strong></p>
<p>SELECT X.SN，X.SA</p>
<p>FROM S X，S Y</p>
<p>WHERE X.SA&gt;Y.SA AND Y.SN=’小明’;</p>
</blockquote>
</li>
<li><p>外连接：在连接谓词某一边加上*/+，强制在连接时另一表对应本表不存在的元组增加空行。</p>
</li>
<li><p>子查询/嵌套查询：子句可包含另一查询块，包含子查询的语句称为外部查询。</p>
<p>普通子查询：子查询时与外部查询无关，可单独执行。（子查询不需要外查询值）</p>
<p>相关子查询：外查询时列值作为检索条件条件值。（子查询需要外查询值）</p>
<p>实际上相关子查询效率要低于普通子查询</p>
</li>
<li><p>如果子查询返回唯一值，则可以直接使用比较运算符；如果返回一组值，则需要使用<code>ANY</code>，<code>ALL</code>。</p>
<p>可使用<code>IN</code>代替<code>=ANY</code>（以及<code>NOT IN</code>）</p>
</li>
<li><p>存在检索：<code>EXISTS</code>（子查询），当且仅当子查询结果为非空时为真。（以及<code>NOT EXISTS</code>，可用来表示全称）</p>
</li>
<li><p>并差交：<code>UNION</code>，<code>MINUS</code>，<code>INTERSECT</code>（并差交，操作对象必须是同类关系）</p>
</li>
<li><p>库函数检索：<code>COUNT()</code>对列值计数，<code>COUNT(*)</code>对全部行计数；<code>SUM()</code>对数值列求和；<code>AVG()</code>对数值列求平均值；<code>MAX()</code>对数值列求最大值；<code>MIN()</code>对数值列求最小值。</p>
<p>库函数只能出现在<code>SELECT</code>语句或<code>HAVING</code>语句。</p>
</li>
<li><p>分组检索：<code>GROUP BY 列名 [HAVING condition]</code>，每组在分组属性列上具有相同值，对每一组执行<code>SELECT</code>操作，出现在<code>WHERE</code>语句后。（<code>HAVING</code>是对分组后每组的值进行限制）</p>
</li>
<li><p><code>SELECT</code>中允许存在属性列、常数、库函数、算术运算符$+-*/$等组成的算术表达式，检索结果数据项名可用表达式表示或别名表示。</p>
</li>
<li><p>部分匹配查询：<code>列名 LIKE/NOT LIKE string</code>，列名必须为字符型或变长字符型，string可包含两种特殊符号%：任意0个或多个字符，_:任意一个字符。</p>
</li>
<li><p>派生表：当子查询出现在<code>FROM</code>语句中，子查询生成的表称为临时派生表。使用<code>AS definition</code>对该表定义。</p>
</li>
<li><p>定义：操作：<code>CREATE</code>，<code>DROP</code>，<code>ALTER</code></p>
<p>​            表类型：<code>Table</code>（表），<code>Index</code>（索引），<code>View</code>（视图）</p>
</li>
<li><p>索引：主键+指针，指向表中数据，增加查询效率</p>
</li>
<li><p>视图：虚表，内存中不存在。使用时从数据字典中取出视图定义，与用户查询结合，对基本表查询（视图消解）。</p>
<p>作用：简化用户操作，使用户从多种角度看待，逻辑独立性，对数据提供安全保护。</p>
</li>
<li><p>插入：<code>INSERT INTO 表 VALUES</code></p>
<p>修改：<code>UPDATE 表 SET 值 WHERE 条件</code></p>
<p>删除：<code>DELETE FROM 表 WHERE 条件</code></p>
</li>
<li><p>数据控制： 授权：<code>GRANT 权限 ON 授权范围 TO 用户/角色</code></p>
<p>​                    收权：<code>REVOKE 权限 ON 授权范围 FROM 用户</code></p>
</li>
<li><p>空值：可初始化或赋予某个属性为空值，空值与任何值运算结果为空值，与任何值比较结果为<code>UNKNOWN</code></p>
<p>空值的判断：<code>IS NULL</code></p>
</li>
<li><p>嵌入式SQL：多采用预编译的方法处理，SQL语句翻译为主语言源码，按主语言通常方式进行编译连接为可执行代码。</p>
</li>
<li><p>动态SQL允许程序运行过程中临时组装SQL语言。</p>
</li>
<li><p>ODBC(OPEN DATA BASE CONNECT)、JDBC(JAVA DATA BASE CONNECT)：提供api接口，允许各种SQL语言使用。</p>
</li>
</ol>
<h2 id="第四章-数据库保护"><a href="#第四章-数据库保护" class="headerlink" title="第四章 数据库保护"></a>第四章 数据库保护</h2><ol>
<li><p>数据库安全性控制，数据库完整性控制</p>
</li>
<li><p>安全性：保护数据库防止非法使用造成数据泄露、更改和破坏。（有权用户获得正确数据，无权用户无法获得数据）</p>
</li>
<li><p>用户标识和认证是系统提供的最外层安全保护措施。（常用用户名和口令）</p>
</li>
<li><p>存取控制：确保合法用户在指定权限内使用和访问数据。（包括用户权限定义和合法权限检查，组成DBMS的安全子系统）</p>
</li>
<li><p>存取控制方法： 自主存取控制：不同用户对于同一对象有不同权限，用户可以将权限赋予其他用户。</p>
<p>​                            强制存取控制：对于任意用户，只有具有相关权限的用户可以存取。</p>
</li>
<li><p>自主存取控制：根据预先定义的用户权限（用户对数据对象允许执行的数据类型，由数据对象和操作类型组成）进行存取控制。</p>
<p>对于用户存取权限的定义称为授权，授权时应指明用户名、数据对象名、允许的操作类型。</p>
</li>
<li><p>基于角色的存取控制：角色是一组相关权限的集合，将角色授予用户实现权限分配，用户访问时根据所拥有的角色权限进行存取控制。使用角色存取控制，可以简化权限管理复杂度。</p>
</li>
<li><p>SQL可授予两种权限：用户极权限（整个数据库），关系极权限（关系和视图）。</p>
</li>
<li><p>强制存取方法(MAC)：实体被分为主体和客体，主体为用户和用户进程，客体为文件基本表索引视图等。DBMS为每一个实体赋予一个敏感度标记(Label)，如绝密(TS)，机密(C)，秘密(S)，公开(P)。主体敏感度标记称为许可证级别，客体敏感度标记称为密级。</p>
<p>通过对比主客体的敏感度标记，判断是否允许存取。主体敏感度大于等于客体敏感度时可以访问数据，主体敏感度等于客体敏感度时可以存储数据。</p>
</li>
<li><p>数据安全性控制的其它方法：</p>
<ul>
<li>视图机制：不同的用户定义不同的视图，可以将用户对数据的访问限制在一定的范围内。</li>
<li>审计：将所有操作自动记录并放入审计日志，后续可根据日志查询访问记录。</li>
<li>数据加密：根据一定的算法将原始数据（明文）变换为不可识别的格式（密文）。</li>
</ul>
</li>
<li><p>完整性：数据的正确性（数据合法）和相容性（各表中相同对象数据自洽）。</p>
<p>完整性关系到数据库是否可以正确反应物理世界。</p>
</li>
<li><p>数据完整性控制防止数据库中出现不合法数据，输出错误数据。</p>
<p>数据安全性控制防止非法更改和访问数据。</p>
</li>
<li><p>完整性约束条件：施加在数据库数据上的语义约束条件，作用对象可以是元组、列、关系。</p>
</li>
<li><p>完整性约束可以分为静态约束（确定状态时应满足的约束）和动态约束（状态变化过程中应满足的约束）。</p>
</li>
<li><p>列级约束：动态是指修改列定义或列值时应满足的约束条件，静态是对列的取值域的说明。</p>
<p>元组约束：动态是指修改元组值时元组中各个字段间需要满足的约束，静态是对一个元组的各个列之间关系的约束。</p>
<p>关系约束：动态是指加在关系变化前后状态上的限制条件，静态是一个关系若干元组或若干关系间的联系约束。</p>
</li>
<li><p>数据库完整性控制应包括定义功能、检查功能、违约响应。</p>
</li>
<li><p>完整性约束条件按照完整性检查的时机分为立即执行约束（一条语句执行之后立即检查）和延迟执行约束（所有语句执行之后检查，若不合法则拒绝全部语句）。</p>
</li>
<li><p>一条完整性规则可以用一个五元组(Data, Operation, Assertion, Condition, Procedure)，分别指数据对象，数据操作，断言或语义约束，作用的谓词，违反完整性规则时触发的过程。</p>
</li>
<li><p>断言：CREATE ASSERTION name CHECK condition，使condition不为真的操作将被拒绝。</p>
</li>
<li><p>触发器(Trigger)：定义在关系上的一类由事件驱动的特殊过程，对表更新时，系统激活相应触发器，执行完整性控制，判断更新是否可以执行。</p>
</li>
</ol>
<h2 id="第五章-关系数据理论"><a href="#第五章-关系数据理论" class="headerlink" title="第五章 关系数据理论"></a>第五章 关系数据理论</h2><ol>
<li><p>数据依赖：一个关系内部属性值之间相互依赖又相互制约的关系。</p>
<p>可分为函数依赖、多值依赖。</p>
</li>
<li><p>函数依赖：对于同一关系中两组属性$X$,$Y$，对于任一元组$s$,$t$，$t[X]=s[X]$时都有$t[Y]=s[Y]$（对于任意$X$，有且仅有一个$Y$与其对应），则称$X$函数决定$Y$，$Y$函数依赖于$X$，记作$X\rightarrow Y$，$X$叫做决定因素。</p>
</li>
<li><p>对于函数依赖$X\rightarrow Y$，如果$Y\subseteq X$，则称作平凡的函数依赖（即$Y$中属性全部包含于$X$中）；反之则成为非平凡的函数依赖。</p>
</li>
<li><p>函数依赖与属性间联系：1对1，互为函数依赖；1对多，1函数依赖于多；多对多，不存在函数依赖。</p>
</li>
<li><p>完全函数依赖：若$X\rightarrow Y$，对于$X$任意一个真子集$X^{‘}$，都不存在$X^{‘}\rightarrow Y$，记作$X \overset{f}{\rightarrow}Y$。</p>
<p>部分函数依赖：若$X\rightarrow Y$，对于$X$存在一个真子集$X^{‘}$，使得$X^{‘}\rightarrow Y$，记作$X \overset{p}{\rightarrow}Y$。</p>
<p>传递函数依赖：若$X\rightarrow Y$，$Y\rightarrow Z$，且不存在$Y\rightarrow X$，记作$X \overset{t}{\rightarrow}Z$。</p>
</li>
<li><p>函数依赖的逻辑蕴含：关系模式$R<U,F>$中，$U$表示属性名集合，$F$表示属性间数据依赖关系集合，$X$、$Y$是$R$的属性集合，如果从$F$中的函数依赖可以推出$X\rightarrow Y$，则称$F$逻辑蕴含$X\rightarrow Y$。</p>
</li>
<li><p>函数依赖集的闭包：$F$逻辑蕴含的所有函数依赖称为$F$的闭包（$F$和$F$可以推出的全部），记作$F^+$。</p>
</li>
<li><p>阿姆斯特朗公理系统：对于关系模式$R<U,F>$有如下规则：</p>
<ul>
<li>自反律：若$Y\subseteq X \subseteq U$，则$X\rightarrow Y$为$F$蕴含。</li>
<li>增广律：若$X\rightarrow Y$为$F$蕴含，且$Z \subseteq U$，则$XZ\rightarrow YZ$为$F$蕴含。</li>
<li>传递律：若$X\rightarrow Y$，$Y\rightarrow Z$为$F$蕴含，则$X\rightarrow Z$为$F$蕴含。</li>
<li>合并规则：若$X\rightarrow Y$，$X\rightarrow Z$，则$X\rightarrow YZ$。</li>
<li>为传递规则：若$X\rightarrow Y$，$WY\rightarrow Z$，则$WX\rightarrow Z$。</li>
<li>分解规则：若$X\rightarrow Y$，$Z\subseteq Y$，则$X\rightarrow Z$。</li>
</ul>
</li>
<li><p>属性集$X$关于函数依赖集$F$的闭包：$X_F^+ = {A|X\rightarrow A能由F根据Armstrong公理导出}$。</p>
</li>
<li><p>阿姆斯特朗公理系统是有效的、完备的。</p>
<p>有效性：由$F$出发根据Armstrong公理推导出来的每个函数依赖一定在$F $所蕴含的函数依赖的全体之中；</p>
<p>完备性：$F$所蕴含的函数依赖的全体中的每一个函数依赖，必定可以由$F$根据Armstrong公理导出。</p>
</li>
<li><p>完备性证明（第五章P35）</p>
</li>
<li><p>函数依赖集等价：$F^+ = G^+$，$F$和$G$等价，$F$覆盖$G$，$G$覆盖$F$。</p>
</li>
<li><p>最小依赖集（极小函数依赖集/最小覆盖）：</p>
<ul>
<li>$\forall (X \rightarrow A)$，必有$A$是单属性。（右部单属性）</li>
<li>不存在$X\rightarrow A$使得$F$与$F-{X\rightarrow A}$等价。（无多余FD: Functional Dependency）</li>
<li>不存在$X\rightarrow A$，$Z \sub X$，使得$F$与$F-{X\rightarrow A}\cup{Z\rightarrow A}$等价。（FD左部无多余属性）</li>
</ul>
</li>
<li><p>函数依赖集极小化处理：每个$F$均等价于一个最小依赖集$F_m$。</p>
</li>
<li><p>范式：一个关系满足某个指定的约束集。</p>
</li>
<li><p>满足最低要求约束的关系称为第一范式，记为1NF。（关系只包含原子值，无表中表）</p>
<p>满足每个非主属性完全依赖于码的第一范式称为第二范式，记为2NF。</p>
<p>满足每个非主属性都不传递依赖于任何码的第二范式称为第三范式，记为3NF。</p>
</li>
<li><p>投影分解： 2NF：消除非主属性对码的部分依赖关系，即将对码是部份依赖的非主属性分割出来。</p>
<p>​                    3NF：消除非主属性对码的传递依赖关系，即将对码是传递依赖的非主属性分割出来。</p>
</li>
<li><p>BCNF：每个非平凡函数依赖$X\rightarrow Y$，$X$必含有码的第一范式。</p>
</li>
<li><p>BCNF性质：非主属性均完全函数依赖于每个候选码；主属性均完全函数依赖于每个不包含他的候选码；没有任何属性完全函数依赖于非码的任何一组属性。</p>
</li>
<li><p>其他类型依赖：多值依赖，连接依赖，分层依赖，相互依赖。</p>
</li>
<li><p>多值依赖：设$R(U)$是属性集$U$上的一个关系模式，$X$、$Y$、$Z$是$U$的子集，并且$Z =U – X – Y$，关系模式$R(U)$中多值依赖$X→→Y$成立，当且仅当$R(U)$的任一关系$r$，给定的一对$(x，z)$值有一组Y的值，这组值仅仅决定于$x$值而与$z$值无关。</p>
</li>
<li><p>不存在非平凡的非函数依赖的多值依赖的BCNF称为第四范式，记为4NF。</p>
</li>
<li><p>规范化的基本思想是逐步消除数据依赖中不合适的部分，使数据库模式中各关系模式分离，一个关系只描述一个实体或实体间联系。（实质是概念的单一化）</p>
</li>
<li><p>规范化过程： 1NF→2NF：消除非主属性对码的部分函数依赖；</p>
<p>​                        2NF→3NF：消除非主属性对码的传递函数依赖；</p>
<p>​                        3NF→BCNF：消除主属性对码的部分和传递函数依赖；</p>
<p>​                        1NF→BCNF：消除决定因素非码（$X\rightarrow Y$中的$X$不是码）的非平凡函数依赖；</p>
<p>​                        BCNF→4NF：消除非平凡且非函数依赖的多值依赖。</p>
</li>
<li><p>范式间关系：$4NF \sub BCNF \sub 3NF \sub 2NF$。</p>
</li>
<li><p>模式分解：$F_i= {X→Y | X→Y\in F^+, XY \subseteq U_i}$，称$F_i$为$F$在$U_i$上的投影。</p>
</li>
<li><p>无损分解：对一模式分解 $\rho$，若任一关系等于其分解后所有投影的自然连接，则称为无损分解（即分解后不损失任何属性）。</p>
</li>
<li><p>无损分解的判定（第五章P70）</p>
</li>
<li><p>保持函数依赖性：分解后所有关系模式的依赖集的并集的闭包等于原依赖集的闭包，即不损失任何一个函数依赖。</p>
</li>
<li><p>模式分解原则：通过投影分解完成。</p>
</li>
<li><p>候选码的求解方法（第五章P86）</p>
</li>
</ol>
<h2 id="第六章-数据库设计"><a href="#第六章-数据库设计" class="headerlink" title="第六章 数据库设计"></a>第六章 数据库设计</h2><ol>
<li><p>数据库设计：对于给定的应用环境，设计并建立数据库逻辑结构和物理结构，以适应要求。（主要是设计出三级模式两级映像）</p>
</li>
<li><p>设计特点：数据设计和处理设计结合。</p>
</li>
<li><p>规范设计法：把设计过程划分为多个阶段，每个阶段只解决设计中部分问题。（迭代和逐步求精的过程）</p>
<p>分为需求分析、概念结构设计、逻辑结构设计、物理结构设计、数据库实施、数据库运行和维护。</p>
</li>
<li><p>需求分析：对应用环境进行详细调查，收集支持系统目标的基础数据及其处理。包括用户所需功能、数据之间关系。</p>
</li>
<li><p>概念结构设计：通过对用户需求进行综合、归纳与抽象，形成独立于数据库逻辑结构与具体DBMS的概念模型，可以用E-R图等表示。</p>
</li>
<li><p>逻辑结构设计：将概念结构转换为某个DBMS所支持的数据模型，将逻辑结构转换成特定DBMS能处理的模式、子模式。</p>
</li>
<li><p>物理结构设计：设计数据库在物理设备上的存储结构和存取方法。一般分为两步：一是确定数据库的内模式；二是对物理结构进行时间与空间效率的评价。</p>
</li>
<li><p>数据库实施：建立数据库，用DBMS的DDL描述三级模式，调试产生目标模式；开发应用程序，组织数据入库并试运行。</p>
</li>
<li><p>数据库运行维护：在数据库正式运行时，由DBA执行对数据库经常性的维护工作，包括数据库转储与恢复、数据库控制、数据库性能监控、数据库的重组与重构。</p>
</li>
<li><p>六阶段形成的模式：</p>
<p><img src="/images/DB/数据库/设计基本步骤.png" alt="设计基本步骤" style="zoom:33%;" /></p>
</li>
<li><p>数据流图：以图形方式表示系统功能，数据在系统中的逻辑流向和逻辑变换过程。（数据和处理的关系）</p>
<p>数据字典：数据集中说明，包括数据元素的名字含义等。（系统中各类数据）</p>
</li>
<li><p>E-R法：概念模型，用E-R图描述现实世界，将E-R图转化为相应数据模型。</p>
<p>组成：实体、联系、属性。</p>
<p>自顶向下分析需求，自底向上设计概念模型。首先设计出局部E-R图，整合并消除冲突，生成初步E-R图，消除冗余生成基本E-R图。</p>
</li>
<li><p>E-R图向关系模型的转换规则：一个实体型或一个关系（具有相同码的关系可以合并）转化为一个关系模式。弱实体类型转化为一个关系模式，并将被依赖关系添加到新关系中。</p>
</li>
<li><p>关系模式的优化：按照范式等级优化即可，进行合并和分解（水平分解元组，垂直分解属性）。</p>
</li>
<li><p>常用存取方法：索引、聚集、哈希。</p>
</li>
<li><p>索引：记录索引项，包含索引域、指针两个域。</p>
<p>常用B+树索引，所有关键字都按递增次序从左到右安排在叶节点上，并且链接起来。B+树能同时进行随机查找和顺序查找。</p>
</li>
<li><p>聚集：把关系中某个属性/组(聚集键)值相同的记录集中存放在连续的物理块，称为聚集。一个关系只能参与一个聚集。</p>
<p>经常进行连接操作的关系， 单个关系的某组属性经常进行相等比较可以构建聚集。</p>
</li>
<li><p>hash存储：将记录的关键字通过hash函数或hash表转换为地址。</p>
<p>关系大小可预知且不变可以直接建立，关系大小动态改变需要DBMS提供动态hash存取方法。</p>
</li>
</ol>
<h2 id="第七章-存储管理与索引"><a href="#第七章-存储管理与索引" class="headerlink" title="第七章 存储管理与索引"></a>第七章 存储管理与索引</h2><ol>
<li><p>存储管理目标：最小化磁盘存取次数</p>
<p>实现手段：在主存中保持尽量多的块，使得上层要访问块时他在主存中概率最大。</p>
</li>
<li><p>数据库存储结构主要是文件的组织结构。</p>
</li>
<li><p>数据库中表映射到文件（记录的序列），存储到若干磁盘块上。</p>
<p>一个块上可以存储多条记录，而一条记录只能存储到单个块中。每条记录有唯一的标识ID，由块号和记录在块中的位置组成。</p>
</li>
<li><p>数据库存储采用页块结构，使用页表存储块。</p>
</li>
<li><p>堆文件组织：记录可以存放在文件空间中的任何位置。可以采取链表方式（维护header页，存储空白页链表头指针和数据页链表头指针，每页记录当前包含的空槽数）和页目录方式（维护特殊页保存文件中数据页位置，记录每个页中空槽数）。</p>
</li>
<li><p>顺序文件组织：文件中记录按搜索码（用于在文件中查找记录的任意属性集合）排序排列。通过指针将记录链接起来，每个记录的指针指向按搜索码排列的下一条记录（可高效按搜索码处理记录）。</p>
</li>
<li><p>索引文件组织：索引是指记录的关键字与相应记录的存储地址的对照表，索引文件由主文件（可按主关键字有序组织或无序组织）和索引表（必须按关键字有序）构成。</p>
</li>
<li><p>散列文件组织：存储单位为桶，桶号可以是相对块号，最终可以转换为外存空间上的物理地址。使用哈希函数，将记录散列到桶上。如果记录个数超过一个桶的容量，即哈希函数出现冲突，形成一个主桶和多个溢出桶的列表。</p>
<p>二次检索：先利用哈希函数确定项所在的主桶，再根据列表逐一找到每个溢出桶。</p>
</li>
<li><p>聚集文件组织：具有相同或相似属性值得记录存储于连续的磁盘块中，并获得聚集码（哪些记录被存储在一起）。</p>
<p>多表聚集：将多个关系存储于一个文件中，在每个块中存储两个或更多关系得相关记录。</p>
</li>
<li><p>缓冲区：主存中存储磁盘块副本的区域。</p>
<p>缓冲区管理器：负责缓存空间分配，内外存交换。</p>
</li>
<li><p>块/页是存储分配和数据交换的单位。</p>
</li>
<li><p>索引分类：排序索引、哈希索引（顺序与哈希函数确定的乱序）</p>
</li>
<li><p>聚集索引：索引域排列顺序与记录在排列顺序一致，也称主索引。</p>
<p>非聚集索引：顺序不同，也称辅助索引。</p>
</li>
<li><p>稠密索引：对于文件中每一个搜索码值都有一个索引项。</p>
<p>稀疏索引：只有部分搜索码值有索引项。（占空间小且维护代价低，定位记录慢）</p>
</li>
<li><p>多级索引：索引规模大，无法全部放入内存，建立外层索引（基本索引的稀疏索引）和内层索引（基本索引文件）。</p>
</li>
<li><p>B树：限制了每个节点放置关键字与指针的最小和最大个数。所有叶节点都分布在同一层上，关键字散布在各层上。</p>
</li>
<li><p>B+树：所有关键字都按递增顺序从左到右安排在叶节点上，并链接。能同时进行随机查找和顺序查找。</p>
<p>查询：从树的根节点开始，通过比较查询码值和节点的 $k_i$ 值，向下遍历树直至到达包含指定值的叶节点。</p>
<p>插入：查询到要插入的叶节点，若有空间插入该条记录，否则拆分（将原叶节点后一半差分出一个叶节点，并将新叶节点插入原叶节点的父节点中；向上递归处理，直至不再需要拆分）。</p>
<p>删除： 查询到要删除的叶节点，删除该条记录，如果删除后叶节点中码个数低于下限，可能需要合并或重新分配（将原叶节点与其兄弟节点合并，并在父节点中删除原叶节点；如果合并时超出上限，则需要重新分配合并的码值）。</p>
</li>
<li><p>hash索引：使用哈希表实现从码到存储地址的映射。</p>
<p>哈希表包括哈希函数（映射函数，速度快碰撞率低）和哈希方案（解决一个哈希值对应多条记录，常用溢出链接法：链表）两部分。</p>
<p>静态哈希：哈希表不可变化，文件增大时访问效率降低，文件缩小时造成空间浪费。</p>
<p>动态哈希：哈希表可变化，创建新的哈希表，把原表中的码值重新缔造哈希函数并存入新哈希表。</p>
</li>
</ol>
<h2 id="第八章-查询处理与优化"><a href="#第八章-查询处理与优化" class="headerlink" title="第八章 查询处理与优化"></a>第八章 查询处理与优化</h2><ol>
<li><p>四个阶段：分析、检查、优化、执行。</p>
<p>词法分析、语法分析 =&gt; 语义分析、安全性检查、完整性检查、符号名转换 =&gt; 代数优化、物理优化 =&gt; 代码生成、代码执行</p>
</li>
<li><p>选择操作：全表扫描、索引扫描。</p>
</li>
<li><p>排序操作：内存中完全容纳，可采用快速排序等算法；内存中无法容纳，采用外排序-归并算法。</p>
</li>
<li><p>连接操作：嵌套循环（较小表为外循环，较大表为内循环）、索引连接（一个表按照连接属性建立索引，另一个表取连接属性与其比对）、排序合并（按照连接属性排序，两个表按连接属性比对）、hash-join（连接属性作为hash码，两个表散列到同一个hash文件）。</p>
</li>
<li><p>去重操作：使重复数据相邻，保留一个数据并去除其他。</p>
</li>
<li><p>投影操作：每个元组投影，再进行去重操作。</p>
</li>
<li><p>并差交：类似于排序-合并连接。</p>
</li>
<li><p>表达式的执行：物化方法（按次序每次只执行一个运算，运算结果存为临时表，一般需要写到磁盘上）和流水线方法（同时执行多个运算，将结果传递给下一个运算）。</p>
</li>
<li><p>查询优化目标：访问磁盘块数最少。</p>
</li>
<li><p>代数优化：改变代数表达式中操作的次序和组合。</p>
<p>物理优化：存取路径和底层操作算法的选择。</p>
</li>
<li><p>查询计划：定义每个操作的算法以及操作执行的顺序。</p>
</li>
<li><p>关系代数表达式等价变换规则：</p>
<ul>
<li>连接、笛卡尔积的交换律： $A @ B = B @ A$ ；</li>
<li>连接、笛卡尔积的结合律： $(A@B)@C = A@(B@C)$ ；</li>
<li>投影的串接定律： $\Pi<em>{A_1, …, A_n}(\Pi</em>{B<em>1, …, B_m} (E)) = \Pi</em>{A_1, …, A_n}(E)$ ，其中 ${A_1, …, A_n} \subseteq {B_1, …, B_m}$ ；</li>
<li>选择的串接定律：$\sigma<em>{F_1}(\sigma</em>{F<em>2} (E)) = \sigma</em>{F_1 \cap F_2}(E)$ ；</li>
<li>选择与投影的交换律： $\Pi<em>{A_1, …, A_n}(\sigma_F (E)) = \sigma_F(\Pi</em>{A_1, …, A_n}(E))$ ；</li>
<li>选择与笛卡尔积交换律：若 $F=F<em>1\cap F_2$ 代表选择的属性集合 $F$ 中含有 $E_1$ 中属性集合 $F_1$ 和 $E_2$ 中属性集合 $F_2$ ，则存在 $\sigma_F(E_1\times E_2) = \sigma</em>{F<em>1}(E_1)\times \sigma</em>{F_2}(E_2)$ ；</li>
<li>选择与并差交、自然连接的分配律： $\sigma_F(E_1 @ E_2) = \sigma_F(E_1) @ \sigma_F(E_2)$ ；</li>
<li>投影与笛卡尔积的分配律： $\Pi<em>{A_1, …, A_n, B_1, …, B_m}(E_1\times E_2) = \Pi</em>{A<em>1, …, A_n}(E_1) \times \Pi</em>{B_1, …, B_m}(E_2)$ ；</li>
<li>投影与并的分配律： $\Pi<em>{A_1, …, A_n}(E_1\cup E_2) = \Pi</em>{A<em>1, …, A_n}(E_1) \cup \Pi</em>{A_1, …, A_n}(E_2)$ 。</li>
</ul>
</li>
<li><p>优化的一般准则：</p>
<ul>
<li>选择运算尽早执行。（减小中间关系-减少元组数据）</li>
<li>投影运算尽早执行。（减小中间关系-减少属性数目）</li>
<li>把投影运算和选择运算同时进行；把投影同其前或其后的双目运算结合起来。（减少扫描关系的次数）</li>
<li>把某些选择同在它前面要执行的笛卡尔积结合起来成为一个连接运算。（把笛卡尔积与选择转换为连接）</li>
<li>找出公共子表达式，把公共子表达式的结果写入中间文件，重复使用。（中间结果复用）</li>
</ul>
</li>
<li><p>查询树优化：查询树是关系代数表达式的树型表示。类似于四元式的DAG图，构造出查询树够使用关系代数表达式等价变换规则。</p>
<p>分组：双目运算和它的直系祖先 (选取、投影)为一组；双目运算后代直到叶子全是单目运算时并入该组。笛卡尔积的后面若不是与之可以合并的自然连接的等值选择时，其后代单独分为一组。</p>
<p>生成查询代码时，每组节点的计算是程序中的一步。各步的顺序是任意的，只要保证任何一组的计算不会在其后代组之前计算。</p>
</li>
<li><p>物理优化：选择高效合理的操作算法或存取路径，得到优化的查询计划。</p>
<p>常用方法：基于规则的启发式优化、基于代价估算的优化。</p>
</li>
<li><p>选择操作的启发式规则：小关系使用全表顺序扫描；大关系采用索引扫描、全表顺序扫描。</p>
<p>连接操作的启发式规则：两个表都已经按照连接属性排序，使用排序-合并法；一个表在连接属性上有索引，使用索引连接法；连接属性上未建立索引未排序，且其中一个表较小，使用hash-join法；其余可使用嵌套循环法，选择较小的表为外循环表。</p>
</li>
<li><p>基于代价估算：利用数据库统计信息，计算各种操作算法的执行代价，选出具有最小代价的执行计划。</p>
<p>统计信息包括：基本表的规模，基本表列信息（不同值个数、最大最小值、是否有索引、索引类型）、索引的具体信息</p>
</li>
<li><p>查询优化一般步骤：查询转换成语法树；查询树利用代数优化转换为优化后标准形式；启发式优化选择底层的操作算法与存取路径，生成查询计划；基于代价优化选取代价最小的。</p>
</li>
</ol>
<h2 id="第九章-事务处理技术"><a href="#第九章-事务处理技术" class="headerlink" title="第九章 事务处理技术"></a>第九章 事务处理技术</h2><ol>
<li><p>事务的概念：用户定义的数据库操作序列，不可分割的工作单位。</p>
</li>
<li><p>事务特性：原子性、一致性、隔离性、持久性。</p>
</li>
<li><p>利用数据库的并发控制与恢复机制保证事务的特性不被破坏。</p>
</li>
<li><p>数据库的恢复基本原理是冗余，即利用存储在其他地方的数据重建数据库。</p>
</li>
<li><p>恢复是通过数据库管理系统的恢复子系统完成的，数据转储与登录日志文件。</p>
</li>
<li><p>故障种类：事务内部故障、系统故障、介质故障、计算机病毒。</p>
</li>
<li><p>日志是用来记录事务对数据库更新操作的文件。</p>
</li>
<li><p>故障恢复策略：事务故障：UNDO；系统故障：UNDO+REDO；介质故障：恢复到最近一次转储，装入日志，重做已完成事务。</p>
</li>
<li><p>检查点技术：增加检查点记录（正执行事务清单，最近记录地址）。</p>
</li>
<li><p>恢复子系统操作：缓存日志记录写入日志文件；写入检查点记录；缓存的数据记录写入数据库；检查点记录地址写入重新开始文件。</p>
</li>
<li><p>并发控制提高吞吐量，减少平均响应时间。</p>
</li>
<li><p>并发控制问题：可能破坏数据一致性。（丢失更新、读出脏数据、无法重复读）</p>
</li>
<li><p>基本思想：合理调度，避免事务间干扰破坏一致性。</p>
</li>
<li><p>基本手段：封锁。（基本封锁两种：排他锁X锁、共享锁S锁）</p>
</li>
<li><p>三种封锁协议分别对应三种问题：一级对应丢失更新、二级对应读出脏数据、三级对应无法重复读。</p>
</li>
<li><p>一级封锁协议：事务对数据修改前必须加排他锁。</p>
<p>二级封锁协议：增加读取数据前必须加共享锁。（读取完成释放）</p>
<p>三级封锁协议：增加读取数据前必须加共享锁。（事务完成释放）</p>
</li>
<li><p>封锁对象大小称为封锁粒度。</p>
</li>
<li><p>粒度大，并发度低，结构简单，开销小。</p>
</li>
<li><p>多粒度封锁：一个系统中同时支持多种封锁粒度。考虑封锁开销和并发度以选择封锁粒度。</p>
</li>
<li><p>多粒度封锁协议：允许多粒度树中每个节点被独立加锁，其后续子节点也会被全部加锁。</p>
</li>
<li><p>意向锁：该节点的下层节点正在被加锁。（因此加锁时只检查对象和其上级节点）</p>
</li>
<li><p>三种意向锁：意向排他锁，意向共享锁，意向共享排他锁。</p>
</li>
<li><p>对对象加锁时应先向其上级节点加意向锁。</p>
</li>
<li><p>活锁指其他对象已获得锁，当前对象处于等待；死锁指互相等待对方的完成。</p>
</li>
<li><p>死锁预防：一次封锁法（一次将所有要使用的对象加锁，并发度降低）、顺序封锁法（规定一个顺序，难度大）。</p>
</li>
<li><p>死锁检测：超时法、等待图法。</p>
</li>
<li><p>死锁恢复：撤销一个处理死锁代价小的事务并重做这个事务。</p>
</li>
<li><p>可串行性：并发执行正确当且仅当其结果与按某一次序执行结果相同。</p>
</li>
<li><p>两段锁协议：对数据读写前事务要取得该数据的封锁；释放封锁后事务不再获得任何其他封锁。即事务分为获得锁和释放锁两个阶段。</p>
</li>
</ol>
<h2 id="第十章-分布式数据库系统"><a href="#第十章-分布式数据库系统" class="headerlink" title="第十章 分布式数据库系统"></a>第十章 分布式数据库系统</h2><ol>
<li><p>分布式数据库：一组分布在计算机网络不同节点的数据，每个节点具有独立处理能力，可执行局部应用，也可通过网络通信执行全局应用。</p>
</li>
<li><p>特点：数据独立性（逻辑和物理独立性）、集中与自治相结合的结构、适当增加数据冗余（不同节点可能存储相同数据）、全局一致性可串行性和可恢复性。</p>
</li>
<li><p>分布式数据库系统的模式结构：</p>
<p><img src="/images/DB/数据库/分布式模式结构.png" alt="分布式模式结构" style="zoom: 50%;" /></p>
</li>
<li><p>分片方式： 基本：水平分片、垂直分片；</p>
<p>​                    复杂：混合分片、导出分片。</p>
</li>
<li><p>水平分片：按行分为若干不相交子集。</p>
<p>垂直分片：按列分为若干不相干子集，通过连接恢复原关系（各片段都包含码）。</p>
<p>导出分片：导出水平分片，分片条件不是关系本身属性而是其他关系属性，如学生课程关系按学生关系中的系属性分片。</p>
<p>混合分片：混合三种方式，按一种分片方式分完后再按另一种方式分片。</p>
</li>
<li><p>分片方式应满足：完全性、不相交性、可重构性。</p>
</li>
<li><p>分布透明性包括：分片透明性（只对全局关系进行操作，不考虑切片）、位置透明性（不必了解片段存储场地及数据一致性）、局部数据模型透明性（不必了解局部场地上使用的数据模型）。</p>
</li>
<li><p>分布式查询分类：局部查询（仅本地）、远程查询（仅远程）、全局查询（均存在）。</p>
</li>
<li><p>分布式查询优化：减少查询开销（IO+CPU+通信，首要目标是减少通信开销），可分为分布优化（更重要）和局部优化。</p>
</li>
<li><p>连接查询的优化：半连接， $R \underset{A=B}{\ltimes} S = R \underset{A=B}{\Join} (\Pi_{B}(S))$ 。</p>
</li>
<li><p>分布事务处理：一个全局事务被划分为在多个节点上的子事务。</p>
</li>
<li><p>分布事务的原子性：组成该事务的全部子事务要么一起提交，要么一起回滚。</p>
</li>
<li><p>两段提交协议保证分布事务原子性。</p>
<p>所有局部事务管理分为两类：一个协调者，多个参与者。</p>
<p>分为两个阶段：第一阶段协调者向参与者发信息并接收返回，做出决定；第二阶段：参与者执行决定。</p>
<p>发生故障时，各场地利用各自有关日志进行事务恢复。</p>
</li>
</ol>
<p>​    </p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>review</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
</search>
