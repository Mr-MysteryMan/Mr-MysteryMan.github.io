<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>编译器设计文档 | ENIGMA</title><meta name="author" content="Mr-MysteryMan"><meta name="copyright" content="Mr-MysteryMan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="参考编译器介绍本次实验预备阶段主要学习参考了经典的Pascal编译器，现进行一定的介绍。 总体结构课程组提供的Pascal编译器总体结构为词法分析、语法分析、错误处理、语义分析、代码生成和代码优化六个部分。 接口设计该编译器并未进行模块化设计，而是将各函数放在一个文件下，在调用时设定形参实参进行数据的交互。主要函数如下：  nextch 读取下一个字符 test 检查符号合法性 error 打印错">
<meta property="og:type" content="article">
<meta property="og:title" content="编译器设计文档">
<meta property="og:url" content="http://example.com/2025/03/17/Compiler/%E7%BC%96%E8%AF%91%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/index.html">
<meta property="og:site_name" content="ENIGMA">
<meta property="og:description" content="参考编译器介绍本次实验预备阶段主要学习参考了经典的Pascal编译器，现进行一定的介绍。 总体结构课程组提供的Pascal编译器总体结构为词法分析、语法分析、错误处理、语义分析、代码生成和代码优化六个部分。 接口设计该编译器并未进行模块化设计，而是将各函数放在一个文件下，在调用时设定形参实参进行数据的交互。主要函数如下：  nextch 读取下一个字符 test 检查符号合法性 error 打印错">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/wuhui/16.jpeg">
<meta property="article:published_time" content="2025-03-17T14:00:00.000Z">
<meta property="article:modified_time" content="2025-03-20T03:13:15.039Z">
<meta property="article:author" content="Mr-MysteryMan">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="C">
<meta property="article:tag" content="Mips">
<meta property="article:tag" content="LLVMIR">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/wuhui/16.jpeg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "编译器设计文档",
  "url": "http://example.com/2025/03/17/Compiler/%E7%BC%96%E8%AF%91%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/",
  "image": "http://example.com/img/wuhui/16.jpeg",
  "datePublished": "2025-03-17T14:00:00.000Z",
  "dateModified": "2025-03-20T03:13:15.039Z",
  "author": [
    {
      "@type": "Person",
      "name": "Mr-MysteryMan",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/logo.png"><link rel="canonical" href="http://example.com/2025/03/17/Compiler/%E7%BC%96%E8%AF%91%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '编译器设计文档',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/post-background.css"><link rel="stylesheet" href="/css/flipcountdown.css"><link rel="stylesheet" href="/css/nav_adjust.css"><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="/css/progress_bar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg" style="background-color: #efefef;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-original="/img/avatar.png" onerror="this.onerror=null;this.src='/img/logo.png'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/charts/"><i class="fa-fw fas fa-list"></i><span> 统计</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/wuhui/16.jpeg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">ENIGMA</span></a><a class="nav-page-title" href="/"><span class="site-name">编译器设计文档</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/charts/"><i class="fa-fw fas fa-list"></i><span> 统计</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">编译器设计文档</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-17T14:00:00.000Z" title="发表于 2025-03-17 22:00:00">2025-03-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-20T03:13:15.039Z" title="更新于 2025-03-20 11:13:15">2025-03-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">17.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>56分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="参考编译器介绍"><a href="#参考编译器介绍" class="headerlink" title="参考编译器介绍"></a>参考编译器介绍</h2><p>本次实验预备阶段主要学习参考了经典的Pascal编译器，现进行一定的介绍。</p>
<h3 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h3><p>课程组提供的Pascal编译器总体结构为词法分析、语法分析、错误处理、语义分析、代码生成和代码优化六个部分。</p>
<h3 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h3><p>该编译器并未进行模块化设计，而是将各函数放在一个文件下，在调用时设定形参实参进行数据的交互。主要函数如下：</p>
<ul>
<li><code>nextch</code> 读取下一个字符</li>
<li><code>test</code> 检查符号合法性</li>
<li><code>error</code> 打印错误信息</li>
<li><code>typ</code>处理类型<ul>
<li><code>typedeclaration</code>处理自定义类型</li>
</ul>
</li>
<li><code>constant</code>处理常量<ul>
<li><code>adjustscale</code>处理实数</li>
</ul>
</li>
<li><code>variabledeclaration</code>处理普通变量</li>
<li><code>procdeclaration</code>处理过程和函数<ul>
<li><code>parameterlist</code> 处理形参</li>
</ul>
</li>
<li><code>statement</code>处理各种语句</li>
<li><code>enter</code>登记符号表<ul>
<li><code>enterreal</code>登记实常量表</li>
<li><code>enterarray</code>登记数组符号表</li>
<li><code>enterblock</code>登记分程序信息入分程序表</li>
</ul>
</li>
<li><code>emit</code>生成中间代码</li>
</ul>
<h3 id="文件组织"><a href="#文件组织" class="headerlink" title="文件组织"></a>文件组织</h3><p>该Pascal编译器全部函数均放在一个文件下，抽象化层次化程度低，复杂程度较高。实际上，可以建立库函数文件（或者像面向对象设计一样建立类，分文件调用），以此降低文件组织的耦合程度。</p>
<hr>
<h2 id="编译器总体设计"><a href="#编译器总体设计" class="headerlink" title="编译器总体设计"></a>编译器总体设计</h2><h3 id="总体结构-1"><a href="#总体结构-1" class="headerlink" title="总体结构"></a>总体结构</h3><p>设计的编译器主要分为前端 <code>Front</code> 、中端 <code>Middle</code> 、后端 <code>Back</code> 三个部分。</p>
<p>其中，前端主要负责词法分析、语法分析部分，有词法分析器 <code>Lexer</code> 、语法分析器 <code>Parser</code> 。中端主要负责语义分析（符号表的构建与管理）与中间代码生成有语义分析器（符号管理器） <code>Manager</code> 、中间代码生成器 <code>Visitor</code> 、代码优化器 <code>Opitimizer</code> 。后端主要负责目标代码生成以及代码优化，有目标代码翻译器 <code>Translator</code> 、代码优化器 <code>Opitimizer</code> 。</p>
<p>整体的结构与流程设计如下所示：</p>
<p><img src="/img/loading.gif" data-original="/images/Compiler/编译器设计文档/编译器整体结构图.png" alt="编译器整体结构图" style="zoom: 50%;"></p>
<h3 id="接口设计-1"><a href="#接口设计-1" class="headerlink" title="接口设计"></a>接口设计</h3><p>前端：</p>
<ul>
<li><code>content</code> ：未经任何处理的待翻译程序字符串；</li>
<li><code>tokens</code> ：经词法分析后获得的单词列表；</li>
<li><code>AST</code> ：经语法分析后获得的抽象语法树（Abstract Syntax Tree，下简称语法树）。</li>
</ul>
<p>中端：</p>
<ul>
<li><code>tables</code> ：经语义分析后获得的符号表项列表，其中列表第一项即是全局符号表项；</li>
<li><code>MCT</code> ：经中间代码生成后获得的中间代码树（Medium Code Tree）。</li>
</ul>
<p>后端：</p>
<ul>
<li><code>OCT</code> ：经目标代码翻译后获得的目标代码树（Object Code Tree）；</li>
<li><code>optim</code> ：经代码优化后获得的目标代码树。</li>
</ul>
<h3 id="文件组织-1"><a href="#文件组织-1" class="headerlink" title="文件组织"></a>文件组织</h3><p>整体文件组织如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├─ Front 前端处理器</span><br><span class="line">├─ Middle 中端处理器</span><br><span class="line">├─ Back 后端处理器</span><br><span class="line">├─ CompileError 编译错误与错误处理器</span><br><span class="line">└─ IO 编译器的输入输出</span><br></pre></td></tr></table></figure>
<p>其中， <code>Front</code> 的文件组织如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">├─Lexer 词法分析</span><br><span class="line">│      Lexer.java 词法分析器类</span><br><span class="line">│      Token.java 单词类</span><br><span class="line">└─Parser 语法分析</span><br><span class="line">    │  Parser.java 语法分析器类</span><br><span class="line">    └─Syntax 语法成分</span><br><span class="line">        │  Syntax.java 语法成分接口</span><br><span class="line">        ├─Block 块</span><br><span class="line">        │      Block.java 块类</span><br><span class="line">        │      BlockItem.java 语句块项类</span><br><span class="line">        ├─Const 常量</span><br><span class="line">        │      IntConst.java 数字常量类</span><br><span class="line">        │      CharConst.java 字符常量类</span><br><span class="line">        │      StringConst.java 字符串常量类</span><br><span class="line">        ├─Decl 声明</span><br><span class="line">        │      Decl.java 声明类</span><br><span class="line">        │      ConstDecl.java 常量声明类</span><br><span class="line">        │      VarDecl.java 变量声明类</span><br><span class="line">        ├─Def 定义</span><br><span class="line">        │      ConstDef.java 常量定义类</span><br><span class="line">        │      FuncDef.java 函数定义类</span><br><span class="line">        │      MainFuncDef.java 主函数定义类</span><br><span class="line">        │      VarDef.java 变量定义类</span><br><span class="line">        ├─Expr 表达式</span><br><span class="line">        │      LOrExpr.java 逻辑或表达式类</span><br><span class="line">        │      LAndExpr.java 逻辑与表达式类</span><br><span class="line">        │      EqExpr.java 相等性表达式类</span><br><span class="line">        │      RelExpr.java 关系表达式</span><br><span class="line">        │      Expr.java 普通表达式类</span><br><span class="line">        │      ConstExpr.java 常量表达式类</span><br><span class="line">        │      AddExpr.java 加减表达式类</span><br><span class="line">        │      MulExpr.java 乘除模表达式类</span><br><span class="line">        │      UnaryExpr.java 一元表达式类</span><br><span class="line">        │      PrimaryExpr.java 基本表达式类</span><br><span class="line">        ├─Param 参数</span><br><span class="line">        │      FuncFParams.java 函数形参表类</span><br><span class="line">        │      FuncFParam.java 函数形参</span><br><span class="line">        │      FuncRParams.java 函数实参表类</span><br><span class="line">        ├─Reserved 保留元素</span><br><span class="line">        │      Number.java 数字类</span><br><span class="line">        │      Character.java 字符类</span><br><span class="line">        │      Ident.java 标识符类</span><br><span class="line">        │      ReservedWord.java 保留字类</span><br><span class="line">        │      UnaryOp.java 一元操作符类</span><br><span class="line">        ├─Stmt 语句</span><br><span class="line">        │      Cond.java 条件类</span><br><span class="line">        │      ForStmt.java for语句类</span><br><span class="line">        │      Stmt.java 语句类</span><br><span class="line">        ├─Type 类型</span><br><span class="line">        │      BType.java 数据类型类</span><br><span class="line">        │      FuncType.java 函数类型类</span><br><span class="line">        ├─Unit 单元</span><br><span class="line">        │      CompUnit.java 编译单元类 </span><br><span class="line">        └─Val 值</span><br><span class="line">                ConstInitVal.java 常量初值</span><br><span class="line">                InitVal.java 变量初值</span><br><span class="line">                LVal.java 左值表达式</span><br></pre></td></tr></table></figure>
<p><code>Middle</code> 的文件组织如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">├─Manager 符号管理</span><br><span class="line">│  │  Manager.java 符号管理类</span><br><span class="line">│  │  Table.java 符号表项类</span><br><span class="line">│  │  TableViewer.java 符号表观察类</span><br><span class="line">│  └─Symbols 符号</span><br><span class="line">│          Symbol.java 符号类</span><br><span class="line">│          ArraySymbol.java 数组符号类</span><br><span class="line">│          FuncSymbol.java 函数符号类</span><br><span class="line">│          VarSymbol.java 普通变量常量类</span><br><span class="line">└─Visitor 中间代码生成</span><br><span class="line">    │  Visitor.java 中间代码生成器类</span><br><span class="line">    │  VisitorFeature.java 中间代码生成器特征类</span><br><span class="line">    └─LLVMIR 中间代码生成LLVMIR预备部分</span><br><span class="line">        ├─TypeIR MCT节点类型</span><br><span class="line">        │  │  ValueTypeIR.java MCT节点类型类</span><br><span class="line">        │  ├─BasicType 基础类型</span><br><span class="line">        │  │      IntegerTypeIR.java int/char/bool数据类型类</span><br><span class="line">        │  │      LabelTypeIR.java 标签类</span><br><span class="line">        │  │      VoidTypeIR.java void数据类型类</span><br><span class="line">        │  └─CompType 复合类型</span><br><span class="line">        │          ArrayTypeIR.java 数组类型类</span><br><span class="line">        │          FunctionTypeIR.java 函数类型类</span><br><span class="line">        │          PointerTypeIR.java 指针类型类</span><br><span class="line">        └─ValueIR MCT节点</span><br><span class="line">            │  IR.java MCT节点接口</span><br><span class="line">            │  ValueIR.java MCT值类</span><br><span class="line">            ├─Component 中间代码组成</span><br><span class="line">            │      BasicBlockIR.java 中间代码块类</span><br><span class="line">            │      FunctionIR.java 中间代码函数类</span><br><span class="line">            │      ModuleIR.java 中间代码模块类</span><br><span class="line">            ├─Constant 中间代码常数</span><br><span class="line">            │      ConstantArrayIR.java 常数组类</span><br><span class="line">            │      ConstantIR.java 常数类</span><br><span class="line">            │      ConstantStringIR.java 常字符串类</span><br><span class="line">            ├─Instruction 中间代码指令</span><br><span class="line">            │  │  InstructionIR.java 中间代码类</span><br><span class="line">            │  ├─calculate 计算指令</span><br><span class="line">            │  │      BinaryIR.java 二元计算类</span><br><span class="line">            │  │      BTypeTranIR.java 数据类型转换类</span><br><span class="line">            │  │      IcmpIR.java 比较类</span><br><span class="line">            │  ├─jump 跳转指令</span><br><span class="line">            │  │      BrIR.java 跳转类</span><br><span class="line">            │  │      RetIR.java 返回类</span><br><span class="line">            │  └─memory 内存指令</span><br><span class="line">            │          AllocateIR.java 申请内存类</span><br><span class="line">            │          CallIR.java 调用函数类</span><br><span class="line">            │          GetElementIR.java 计算数组元素地址类</span><br><span class="line">            │          LoadIR.java 加载类</span><br><span class="line">            │          StoreIR.java 存储类</span><br><span class="line">            └─Variable 中间代码变量</span><br><span class="line">                    GlobalVariableIR.java 中间代码全局声明类</span><br><span class="line">                    VariableIR.java 变量类</span><br></pre></td></tr></table></figure>
<p><code>Back</code> 的文件组织如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">├─Optimizer 代码优化</span><br><span class="line">│      Optimizer.java 优化器类</span><br><span class="line">└─Translator 目标代码生成</span><br><span class="line">    │  Translator.java 目标代码翻译器类</span><br><span class="line">    ├─Mips 目标代码生成MIPS预备部分</span><br><span class="line">    │  │  Mips.java OCT节点类</span><br><span class="line">    │  ├─Component 目标代码组成</span><br><span class="line">    │  │      BlockMips.java 目标代码块类</span><br><span class="line">    │  │      FunctionMips.java 目标代码函数类</span><br><span class="line">    │  │      GlobalMips.java 目标代码全局声明类</span><br><span class="line">    │  │      ModuleMips.java 目标代码模块类</span><br><span class="line">    │  │      SymbolMips.java 目标代码符号类</span><br><span class="line">    │  └─Instruction 目标代码指令</span><br><span class="line">    │      │  InstrMips.java 目标代码指令类</span><br><span class="line">    │      ├─address 地址类指令</span><br><span class="line">    │      │      LwMips.java 加载字类</span><br><span class="line">    │      │      SwMips.java 存储字类</span><br><span class="line">    │      ├─assign 赋值类指令</span><br><span class="line">    │      │      LaMips.java 赋地址值类</span><br><span class="line">    │      │      LiMips.java 赋数值类</span><br><span class="line">    │      │      MfloMips.java 读lo寄存器值类</span><br><span class="line">    │      │      MfhiMips.java 读hi寄存器值类</span><br><span class="line">    │      │      MoveMips.java 赋寄存器值类</span><br><span class="line">    │      ├─binary 二元计算指令</span><br><span class="line">    │      │      AddiuMips.java 带立即数的无符号加法类</span><br><span class="line">    │      │      AdduMips.java 二元无符号加法类</span><br><span class="line">    │      │      SubuMips.java 二元无符号减法类</span><br><span class="line">    │      │      MultMips.java 二元有符号乘法类</span><br><span class="line">    │      │      DivMips.java 二元有符号除法类</span><br><span class="line">    │      │      SltMips.java 二元有符号比较类</span><br><span class="line">    │      ├─bitcalculate 位运算指令</span><br><span class="line">    │      │      AndIMips.java 带立即数的与运算类</span><br><span class="line">    │      │      SllMips.java 逻辑左移类</span><br><span class="line">    │      │      SraMips.java 算术右移类</span><br><span class="line">    │      │      SrlMips.java 逻辑右移类</span><br><span class="line">    │      ├─jump 跳转指令</span><br><span class="line">    │      │      BeqMips.java 相等时跳转立即数地址类</span><br><span class="line">    │      │      BneMips.java 不等时跳转立即数地址类</span><br><span class="line">    │      │      BgezMips.java 大于等于0时跳转立即数地址类</span><br><span class="line">    │      │      BlezMips.java 小于等于0时跳转立即数地址类</span><br><span class="line">    │      │      BgtzMips.java 大于0时跳转立即数地址类</span><br><span class="line">    │      │      BltzMips.java 小于0时跳转立即数地址类</span><br><span class="line">    │      │      JalMips.java 跳转立即数地址并链接类</span><br><span class="line">    │      │      JMips.java 跳转立即数地址类</span><br><span class="line">    │      │      JrMips.java 跳转寄存器地址类</span><br><span class="line">    │      └─system 系统指令</span><br><span class="line">    │              SyscallMips.java 系统调用类</span><br><span class="line">    └─Register 寄存器</span><br><span class="line">            Register.java 寄存器类</span><br><span class="line">            RegisterTable.java 寄存器表类</span><br></pre></td></tr></table></figure>
<p><code>CompilerError</code> 的文件组织如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CompileError.java 编译错误类</span><br><span class="line">   Judgement.java 错误处理类</span><br></pre></td></tr></table></figure>
<p><code>IO</code> 的文件组织如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Printer.java 输出解析类</span><br><span class="line">   Reader.java 输入解析类</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="词法分析设计"><a href="#词法分析设计" class="headerlink" title="词法分析设计"></a>词法分析设计</h2><p>源程序读入后作为长字符串存储在编译器中。词法分析部分的主要任务是将源程序字符串转化为单词。</p>
<p>首先应该建立单词类 <code>Token</code> 。在单词中，应当包含该单词种类、所在行、单词内容。因此设计单词类 <code>Token</code> ，其中包含属性 <code>token</code>、<code>lineNum</code>、<code>type</code>，用于存储必要信息。</p>
<p>在词法分析器 <code>Lexer</code> 中，读入源程序字符串，目标是生成单词列表。其中，部分单词是保留词，需要设置为相应类型。为防止无法分别标识符和部分保留词，首先应建立保留词表，以便分析出新单词后正确判断其类型。开始分析后，可以按照以下分类分析字符串：</p>
<ul>
<li>当前字符是数字：那么下一个单词是数字常量。继续读入字符，直至该字符不是数字为止。该段字符串即是下一个单词，该单词的单词内容即是该段字符串，该单词的类型是 <code>INTCON</code> 。</li>
<li>当前字符是 <code>\"</code> 或 <code>\'</code> ：那么下一个单词是字符串常量或者字符常量。继续读入字符，直至该字符不是对应的 <code>"</code> 或 <code>'</code> 为止。应注意，在读入字符时，有可能出现转义字符 <code>\"</code> 或 <code>\'</code> ，需要进行特殊判断（当前字符是 <code>\</code> 时下一个字符是否是 <code>"</code> 或 <code>'</code> ），不能作为字符或字符串结束标志。该段字符串即是下一个单词，该单词的单词内容即是该段字符串，该单词的类型是 <code>STRCON</code> 或 <code>CHRCON</code> 。</li>
<li>当前字符是字母或 <code>_</code> ：那么下一个单词是标识符或保留字。继续读入字符，直至该字符不是字母、数字或 <code>_</code> 。将该段字符串内容和保留词表比对，判断是否是保留词以及是什么类型的保留词。该段字符串即是下一个单词，该单词的单词内容即是该段字符串，该单词的类型是 <code>IDENFR</code> 或相应的保留词类型。</li>
<li>当前字符是 <code>+-*%;,()[]{}</code> ：那么下一个单词是保留词。这些字符是保证只能单独出现的保留词，因此直接将该字符与保留词表比对，判断是什么类型的保留词。</li>
<li>当前字符是 <code>!=&gt;&lt;</code> ：那么下一个单词是保留词。这些字符可能组合出现，产生不同于当前字符含义的保留词。继续读入字符，直至该字符不是这些字符。将该段字符串内容和保留词表比对，判断是什么类型保留词。</li>
<li>当前字符是 <code>&amp;|</code> ：那么下一个单词是保留词。由于该字符可能出现错误，因此单列出来考虑。继续读入字符，若该字符与当前字符不同，词法分析部分出现错误；若相同则与保留词表比对，判断是什么类型保留词。该单词的类型是 <code>AND</code> 或 <code>OR</code> 。</li>
<li>当前字符是 <code>/</code> ：那么接下来可能是保留词 <code>/</code> 或注释 <code>//</code> 、 <code>/**/</code> 。读入下一个字符，若该字符是 <code>/</code> 或 <code>*</code> ，那么接下来是注释，若不是，则是保留词 <code>/</code> ，类型为 <code>DIV</code>  。如果这两个字符是 <code>//</code> ，继续读入字符，直至读入 <code>\n</code> ；如果这两个字符是 <code>/*</code> ，继续读入字符，直至读入 <code>*/</code> 。 </li>
<li>当前字符是 <code>\n</code> ：源程序进行了换行，当前行数加一。</li>
<li>当前字符是其他字符：跳过即可。</li>
</ul>
<p>获得单词后，将其存入单词列表 <code>tokens</code> 中，并正确输出结果。</p>
<hr>
<h2 id="语法分析设计"><a href="#语法分析设计" class="headerlink" title="语法分析设计"></a>语法分析设计</h2><p>词法分析部分分析出的单词列表存储在编译器中。语法分析部分的主要任务是按照 <code>SysY</code> 语言文法自顶向下将单词列表转化为语法树。</p>
<p><code>SysY</code> 语言文法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">编译单元 CompUnit → {Decl} {FuncDef} MainFuncDef </span><br><span class="line">声明 Decl → ConstDecl | VarDecl </span><br><span class="line">常量声明 ConstDecl → <span class="string">'const'</span> BType ConstDef { <span class="string">','</span> ConstDef } <span class="string">';'</span></span><br><span class="line">基本类型 BType → <span class="string">'int'</span> | <span class="string">'char'</span> </span><br><span class="line">常量定义 ConstDef → Ident [ <span class="string">'['</span> ConstExp <span class="string">']'</span> ] <span class="string">'='</span> ConstInitVal</span><br><span class="line">常量初值 ConstInitVal → ConstExp | <span class="string">'{'</span> [ ConstExp { <span class="string">','</span> ConstExp } ] <span class="string">'}'</span> | StringConst</span><br><span class="line">变量声明 VarDecl → BType VarDef { <span class="string">','</span> VarDef } <span class="string">';'</span></span><br><span class="line">变量定义 VarDef → Ident [ <span class="string">'['</span> ConstExp <span class="string">']'</span> ] | Ident [ <span class="string">'['</span> ConstExp <span class="string">']'</span> ] <span class="string">'='</span> InitVal</span><br><span class="line">变量初值 InitVal → Exp | <span class="string">'{'</span> [ Exp { <span class="string">','</span> Exp } ] <span class="string">'}'</span> | StringConst </span><br><span class="line">函数定义 FuncDef → FuncType Ident <span class="string">'('</span> [FuncFParams] <span class="string">')'</span> Block</span><br><span class="line">主函数定义 MainFuncDef → <span class="string">'int'</span> <span class="string">'main'</span> <span class="string">'('</span> <span class="string">')'</span> Block</span><br><span class="line">函数类型 FuncType → <span class="string">'void'</span> | <span class="string">'int'</span> | <span class="string">'char'</span></span><br><span class="line">函数形参表 FuncFParams → FuncFParam { <span class="string">','</span> FuncFParam } </span><br><span class="line">函数形参 FuncFParam → BType Ident [<span class="string">'['</span> <span class="string">']'</span>]</span><br><span class="line">语句块 Block → <span class="string">'{'</span> { BlockItem } <span class="string">'}'</span> </span><br><span class="line">语句块项 BlockItem → Decl | Stmt </span><br><span class="line">语句 Stmt → LVal <span class="string">'='</span> Exp <span class="string">';'</span></span><br><span class="line">| [Exp] <span class="string">';'</span></span><br><span class="line">| Block</span><br><span class="line">| <span class="string">'if'</span> <span class="string">'('</span> Cond <span class="string">')'</span> Stmt [ <span class="string">'else'</span> Stmt ]</span><br><span class="line">| <span class="string">'for'</span> <span class="string">'('</span> [ForStmt] <span class="string">';'</span> [Cond] <span class="string">';'</span> [ForStmt] <span class="string">')'</span> Stmt </span><br><span class="line">| <span class="string">'break'</span> <span class="string">';'</span> | <span class="string">'continue'</span> <span class="string">';'</span></span><br><span class="line">| <span class="string">'return'</span> [Exp] <span class="string">';'</span></span><br><span class="line">| LVal <span class="string">'='</span> <span class="string">'getint'</span><span class="string">'('</span><span class="string">')'</span><span class="string">';'</span></span><br><span class="line">| LVal <span class="string">'='</span> <span class="string">'getchar'</span><span class="string">'('</span><span class="string">')'</span><span class="string">';'</span></span><br><span class="line">| <span class="string">'printf'</span><span class="string">'('</span>StringConst {<span class="string">','</span>Exp}<span class="string">')'</span><span class="string">';'</span></span><br><span class="line">语句 ForStmt → LVal <span class="string">'='</span> Exp </span><br><span class="line">表达式 Exp → AddExp </span><br><span class="line">条件表达式 Cond → LOrExp </span><br><span class="line">左值表达式 LVal → Ident [<span class="string">'['</span> Exp <span class="string">']'</span>]</span><br><span class="line">基本表达式 PrimaryExp → <span class="string">'('</span> Exp <span class="string">')'</span> | LVal | Number | Character</span><br><span class="line">数值 Number → IntConst </span><br><span class="line">字符 Character → CharConst </span><br><span class="line">一元表达式 UnaryExp → PrimaryExp | Ident <span class="string">'('</span> [FuncRParams] <span class="string">')'</span> | UnaryOp UnaryExp </span><br><span class="line">单目运算符 UnaryOp → <span class="string">'+'</span> | <span class="string">'−'</span> | <span class="string">'!'</span> 注：<span class="string">'!'</span>仅出现在条件表达式中 </span><br><span class="line">函数实参表 FuncRParams → Exp { <span class="string">','</span> Exp } </span><br><span class="line">乘除模表达式 MulExp → UnaryExp | MulExp (<span class="string">'*'</span> | <span class="string">'/'</span> | <span class="string">'%'</span>) UnaryExp </span><br><span class="line">加减表达式 AddExp → MulExp | AddExp (<span class="string">'+'</span> | <span class="string">'−'</span>) MulExp </span><br><span class="line">关系表达式 RelExp → AddExp | RelExp (<span class="string">'&lt;'</span> | <span class="string">'&gt;'</span> | <span class="string">'&lt;='</span> | <span class="string">'&gt;='</span>) AddExp </span><br><span class="line">相等性表达式 EqExp → RelExp | EqExp (<span class="string">'=='</span> | <span class="string">'!='</span>) RelExp </span><br><span class="line">逻辑与表达式 LAndExp → EqExp | LAndExp <span class="string">'&amp;&amp;'</span> EqExp</span><br><span class="line">逻辑或表达式 LOrExp → LAndExp | LOrExp <span class="string">'||'</span> LAndExp</span><br><span class="line">常量表达式 ConstExp → AddExp 注：使用的 Ident 必须是常量</span><br></pre></td></tr></table></figure>
<p>首先应该建立语法成分接口 <code>Syntax</code> 。后续建立语法树 <code>AST</code> 时所有节点都应该实现 <code>Syntax</code> 接口，以保证统一性。对于每一个语法成分，都应建立一个类，存储它作为语法树节点所有的子节点。</p>
<p>在语法分析器 <code>Parser</code> 中，读入单词列表，目标是生成语法树。按照 <code>SysY</code> 语言文法，自顶向下为每个节点类建立分析函数。同时为了不进行回溯，应在每个分析函数开始部分建立是否为当前语法成分的判断部分（判断首单词是否符合当前推导规则）：</p>
<ul>
<li><code>CompUnit</code> ：语法树的最顶层节点，代表整个待编译程序。其子节点可能为 <code>Decl</code> 、 <code>FuncDef</code> 、 <code>MainFuncDef</code> ，其中，前两部分可能存在若干次，因此使用 <code>for</code>  循环进行解析，直至无法解析出 <code>Decl</code> 或 <code>FuncDef</code> 。对于第三部分  <code>MainFuncDef</code> ，直接解析即可。</li>
<li><code>Decl</code> ：代表声明部分，分为常量声明 <code>ConstDecl</code> 和变量声明 <code>VarDecl</code> 。先假定为常量声明进行解析，若返回值为空，按照变量声明解析即可。</li>
<li><code>FuncDef</code> ：代表普通函数（非主函数）声明部分。当需要解析函数时，首先应该判断是否符合函数定义格式以及是否是主函数。对于函数定义，最大的特征标识是函数名标识符 <code>Ident</code> 后的小括号 <code>(</code> ，如果成立则可以判定为函数。对于是否是主函数的判定，只需要判定函数名标识符 <code>Ident</code> 是否是 <code>main</code> 即可。判定确实为普通函数后，存储该函数的函数类型 <code>FuncType</code> 、函数名标识符 <code>Ident</code> ，并对标识符后的函数形参进行解析及存储（存储形参个数、形参名、形参类型等）。之后对函数主体的块 <code>Block</code> 进行解析即可完成整个函数的解析。</li>
<li><code>MainFuncDef</code> ：代表主函数声明部分。其大体流程与普通函数声明部分相似：判断是否符合函数定义格式以及是否是主函数。对于函数定义，最大的特征标识是函数名标识符 <code>Ident</code> 后的括号 <code>(</code> ，如果成立则可以判定为函数。对于是否是主函数的判定，只需要判定函数名标识符 <code>Ident</code> 是否是 <code>main</code> 即可。需注意，二者都必须进行，否则可能出现被命名为 <code>main</code> 的变量被判定为主函数而导致的解析错误。判定为主函数后，存储相应函数信息，不需要对函数形参进行解析，直接对函数主体的块 <code>Block</code> 进行解析即可完成整个主函数的解析。</li>
<li><code>Block</code> ：代表由大括号包覆的块。其内部含有若干各块组成 <code>BlockItem</code> ，因此使用 <code>for</code>  循环进行解析，直至无法解析出 <code>BlockItem</code> （实际上是到达块的后一个大括号 <code>}</code> ）。最后，将块的后一个大括号 <code>}</code> 解析即可。</li>
<li><code>ConstDecl</code> ：代表常量声明部分。首先应通过当前单词是否是 <code>const</code> 判断是否是常量定义，若不是常量定义则返回空值。如果是常量定义，则存储之后定义的常量的数据类型 <code>BType</code> 。由于一句常量声明中可以存在多条常量定义语句，因此使用 <code>for</code>  循环进行解析，直至无法解析出 <code>ConstDef</code> 。</li>
<li><code>VarDecl</code> ：代表变量声明部分。首先应当判定是否是变量定义：当前单词应该是变量的数据类型 <code>BType</code> ，且不应该出现 <code>BType Ident (</code> 的情况。如果是变量定义，则存储之后定义的变量的数据类型 <code>BType</code> 。由于一句变量声明中可以存在多条变量定义语句，因此使用 <code>for</code>  循环进行解析，直至无法解析出 <code>VarDef</code> 。</li>
<li><code>ConstDef</code> ：代表常量定义部分。首先需要判断是否是常量定义，由于 <code>ConstDef</code> 只能从 <code>ConstDecl</code> 获得，因此只需要通过是否存在定义常量标识符 <code>Ident</code> 判定是否是定义语句即可。如果是常量定义，则存储当前常量标识符 <code>Ident</code> 。该标识符所代表常量可能是常量数组，需要通过标识符后是否是中括号 <code>[</code> 来判断。如果该常量是常量数组，则需要对中括号 <code>[</code> 后的常量表达式 <code>ConstExp</code> 进行解析，以获得该数组的元素个数。如果不是常量数组，正常进行后续操作即可。对于常量定义部分，还需要解析为定义常量所赋的初值。对等号 <code>=</code> 后的常量表达式 <code>ConstExp</code> 进行解析并存储即可。</li>
<li><code>VarDef</code> ：代表变量定义部分。首先需要判断是否是变量定义，由于 <code>VarDef</code> 只能从 <code>VarDecl</code> 获得，因此只需要通过是否存在定义变量标识符 <code>Ident</code> 判定是否是定义语句即可。如果是变量定义，则存储当前变量标识符 <code>Ident</code> 。该标识符所代表变量可能是变量数组，需要通过标识符后是否是中括号 <code>[</code> 来判断。如果该变量是变量数组，则需要对中括号 <code>[</code> 后的变量表达式 <code>VarExp</code> 进行解析，以获得该数组的元素个数。如果不是变量数组，正常进行后续操作即可。对于变量定义部分，还需要判定是否存在为定义变量赋初值的情况，通过标识符 <code>Ident</code> 或中括号 <code>]</code> 后是否存在等号 <code>=</code> 来判断。如果存在，解析为定义变量所赋的初值。对等号 <code>=</code> 后的普通表达式 <code>Exp</code> 进行解析并存储即可。</li>
<li><code>ConstInitVal</code> ：代表常量定义时的初值，可能为字符串常量，常量数组元素集合，常量表达式。对于字符串常量，直接存储即可。对于数组元素集合，通过大括号 <code>{</code> 来判定，如果是则解析后续出现的若干常量表达式即可；对于常量表达式，直接解析即可。</li>
<li><code>InitVal</code> ：代表变量定义时的初值，可能为字符串常量，变量数组元素集合，普通表达式。对于字符串常量，直接存储即可。对于数组元素集合，通过大括号 <code>{</code> 来判定，如果是则解析后续出现的若干普通表达式即可；对于普通表达式，直接解析即可。</li>
<li><code>FuncFParams</code> ：代表函数形参声明部分。函数形参声明可能有若干形参，因此使用 <code>for</code>  循环进行解析，直至无法解析出  <code>FuncFParam</code> 为止。根据解析出的形参个数，判定是否存在函数形参声明部分。即如果解析出的形参个数为0，则不存在函数形参部分。</li>
<li><code>FuncFParam</code> ：代表每个函数形参的定义部分。对于每个函数形参的定义，存储该形参的数据类型 <code>BType</code> 和形参标识符 <code>Ident</code> 。部分形参可能是数组（实际上是有着数组形式的指针），识别标识符后的中括号 <code>[]</code> ，并将类型存储。</li>
<li><code>BlockItem</code> ：代表每个块组成。其可能是声明 <code>Decl</code> 或语句 <code>Stmt</code> 。先假定为声明进行解析，若返回值为空，按照语句解析即可。</li>
<li><code>Stmt</code> ：代表块中可能出现的语句，推导规则比较复杂，大体可以分为三类：赋值型，特殊功能型，块或表达式。对于赋值型，即 <code>LVal '=' Exp ';'</code> , <code>LVal '=' 'getint''('')'';'</code> , <code>LVal '=' 'getchar''('')'';'</code> ，需要通过等号 <code>=</code> 来判定，如果是赋值型，直接存储即可；如果不是赋值型，此时已经对左值表达式 <code>LVal</code> 进行了解析，需要进行回溯，因此在解析前应保留解析位置，以便后期回溯。对于特殊型，可以直接通过关键词判断类型： <code>'if' '(' Cond ')' Stmt [ 'else' Stmt ]</code> 可以通过 <code>if</code> 判定，并解析 <code>if</code> 的条件 <code>Cond</code> 和需要执行的语句 <code>Stmt</code> ，如果存在 <code>else</code> ，则额外解析 <code>else</code> 需要执行的语句 <code>Stmt</code> ； <code>'for' '(' [ForStmt] ';' [Cond] ';' [ForStmt] ')' Stmt</code> 可以通过 <code>for</code> 判定，并解析 <code>for</code> 的条件 <code>Cond</code> 和两个 <code>for</code> 语句 <code>ForStmt</code> （如果存在的话），以及需要执行的语句 <code>Stmt</code> ；<code>';'</code> 、 <code>'break' ';'</code> 和 <code>'continue' ';'</code> 语句中全部是保留词，直接解析即可； <code>'return' [Exp] ';'</code> 可以通过 <code>return</code> 判定，并解析之后可能出现的表达式 <code>Exp</code> ；<code>'printf''('StringConst {','Exp}')'';'</code> 可以通过 <code>printf</code> 判定，存储保留词和字符串常量，并解析之后可能出现的若干表达式 <code>Exp</code> 。对于块或表达式，在排除上述所有情况后，直接解析即可，不会再出现需要回溯的情况。</li>
<li><code>ForStmt</code> ：代表 <code>for</code> 语句，只可能出现左值表达式的赋值。因此解析被赋值的左值表达式 <code>LVal</code> 和待赋值的普通表达式 <code>Exp</code> 即可。需注意，判定是 <code>ForStmt</code> 的标识是赋值的等号 <code>=</code> ，此时已经对左值表达式 <code>LVal</code> 进行了解析，如果不是 <code>ForStmt</code> 则需要进行回溯，因此在解析前应保留解析位置，以便后期回溯。</li>
<li><code>Cond</code> ：代表各类语句的条件，只能是逻辑表达式，按照文法，只能是逻辑或表达式 <code>LOrExp</code> 。因此，直接按照逻辑或表达式 <code>LOrExp</code> 对其解析即可。</li>
<li><code>LOrExp</code> ：代表逻辑或表达式，由逻辑或表达式 <code>LOrExp</code> 、逻辑或符号 <code>||</code> 、逻辑与表达式 <code>LAndExp</code> 组成。由于该文法是左递归文法，如果直接解析会出现无限下降的问题。因此，改写文法，先解析逻辑与表达式 <code>LAndExp</code> ，如果存在逻辑或符号 <code>||</code> ，则将其种类变换为逻辑或表达式 <code>LOrExp</code> ，并按照上述方法继续进行。</li>
<li><code>LAndExp</code> ：代表逻辑与表达式，由逻辑与表达式 <code>LAndExp</code> 、逻辑与符号 <code>&amp;&amp;</code> 、相等性表达式 <code>EqExp</code> 组成。由于该文法是左递归文法，因此，按照 <code>LOrExp</code> 中相似的方法进行解析。</li>
<li><code>EqExp</code> ：代表相等性表达式，由相等性表达式 <code>EqExp</code> 、相等性符号 <code>==</code> 或 <code>!=</code> 、关系表达式 <code>RelExp</code> 组成。由于该文法是左递归文法，因此，按照 <code>LOrExp</code> 中相似的方法进行解析。</li>
<li><code>RelExp</code> ：代表关系表达式，由关系表达式 <code>RelExp</code> 、关系符号 <code>&gt;</code> 或 <code>&lt;</code> 或<code>&gt;=</code> 或 <code>&lt;=</code> 、加减表达式 <code>AddExp</code> 组成。由于该文法是左递归文法，因此，按照 <code>LOrExp</code> 中相似的方法进行解析。</li>
<li><code>ConstExp</code> ：代表常量表达式，只能是加减表达式。因此，直接按照加减表达式 <code>AddExp</code> 对其解析即可。同时应指出，由文法规定，常量表达式中出现的全部标识符必须是常量。</li>
<li><code>Exp</code> ：代表普通表达式，只能是加减表达式。因此，直接按照加减表达式 <code>AddExp</code> 对其解析即可。</li>
<li><code>AddExp</code> ：代表关系表达式，由加减表达式 <code>AddExp</code> 、加减符号 <code>+</code> 或 <code>-</code> 、乘除表达式 <code>MulExp</code> 组成。由于该文法是左递归文法，因此，按照 <code>LOrExp</code> 中相似的方法进行解析。</li>
<li><code>MulExp</code> ：代表乘除表达式，由乘除表达式 <code>MulExp</code> 、乘除符号 <code>*</code> 或 <code>/</code> 或 <code>%</code> 、一元表达式 <code>UnaryExp</code> 组成。由于该文法是左递归文法，因此，按照 <code>LOrExp</code> 中相似的方法进行解析。</li>
<li><code>UnaryExp</code> ：代表一元表达式，可能是带一元符号的一元表达式，基本表达式或函数调用。对于带一元符号的一元表达式，通过医院符号进行判定，若是则解析一元表达式 <code>UnaryExp</code> 即可。对于函数调用，通过标识符后的小括号 <code>(</code> 判定，若是函数调用，则对括号内进行函数实参 <code>FuncRParams</code> 解析。排除函数调用的情况后，一定是基本表达式，对基本表达式 <code>PrimaryExp</code> 进行解析即可。</li>
<li><code>FuncRParams</code> ：代表函数实参。其由若干普通表达式组成，因此使用 <code>for</code>  循环进行解析，直至无法解析出  <code>Exp</code> 为止。</li>
<li><code>PrimaryExp</code> ：代表基本表达式。可能是 <code>int</code> 型常量、 <code>char</code> 型常量、带小括号的普通表达式或左值表达式 <code>LVal</code> 。对于 <code>int</code> 型常量、 <code>char</code> 型常量，按照数据类型直接解析存储即可。对于带小括号的普通表达式，通过小括号 <code>(</code> 判定，若是则对后续普通表达式解析即可。对于左值表达式 <code>LVal</code> ，直接解析即可。</li>
<li><code>LVal</code> ：代表左值表达式，主要是标识符（普通变量常量标识符，变量常量数组标识符，带偏移的变量常量数组标识符）。对于不带偏移的标识符（即不存在 <code>[Exp]</code> ），直接当作标识符 <code>Ident</code> 处理即可。对于带偏移的变量常量数组标识符，在存储标识符的同时也需要对偏移量表达式解析存储。</li>
</ul>
<p>对于每一种实现 <code>Syntax</code> 的语法节点，其应有属性 <code>syntaxes</code> ，表示其含有的全部子节点。获得语法树 <code>AST</code> 各节点后，将其存入父节点的 <code>syntaxes</code> 中，并设置函数，使其可以正确输出必要信息。</p>
<hr>
<h2 id="语义分析设计"><a href="#语义分析设计" class="headerlink" title="语义分析设计"></a>语义分析设计</h2><p>语法分析部分分析出的语法树 <code>AST</code> 会存储在编译器中。语义分析部分的主要任务是解析出现的标识符（函数标识符，常量标识符，变量标识符），构建符号表，以便后续代码生成时方便查阅。</p>
<p>对于各类符号，在不同域定义的标识使用范围不同：在外层定义的标识可以在内层使用，而在内层定义的标识不可以在外层使用。相同层不同域定义的标识不可以互相使用。因此，需要建立一种双向树结构，每个节点代表每个符号表项，相同层节点代表相同层的符号表项。建立符号表项类 <code>Table</code> ，其属性有符号表项序号 <code>id</code> ，符号表项的父符号表项 <code>father</code> ，符号表项所处的层数 <code>floor</code> ，符号表项内存储的符号 <code>symbols</code> 。这样在查找符号时，从当前表项出发，从底向上逐层遍历，直至获得当前符号：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Symbol <span class="title function_">searchDefinition</span><span class="params">(String symbolName)</span> {</span><br><span class="line">    <span class="keyword">for</span> (Symbol symbol : symbols) {</span><br><span class="line">        <span class="keyword">if</span> (symbol.getName().equals(symbolName)) <span class="keyword">return</span> symbol;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (father != <span class="literal">null</span>) <span class="keyword">return</span> father.searchDefinition(symbolName);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>需要储存的符号有函数，变量，常量，变量数组以及常量数组。每种符号都有其类型和要储存的属性，应该建立类，规定相应属性：</p>
<ul>
<li><code>Symbol</code> ：总的符号类，其他符号类的父类，存储有各类符号的基本信息。包括符号序号 <code>id</code> ，符号所在的符号表项 <code>table</code> ，符号名 <code>name</code> ， 符号对应的单词 <code>token</code> ，符号类型 <code>type</code> （可能为 <code>"intVar"</code> 、 <code>"charVar"</code> 、 <code>"intArray"</code> 、 <code>"charArray"</code> 、 <code>"intFunc"</code> 、 <code>"charFunc"</code> 、 <code>"voidFunc"</code> ）。对于每个属性，建立 <code>set</code> 和 <code>get</code> 方法，并设置函数，使其可以正确输出必要信息。</li>
<li><code>VarSymbol</code> ：变量常量符号类，继承 <code>Symbol</code> 。除去 <code>Symbol</code> 中存储的信息，还应额外存储符号数据类型 <code>bType</code> ，符号是否代表常量 <code>con</code> 。在创建该类时，应给出全部必要信息。</li>
<li><code>ArraySymbol</code> ：变量常量数组符号类，继承 <code>Symbol</code> 。除去 <code>Symbol</code> 中存储的信息，还应额外存储符号数据类型 <code>bType</code> ，符号是否代表常量 <code>con</code> ，数组维度 <code>dim</code> （应指出 <code>SysY</code> 语言规定数组为一维）。在创建该类时，应给出全部必要信息。</li>
<li><code>FuncSymbol</code> ：函数符号类，继承 <code>Symbol</code> 。除去 <code>Symbol</code> 中存储的信息，还应额外存储函数数据类型 <code>funcType</code> ，函数的形参个数 <code>paramNum</code> ，函数各形参的类型 <code>paramTypes</code> （可能为 <code>"intVar"</code> 、 <code>"charVar"</code> 、 <code>"intArray"</code> 、 <code>"charArray"</code> ）。在创建该类时，应给出全部必要信息。</li>
</ul>
<p>完成必需类准备后，可以进行符号的解析与符号表的构建。在语义分析器（符号管理器） <code>Manager</code> 中，读入并遍历语法树 <code>AST</code> ，解析各语法成分，获得新出现的符号，存入相应的符号表项。在遍历过程中，由于函数、块等的存在，符号会出现不同的定义与使用域，因此在遍历过程中，需要注意和维护当前符号所在层数，在层数改变时改变当前符号表（层数增加时新建符号表项，层数减少时转移至当前表项的父符号表项，如不存在则报错）。由于层数改变出现较为频繁，因此封装函数 <code>createTable()</code> 和 <code>quitTable()</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createTable</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">Table</span> <span class="variable">father</span> <span class="operator">=</span> nowTable;</span><br><span class="line">    curFloor++;</span><br><span class="line">    curSerial = tables.size(); <span class="comment">// 当前符号表序号</span></span><br><span class="line">    curIndex = <span class="number">0</span>; <span class="comment">// 当前符号表中当前符号序号</span></span><br><span class="line">    nowTable = <span class="keyword">new</span> <span class="title class_">Table</span>(curSerial, father.getId(), father, curFloor);</span><br><span class="line">    tables.add(nowTable);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quitTable</span><span class="params">()</span> {</span><br><span class="line">    curFloor--;</span><br><span class="line">    curSerial = nowTable.getFather().getId();</span><br><span class="line">    curIndex = nowTable.getFather().getSize();</span><br><span class="line">    nowTable = nowTable.getFather();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>会发生符号表变更的位置是（主）函数定义，带块的 <code>if</code> 和 <code>for</code> ，普通的块。应指出，虽然这几个位置产生表的变化都是因为块，但不可将符号表项的变更放在块的解析中。这是因为函数定义中可能出现形参，需要存入新符号表项中，因此应该具体问题具体分析。对于不带块的 <code>if</code> 和 <code>for</code> ，根据文法，其后只能是 <code>[Exp] ';'</code> ，不能出现新的声明 <code>Decl</code> ，因此不新建符号表。这些符号表项变化主要出现在 <code>MainFuncDef</code> 、 <code>FuncDef</code> 和 <code>Stmt</code> 中。</p>
<ul>
<li><code>MainFuncDef</code> ：主函数内的符号表变化，不含形参。主要是在主函数的块内，因此在进入块前调用 <code>createTable()</code> ，完成块的解析并退出块后调用 <code>quitTable()</code> 。</li>
<li><code>FuncDef</code> ：普通函数内的符号表变化，不含形参。主要是在普通函数的形参声明以及块内，因此在函数进行形参声明前调用 <code>createTable()</code> ，完成块的解析并退出块后调用 <code>quitTable()</code> 。</li>
<li><code>Stmt</code> ：主要是带块的 <code>if</code> 、 <code>for</code> 和 普通的块。在这里，可以进行合并，统一在 <code>Stmt → Block</code> 的过程中进行。在进入块前调用 <code>createTable()</code> ，完成块的解析并退出块后调用 <code>quitTable()</code> 。</li>
</ul>
<p>对于三种符号 <code>FuncSymbol</code> 、 <code>VarSymbol</code> 、 <code>ArraySymbol</code> ，第一种主要在函数定义中出现（ <code>main</code> 函数可以直接获得符号，无需特殊说明），后两种主要在变量常量定义，函数形参解析中出现。</p>
<ul>
<li><code>FuncDef</code> ：根据解析的语法成分，获得函数标识符并建立 <code>FuncSymbol</code> 存储在当前符号表项中。</li>
<li><code>ConstDef</code> / <code>VarDef</code> ：根据解析的语法成分（标识符和数据类型），建立  <code>VarSymbol</code> 或 <code>ArraySymbol</code> 存储在当前符号表项中。</li>
<li><code>FuncFParam</code> ：建立符号的方法基本与 <code>ConstDef</code> / <code>VarDef</code> 相同，建立  <code>VarSymbol</code> 或 <code>ArraySymbol</code> 存储在当前符号表项中。</li>
</ul>
<hr>
<h2 id="错误处理设计"><a href="#错误处理设计" class="headerlink" title="错误处理设计"></a>错误处理设计</h2><p>按照文法设计与实验安排，本次实验中总共有 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.557ex" role="img" focusable="false" viewBox="0 -666 1000 688"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(500,0)"></path></g></g></g></svg></mjx-container> 种错误，其中 <code>a</code> 类错误会出现在词法分析部分，<code>i</code> 、 <code>j</code> 、 <code>k</code> 类错误会出现在语法分析部分，其余错误会出现在语义分析部分。同时，为了统一性和复用性，在实验中建立了错误判定器类 <code>Judgement</code> ，判断每类错误时输入必要信息，获得判断结果。同时 <code>Judgement</code> 内含属性 <code>errors</code> ，存储分析过程中抛出的全部错误。现对每种错误进行分析：</p>
<ul>
<li><code>a</code> 类错误：非法符号 <code>&amp;</code> 和 <code>|</code> ，应该将其当做 <code>&amp;&amp;</code> 与 <code>||</code> 进行处理，并在记录单词名称的时候正确记录。这个错误主要在词法分析对 <code>&amp;|</code> 的分析中出现，判断当前字符与下一个字符是否相同即可。由于出现在词法分析部分，为了错误检测的正常运行（以检测出全部错误），按照出现的第一个字符添加或更改字符，将其作为正确单词存入。判断函数输入的必要信息是当前字符、下一个字符以及当前字符所在行数。</li>
<li><code>b</code> 类错误：符号名在当前域下重复定义。应指出，变量在同一级域下重定义会判定错误，不同级作用域下，内层会覆盖外层定义。这个错误主要出现在语义分析符号定义阶段。将当前符号放入当前符号表项搜索，判断是否出现相同名字的符号。判断函数输入的必要信息是当前符号以及当前符号表项。</li>
<li><code>c</code> 类错误：使用未定义的标识符。使用当前符号表项或其父符号表项中不含有的的符号，主要出现在语义分析的语句和表达式的解析中。将当前符号在当前符号表以及父符号表等递归搜索，判断是否出现相同名字的符号。判断函数输入的必要信息是当前标识符单词以及当前符号表项。</li>
<li><code>d</code> 类错误：函数的形参和实参个数不匹配。主要出现在语义分析的函数调用阶段。在函数定义阶段，有对函数的形参进行存储。在调用阶段（ <code>UnaryExp</code> 的解析阶段），以 <code>,</code> 作为分隔符解析函数实参，存储实参的个数。比较形参数组的大小和实参个数即可。判断函数输入的必要信息是当前函数的符号以及实参个数。</li>
<li><code>e</code> 类错误：函数的形参和实参类型不匹配。主要出现在语义分析的函数调用阶段。在函数定义阶段，有对函数的形参进行存储。在调用阶段（ <code>UnaryExp</code> 的解析阶段），以 <code>,</code> 作为分隔符解析函数实参，存储各实参的类型。比较各形参和各实参的类型是否匹配即可。应注意，类型匹配过程中，普通变量常量允许出现数据转换，即 <code>intVar</code> 和 <code>charVar</code> 可以认为是匹配的。其余类型必须完全匹配才可。判断函数输入的必要信息是当前函数的符号以及实参类型数组。</li>
<li><code>f</code> 类错误： <code>void</code> 类型的函数存在不匹配的 <code>return</code> 语句。 <code>void</code> 类型函数如果存在返回语句，返回语句后一定不能出现 <code>Exp</code> 。主要出现在语义分析的语句分析阶段。在语句分析的过程中，如果出现 <code>return</code> ，应解析其后单词，判断是否出现 <code>Exp</code> 。判断函数输入的必要信息是当前函数符号，当前 <code>return</code> 所在行数以及当前 <code>return</code> 是否存在返回值。</li>
<li><code>g</code> 类错误： <code>int</code> 或 <code>char</code> 类型的函数在函数末尾不存在 <code>return</code> 语句。为简化问题，实验规定， <code>int</code> 或 <code>char</code> 类型的函数在函数末尾必须存在 <code>return</code> 语句，即使在 <code>if-else</code> 控制流语句中出现也不能省略。主要出现在语义分析的函数定义阶段。在控制流外，如果出现 <code>return</code> 语句，则存储该语句所在域层数 <code>returnFloor</code> （这表明该变量一定保留的是最后一个 <code>return</code> 语句所在的层数，该变量初始化为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="2.891ex" height="1.692ex" role="img" focusable="false" viewBox="0 -666 1278 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(778,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container> ）；如果 <code>returnFloor</code> 的值不等于 <code>funcFloor + 1</code> （为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="2.891ex" height="1.692ex" role="img" focusable="false" viewBox="0 -666 1278 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(778,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container> 时证明不存在 <code>return</code> 语句，大于 <code>funcFloor + 1</code> 时证明该 <code>return</code> 语句在控制流内），则证明其存在该类错误。判断函数输入的必要信息是函数符号，最后一个 <code>return</code> 语句所在的层数以及函数块 <code>}</code> 的行号。</li>
<li><code>h</code> 类错误：尝试修改常量的值。主要出现在语义分析的语句和表达式的解析中。在构建语法树时，对于标识符，有属性 <code>con</code> 判断其是否是常量。因此，在赋值时根据该属性判断是否存在错误即可。判断函数输入的必要信息是常量符号以及是否是对该常量赋值。</li>
<li><code>i</code> 类错误：缺少必要的 <code>;</code> 。这个错误主要出现在语法分析部分，在构建语法树的过程中按照正确文法检测相应位置是否存在 <code>;</code> 即可。由于出现在语法分析部分，为了错误检测的正常运行（以检测出全部错误），添加缺少的 <code>;</code> ，以保证当前语法成分的正确性。判断函数输入的必要信息是当前字符、上一个字符所在行数。</li>
<li><code>j</code> 类错误：缺少必要的 <code>)</code> 。这个错误主要出现在语法分析部分，在构建语法树的过程中按照正确文法检测相应位置是否存在 <code>)</code> 即可。由于出现在语法分析部分，为了错误检测的正常运行（以检测出全部错误），添加缺少的 <code>)</code> ，以保证当前语法成分的正确性。判断函数输入的必要信息是当前字符、上一个字符所在行数。</li>
<li><code>k</code> 类错误：缺少必要的 <code>]</code> 。这个错误主要出现在语法分析部分，在构建语法树的过程中按照正确文法检测相应位置是否存在 <code>]</code> 即可。由于出现在语法分析部分，为了错误检测的正常运行（以检测出全部错误），添加缺少的 <code>]</code> ，以保证当前语法成分的正确性。判断函数输入的必要信息是当前字符、上一个字符所在行数。</li>
<li><code>l</code> 类错误： <code>printf</code> 字符串中格式字符数量与表达式个数不匹配。文法规定  <code>printf</code> 函数中可以出现格式字符 <code>%d</code> / <code>%c</code> ，用于输出 <code>int</code> 或 <code>char</code> 类型的算式。该类错误即是格式字符 <code>%d</code> / <code>%c</code> 与要输出的表达式的数量不同。 主要出现在语义分析的语句 <code>printf</code> 的解析中。在 <code>printf</code> 语句解析时，使用正则表达式，获得输出字符串中格式字符的匹配数量，并与解析的表达式个数进行比较。判断函数输入的必要信息是输出字符串以及表达式数量。</li>
<li><code>m</code> 类错误：在非循环块中使用 <code>break</code> 和 <code>continue</code> 语句。主要出现在语义分析的语句 <code>break</code> 和 <code>continue</code> 的解析中。要判断当前语句是否位于循环块中，需要动态维护循环层数 <code>forFloor</code> 。该属性初值为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.557ex" role="img" focusable="false" viewBox="0 -666 500 688"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></svg></mjx-container> ，仅在进入循环时增加，在退出循环时减少。解析 <code>break</code> / <code>continue</code> 语句时，只需要判断循环层数 <code>forFloor</code> 是否大于 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.557ex" role="img" focusable="false" viewBox="0 -666 500 688"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></svg></mjx-container> 即可。 判断函数输入的必要信息是<code>break</code> / <code>continue</code> 语句的行号以及循环层数 <code>forFloor</code> 。</li>
</ul>
<p>错误处理主要出现在词法分析、语法分析和语义分析部分。为了尽可能全面地检查出全部错误，按照流程，应保证词法分析和语法分析部分遇到错误不仅需要抛出相应错误，还需要进行修正，以便后续流程进行。错误处理完成后，获取 <code>errors</code> 属性，并输出相应信息。同时 <code>errors</code> 也将作为判断是否能进行代码生成的充分条件。</p>
<hr>
<h2 id="代码生成设计"><a href="#代码生成设计" class="headerlink" title="代码生成设计"></a>代码生成设计</h2><p>在获得语法树 <code>AST</code> 后，可以按照树型结构将其转换为目标代码树。直接转化为目标代码难度较大，因此优先转化为中间代码树，在转换为目标代码树。本次实验中选择的目标代码是MIPS，中间代码是LLVMIR。</p>
<h3 id="中间代码生成设计"><a href="#中间代码生成设计" class="headerlink" title="中间代码生成设计"></a>中间代码生成设计</h3><p>在中间代码生成器 <code>Visitor</code> 中，读入语法分析中生成的抽象语法树 <code>AST</code> 和语义分析中生成的符号表 <code>tables</code> ，目标是生成中间代码树 <code>MCT</code> 。对于特定的语法成分，可以对应生成相应的中间代码节点 <code>IR</code> 。LLVMIR中的成分与结构如下图所示：</p>
<p><img src="/img/loading.gif" data-original="/images/Compiler/编译器设计文档/中间代码树结构.png" alt="中间代码树结构" style="zoom:50%;"></p>
<p>LLVMIR中的成分主要有模块 <code>Module</code> ，对应语法成分中的 <code>CompUnit</code> ；全局值 <code>GlobalValue</code> ，对应语法成分中直接声明的全局变量常量；函数 <code>Function</code> ，对应语法成分中的 <code>FuncDef</code> ；基本块 <code>BasicBlock</code> ，存有需要先后执行的指令（一个基本块中的指令一定是一同执行的）；指令 <code>Instrunction</code> ，LLVMIR的基本指令，也是转化为MIPS指令的中间形式。一些常用的LLVMIR基本指令如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>LLVM IR</th>
<th>使用方法</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>add</code></td>
<td><code>&lt;result&gt; = add &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td>
<td>/</td>
</tr>
<tr>
<td><code>sub</code></td>
<td><code>&lt;result&gt; = sub &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td>
<td>/</td>
</tr>
<tr>
<td><code>mul</code></td>
<td><code>&lt;result&gt; = mul &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td>
<td>/</td>
</tr>
<tr>
<td><code>sdiv</code></td>
<td><code>&lt;result&gt; = sdiv &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td>
<td>有符号除法</td>
</tr>
<tr>
<td><code>srem</code></td>
<td><code>&lt;result&gt; = srem &lt;type&gt; &lt;op1&gt;, &lt;op2&gt;</code></td>
<td>有符号取余</td>
</tr>
<tr>
<td><code>icmp</code></td>
<td><code>&lt;result&gt; = icmp &lt;cond&gt; &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td>
<td>比较指令</td>
</tr>
<tr>
<td><code>and</code></td>
<td><code>&lt;result&gt; = and &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td>
<td>按位与</td>
</tr>
<tr>
<td><code>or</code></td>
<td><code>&lt;result&gt; = or &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td>
<td>按位或</td>
</tr>
<tr>
<td><code>call</code></td>
<td><code>&lt;result&gt; = call [ret attrs] &lt;ty&gt; &lt;name&gt;(&lt;...args&gt;)</code></td>
<td>函数调用</td>
</tr>
<tr>
<td><code>alloca</code></td>
<td><code>&lt;result&gt; = alloca &lt;type&gt;</code></td>
<td>分配内存</td>
</tr>
<tr>
<td><code>load</code></td>
<td><code>&lt;result&gt; = load &lt;ty&gt;, ptr &lt;pointer&gt;</code></td>
<td>读取内存</td>
</tr>
<tr>
<td><code>store</code></td>
<td><code>store &lt;ty&gt; &lt;value&gt;, ptr &lt;pointer&gt;</code></td>
<td>写内存</td>
</tr>
<tr>
<td><code>getelementptr</code></td>
<td><code>&lt;result&gt; = getelementptr &lt;ty&gt;, ptr &lt;ptrval&gt; {, &lt;ty&gt; &lt;idx&gt;}*</code></td>
<td>计算目标元素的位置（数组部分会单独详细说明）</td>
</tr>
<tr>
<td><code>phi</code></td>
<td><code>&lt;result&gt; = phi [fast-math-flags] &lt;ty&gt; [&lt;val0&gt;, &lt;label0&gt;], ...</code></td>
<td>/</td>
</tr>
<tr>
<td><code>zext..to</code></td>
<td><code>&lt;result&gt; = zext &lt;ty&gt; &lt;value&gt; to &lt;ty2&gt;</code></td>
<td>将 <code>ty</code> 的 <code>value</code> 的 type 扩充为 <code>ty2</code>（zero extend）</td>
</tr>
<tr>
<td><code>trunc..to</code></td>
<td><code>&lt;result&gt; = trunc &lt;ty&gt; &lt;value&gt; to &lt;ty2&gt;</code></td>
<td>将 <code>ty</code> 的 <code>value</code> 的 type 缩减为 <code>ty2</code>（truncate）</td>
</tr>
<tr>
<td><code>br</code></td>
<td><code>br i1 &lt;cond&gt;, label &lt;iftrue&gt;, label &lt;iffalse&gt;</code> <br><code>br label &lt;dest&gt;</code></td>
<td>改变控制流</td>
</tr>
<tr>
<td><code>ret</code></td>
<td><code>ret &lt;type&gt; &lt;value&gt;</code>, <code>ret void</code></td>
<td>退出当前函数，并返回值</td>
</tr>
</tbody>
</table>
</div>
<p>想要对中间代码成分进行分析，首先应为各成分建立类型类 <code>ValurTypeIR</code> 。根据代码生成中出现的变量类型，可将其分为两类，基本类型和复合类型。</p>
<ul>
<li>基本变量类型：<ul>
<li><code>IntegerTypeIR</code> ：位数据类型，含有属性位数 <code>bits</code> ，代表数据所占的位数。 <code>bits = 32</code> ，代表 <code>int</code> 类型； <code>bits = 8</code> ，代表 <code>char</code> 类型； <code>bits = 1</code> ，代表 <code>bool</code> 类型。</li>
<li><code>VoidTypeIR</code> ：<code>void</code> 数据类型，仅 <code>FunctionIR</code> 中会出现。</li>
<li><code>LabelTypeIR</code> ：标签类型，代表当前变量的类型为标签。</li>
</ul>
</li>
<li>复合变量类型：<ul>
<li><code>ArrayTypeIR</code> ：数组类型，含有属性数组元素类型 <code>typeIR</code> 、数组元素个数 <code>elementNum</code> 。其中，本实验中规定数组元素类型 <code>typeIR</code> 仅能为位数据类型 <code>IntegerTypeIR</code> ，即只存在 <code>int</code> / <code>char</code> 类型的数组。</li>
<li><code>PointerTypeIR</code> ：指针类型，含有属性指针对象类型 <code>typeIR</code> 。其中，本实验中规定指针所指对象类型为数组类型 <code>ArrayTypeIR</code> （当含有为数组申请地址的指令时）和位数据类型 <code>IntegerTypeIR</code> （当含有普通地址指令时）。</li>
<li><code>FunctionTypeIR</code> ：函数类型，含有属性函数数据类型 <code>typeIR</code> 、函数形参数据类型 <code>paramTypes</code> 。</li>
</ul>
</li>
</ul>
<p>在建立成分类型类后，为各中间代码成分构建类，并对语法树 <code>AST</code> 遍历解析获得中间代码成分。所有的中间代码节点（除顶层模块），均继承于中间代码值类 <code>ValueIR</code> 。该类主要代表各种中间代码索要使用的值，最常用的子类是 <code>FunctionIR</code> （用于函数调用等指令中）、 <code>BasicBlockIR</code> （用于跳转等指令中）等。构建的中间代码成分类如下：</p>
<ul>
<li><p><code>ModuleIR</code> ：中间代码中的模块，代表整个程序。由于本次实验中涉及的待编译 <code>SysY</code> 语言文件都是单文件，因此 <code>ModuleIR</code> 唯一。其含有属性全局变量声明 <code>globalVariables</code> 、函数声明 <code>functions</code> 。在 <code>CompUnit</code> 解析中获得<code>ModuleIR</code> 。</p>
</li>
<li><p><code>GlobalVariableIR</code> ：中间代码中的全局变量声明。其含有属性变量名 <code>name</code> 、初始值 <code>initValue</code> 、是否是输出字符串 <code>isPrint</code> 。在 <code>Decl</code> 中，根据当前变量常量所在层数判断其是否是全局变量常量。</p>
</li>
<li><p><code>FunctionIR</code> ：中间代码中的函数（包括主函数）。其含有属性函数名 <code>name</code> 、函数参数 <code>params</code> 、函数含有的基本块 <code>blocks</code> 、函数中变量数量 <code>numVar</code> 。在 <code>FuncDef</code> 解析中获得 <code>FunctionIR</code> 。LLVMIR中变量以序号表示，每个函数中的变量编号均从 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.507ex" role="img" focusable="false" viewBox="0 -666 500 666"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container> 开始，因此可以内置函数 <code>allocVar</code> ，为函数申请新变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> VariableIR <span class="title function_">allocVar</span><span class="params">(ValueTypeIR typeIR)</span> {</span><br><span class="line">    <span class="type">VariableIR</span> <span class="variable">var</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VariableIR</span>(typeIR, numVar, name);</span><br><span class="line">    numVar++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">var</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>BasicBlockIR</code> ：中间代码中的基本块，存储需要一同执行的LLVMIR指令。其含有属性基本块标签 <code>label</code> 、基本块是否可以添加指令 <code>canAddInstr</code> 、基本块含有的指令 <code>instrs</code> 。在 <code>Block</code> 的解析中获得 <code>BasicBlockIR</code> （由于申请到的块在 <code>Block</code> 外可能需要使用，因此将新 <code>BasicBlockIR</code> 的申请放在 <code>FuncDef</code> 或 <code>Stmt</code> 的解析中）。在 <code>if</code> 或 <code>for</code> 这种含有条件 <code>Cond</code> 解析的语句中，需要注意额外新 <code>BasicBlockIR</code> 的申请。 </p>
<blockquote>
<p>对于普通的 <code>Cond</code> 判断，其结构应该是 <code>condBlock-trueBlock-falseBlock</code> 。条件判断块 <code>condBlock</code> 中含有跳转指令 <code>br cond, trueLabel, falseLabel</code> 。在条件 <code>Cond</code> 的解析中，需要满足短路求值原则。即对于逻辑与表达式和逻辑或表达式，当左侧表达式可以确定整体表达式值时，不访问右侧表达式。这意味着，当前访问表达式之前的表达式计算结果为真。对于不同形式的表达式，由于短路求值原则，跳转的标签也有所不同。</p>
<ul>
<li>对于逻辑或表达式 <code>B1 || B2</code> ， <code>B1</code> 对应的基本块 <code>block1</code> 的跳转指令，为真跳转到 <code>trueLabel</code> ，为假跳转到 <code>B2Label</code> ； <code>B2</code> 对应的基本块 <code>block2</code> 的跳转指令，为真跳转到 <code>trueLabel</code> ，为假跳转到 <code>falseLabel</code> 。 </li>
<li>对于逻辑与表达式 <code>B1 &amp;&amp; B2</code> ， <code>B1</code> 对应的基本块 <code>block1</code> 的跳转指令，为真跳转到 <code>B2Label</code> ，为假跳转到 <code>falseLabel</code> ； <code>B2</code> 对应的基本块 <code>block2</code> 的跳转指令，为真跳转到 <code>trueLabel</code> ，为假跳转到 <code>falseLabel</code> 。 </li>
<li>对于逻辑与或组合表达式 <code>B1 &amp;&amp; B2 || B3</code> ， <code>B1</code> 对应的基本块 <code>block1</code> 的跳转指令，为真跳转到 <code>B2Label</code> ，为假跳转到 <code>B3Label</code> ； <code>B2</code> 对应的基本块 <code>block2</code> 的跳转指令，为真跳转到 <code>trueLabel</code> ，为假跳转到 <code>B3Label</code> ； <code>B3</code> 对应的基本块 <code>block3</code> 的跳转指令，为真跳转到 <code>trueLabel</code> ，为假跳转到 <code>falseLabel</code> 。 </li>
<li>对于逻辑与或组合表达式 <code>B1 || B2 &amp;&amp; B3</code> ， <code>B1</code> 对应的基本块 <code>block1</code> 的跳转指令，为真跳转到 <code>trueLabel</code> ，为假跳转到 <code>B2Label</code> ； <code>B2</code> 对应的基本块 <code>block2</code> 的跳转指令，为真跳转到 <code>B3Label</code> ，为假跳转到 <code>falseLabel</code> ； <code>B3</code> 对应的基本块 <code>block3</code> 的跳转指令，为真跳转到 <code>trueLabel</code> ，为假跳转到 <code>falseLabel</code> 。 </li>
</ul>
<p>由于在 <code>Cond</code> 的解析函数中，无法获得具体的表达式的数量，因此只能在逻辑与或表达式的解析中创建新的基本块。在解析与或表达式时，出现与或符号，证明还存在下一个表达式，则在解析当前表达式之前应该建立新的基本块。解析逻辑或表达式新建的基本块（ <code>nextOrBlock</code> ，下一个逻辑或表达式块）应当一同传入逻辑与表达式的解析函数中。同时可以观察到，像 <code>B1 || B2 &amp;&amp; B3</code> 这种形式， <code>B2</code> 后不存在下一个逻辑或表达式块，为假时跳转到 <code>falseLabel</code> 。因此，在逻辑或表达式新建基本块时应判断当前是否是最后一个逻辑或表达式，以决定跳转指令的目标。</p>
</blockquote>
<p>同时，应注意，LLVMIR规定，一个基本块中只能出现一个改变控制流的指令（ <code>br</code> 或 <code>ret</code> ），因此在基本块出现该类指令后将 <code>canAddInstr</code> 置为 <code>false</code> ，后续产生的指令不能再添加到该基本块中。</p>
</li>
<li><p><code>ConstIR</code> ：中间代码中的常量。其含有属性常量数值 <code>value</code> 。</p>
<ul>
<li><code>ConstArrayIR</code> ：中间代码中的数组常量，继承 <code>ConstIR</code> 。其含有属性数组元素 <code>values</code> 。</li>
<li><code>ConstStringIR</code> ：中间代码中的字符串常量，继承 <code>ConstIR</code> 。区别于普通的字符串常量（那将在字符数组的初始化中解决），这个字符串常量专指 <code>printf</code> 中的输出字符串。其含有属性字符串名 <code>name</code> 、字符串值 <code>value</code> 、字符串长度 <code>length</code> 。</li>
</ul>
</li>
<li><p><code>VariableIR</code> ：中间代码中的变量。其含有属性变量名 <code>name</code> 、变量编号 <code>pos</code> 、变量值 <code>value</code> 、是否是全局变量 <code>isGlobal</code> 。对于普通变量和全局变量，其所使用的属性不同：全局变量使用变量名、变量值，局部变量使用变量编号、变量值。</p>
</li>
<li><p><code>InstrIR</code> ：中间代码中的指令。其含有属性操作符号 <code>op</code> 。</p>
<ul>
<li><code>AllocateIR</code> ：申请地址的指令，含有属性申请结果 <code>result</code> 、申请类型 <code>type</code> 。主要出现在变量常量声明中，为要声明的标识申请足够的存储地址。</li>
<li><code>StoreIR</code> ：存储变量的指令，含有属性存储值 <code>value</code> 、存储地址 <code>address</code> 。主要出现在赋值语句中，将新值存储在变量对应的地址。</li>
<li><code>LoadIR</code> ：加载变量的指令，含有属性加载到的值 <code>value</code> 、加载地址 <code>address</code> 。主要出现在对变量的使用语句中，将变量的值从对应地址中取出并参与运算。</li>
<li><code>CallIR</code> ：调用函数的指令，含有属性调用函数 <code>function</code> 、函数返回值 <code>result</code> （函数是 <code>void</code> 型时为空）、函数实参 <code>params</code> 。主要出现在一元表达式的函数调用中，确定调用函数，将解析的表达式作为实参存入指令，获得返回值。</li>
<li><code>GetElementIR</code> ：计算数组元素地址的指令，含有属性元素地址 <code>result</code> 、数组基地址 <code>address</code> 、元素索引 <code>index</code> 。主要出现在数组元素的访问中。</li>
<li><code>BinaryIR</code> ：二元有符号计算指令，含有属性左值 <code>lValue</code> 、右值 <code>rValue</code> 、结果 <code>result</code> 。主要出现在加减乘除表达式的解析中，根据计算类型设置指令类型。</li>
<li><code>BTypeTranIR</code> ：数据类型转换指令，含有属性转换值 <code>value</code> 、转换结果 <code>result</code> 。主要出现在各种数据类型转换的赋值中。</li>
<li><code>IcmpIR</code> ：数据比较指令，含有属性左值 <code>lValue</code> 、右值 <code>rValue</code> 、结果 <code>result</code> 。主要出现在关系表达式和相等性表达式。</li>
<li><code>BrIR</code> ：跳转指令，含有属性是否存在条件 <code>haveCond</code> 、跳转块 <code>block</code> 、跳转条件 <code>cond</code> 、为真时跳转块 <code>trueBlock</code> 、为假时跳转块 <code>falseBlock</code> 。有条件的跳转指令使用跳转条件、为真时跳转块、为假时跳转块；无条件的跳转指令使用跳转块。主要出现在各 <code>BasicBlock</code> 末尾改变控制流。</li>
<li><code>RetIR</code> ：返回指令，含有属性返回结果 <code>result</code> （函数是 <code>void</code> 型时为空）。主要出现在 <code>return</code> 语句的解析中。</li>
</ul>
</li>
</ul>
<p>完成全部预备类构建后，即可遍历语法树 <code>AST</code> ，按照上文中所述的解析方式，构建对应的LLVMIR成分，组成中间代码树 <code>MCT</code> 。</p>
<h3 id="目标代码生成设计"><a href="#目标代码生成设计" class="headerlink" title="目标代码生成设计"></a>目标代码生成设计</h3><p>在目标代码翻译器 <code>Translator</code> 中，读入生成的中间代码树 <code>MCT</code> ，目标是生成目标代码树 <code>OCT</code> 。目标代码的结构与中间代码相似，顶层模块 <code>ModuleMips</code> 、全局声明 <code>GlobalMips</code> 、函数 <code>FunctionIR</code> 、基本块 <code>BlockMips</code> 、指令 <code>InstrMips</code> 。因此，目标代码生成的主要思路是遍历中间代码树，生成对应的目标代码部分。</p>
<p>对于模块 <code>ModuleIR</code> 、全局声明 <code>GlobalVariableIR</code> 、基本块 <code>BasicBlockIR</code> 的遍历解析，难度较小，基本为直译，因此不过多赘述。主要说明函数 <code>FunctionIR</code> 和指令 <code>InstrIR</code> 的翻译。此次实验中使用到的MIPS指令如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>MIPS</th>
<th>使用方法</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>La</code></td>
<td><code>La $1, &lt;label&gt;</code></td>
<td>从标签加载数值</td>
</tr>
<tr>
<td><code>Li</code></td>
<td><code>Li $1, &lt;value&gt;</code></td>
<td>从立即数加载数值</td>
</tr>
<tr>
<td><code>move</code></td>
<td><code>move $1, $2</code></td>
<td>将寄存器值赋给另一寄存器</td>
</tr>
<tr>
<td><code>mfhi</code></td>
<td><code>mfhi $1</code></td>
<td>读 <code>hi</code> 寄存器</td>
</tr>
<tr>
<td><code>mflo</code></td>
<td><code>mflo $1</code></td>
<td>读 <code>lo</code> 寄存器</td>
</tr>
<tr>
<td><code>addu</code></td>
<td><code>addu $1, $2, $3</code></td>
<td>无符号加</td>
</tr>
<tr>
<td><code>addiu</code></td>
<td><code>addiu $1, $2, &lt;value&gt;</code></td>
<td>无符号加立即数</td>
</tr>
<tr>
<td><code>subu</code></td>
<td><code>subu $1, $2, $3</code></td>
<td>无符号减</td>
</tr>
<tr>
<td><code>mult</code></td>
<td><code>mult $1, $2</code></td>
<td>有符号乘</td>
</tr>
<tr>
<td><code>div</code></td>
<td><code>div $1, $2</code></td>
<td>有符号除</td>
</tr>
<tr>
<td><code>slt</code></td>
<td><code>slt $1, $2, $3</code></td>
<td>有符号小于置1</td>
</tr>
<tr>
<td><code>andi</code></td>
<td><code>andi $1, $2, $3</code></td>
<td>与立即数</td>
</tr>
<tr>
<td><code>sll</code></td>
<td><code>sll $1, $2, &lt;offset&gt;</code></td>
<td>逻辑左移</td>
</tr>
<tr>
<td><code>srl</code></td>
<td><code>srl $1, $2, &lt;offset&gt;</code></td>
<td>逻辑右移</td>
</tr>
<tr>
<td><code>sra</code></td>
<td><code>sra $1, $2, &lt;offset&gt;</code></td>
<td>算术右移</td>
</tr>
<tr>
<td><code>lw</code></td>
<td><code>lw $1, &lt;offset&gt;($2)</code></td>
<td>加载字</td>
</tr>
<tr>
<td><code>sw</code></td>
<td><code>sw $1, &lt;offset&gt;($2)</code></td>
<td>存储字</td>
</tr>
<tr>
<td><code>beq</code></td>
<td><code>beq $1, $2, &lt;label&gt;</code></td>
<td>相等时转移</td>
</tr>
<tr>
<td><code>bne</code></td>
<td><code>bne $1, $2, &lt;label&gt;</code></td>
<td>不等时转移</td>
</tr>
<tr>
<td><code>bgez</code></td>
<td><code>bgez $1, &lt;label&gt;</code></td>
<td>大于等于0时转移</td>
</tr>
<tr>
<td><code>blez</code></td>
<td><code>blez $1, &lt;label&gt;</code></td>
<td>小于等于0时转移</td>
</tr>
<tr>
<td><code>bgtz</code></td>
<td><code>bgtz $1, &lt;label&gt;</code></td>
<td>大于0时转移</td>
</tr>
<tr>
<td><code>bltz</code></td>
<td><code>bltz $1, &lt;label&gt;</code></td>
<td>小于0时转移</td>
</tr>
<tr>
<td><code>j</code></td>
<td><code>j &lt;label&gt;</code></td>
<td>跳转</td>
</tr>
<tr>
<td><code>jal</code></td>
<td><code>jal &lt;label&gt;</code></td>
<td>跳转并链接</td>
</tr>
<tr>
<td><code>jr</code></td>
<td><code>jr $1</code></td>
<td>跳转至寄存器</td>
</tr>
<tr>
<td><code>syscall</code></td>
<td><code>syscall</code></td>
<td>系统调用</td>
</tr>
</tbody>
</table>
</div>
<p>对于MIPS指令的翻译，最重要的是寄存器的存储和分配系统的建立。建立寄存器类 <code>Register</code> ，其含有属性名称 <code>name</code> 、编号 <code>id</code> 、是否正在使用 <code>use</code> 、寄存器中值 <code>value</code> 。同时建立寄存器表类 <code>RegisterTable</code> ，负责寄存器的管理。对于寄存器的分配，采用的策略是如果有未在使用的寄存器，即分配该寄存器；如果全部寄存器都在使用，则将 <code>$t0</code> 的值压入数据栈中，分配 <code>$t0</code> 。对于该种分配方法，核心是寄存器应该在何时释放。寄存器的释放原则是每次存入寄存器的值只能使用一次，使用后立即释放（出于正确性考虑，再使用寄存器前，应检查该寄存器内数据是否是当前变量），以防止寄存器数量不够用以及控制流改变引发的寄存器冲突问题。寄存器的释放过程在指令中进行。</p>
<p>由于每一个 <code>VariableIR</code> 可能被不止一次使用，因此应该建立中间代码变量符号表，以便后续使用。建立中间代码符号类 <code>SymbolMips</code> ，其含有属性变量名 <code>name</code> 、是否是全局声明 <code>isGlobal</code> 、是否是立即数 <code>isImm</code> 、是否是绝对地址 <code>isAbsolute</code> 、分配的寄存器 <code>register</code> 、数值 <code>value</code> 、存储的相对地址 <code>addrOffset</code> 。对于普通变量或立即数，填写相应属性即可。对于代表地址的变量，则需要要特殊处理。对于存储全局声明标签的变量，需要标记 <code>isAbsolute</code> 为真，后续使用时可能出现相对地址与绝对地址之间的转化。</p>
<p>在完成预备类的构建后，进行 <code>InstrIR</code> 的翻译：</p>
<ul>
<li><code>AllocateIR</code> ：为变量申请地址，不增加MIPS指令，只改变当前的 <code>offset</code> 。为变量构建中间代码变量符号，并将当前相对 <script type="math/tex">sp</script> 的偏移量 <code>offset</code> 赋值给相应属性即可。按照申请的地址大小，增加 <code>offset</code> 的值（ <code>int</code> / <code>char</code> 型均按照一个字节存储，变量为数组时按照元素数量改变 <code>offset</code> 的值）。</li>
<li><code>StoreIR</code> ：存储变量，使用 <code>sw $1, &lt;offset&gt;($2)</code> 即可。应注意判断存储到的指针变量类型：若该变量是相对地址，则使用 <code>sw $1, &lt;offset&gt;($sp)</code> ；若该变量是绝对地址，则使用 <code>sw $1, 0($2)</code> 。完成存储后，释放分配给值变量和地址变量的寄存器。</li>
<li><code>LoadIR</code> ：加载变量，使用 <code>lw $1, &lt;offset&gt;($2)</code> 即可。对于待加载的指针变量类型的判定和 <code>StoreIR</code> 相同。完成加载后，释放分配给地址变量的寄存器。</li>
<li><code>CallIR</code> ：调用函数，使用 <code>jal &lt;label&gt;</code> 跳转到函数位置即可。</li>
<li><code>GetElementIR</code> ：计算数组元素地址， <code>elementAddr = baseAddr + index * 4</code> ， <code>elementAddr</code> 统一使用绝对地址。如果基地址为绝对地址，直接使用 <code>sll</code> 和 <code>addu</code> 指令计算即可。如果基地址为相对地址，则需要额外加 <code>$sp</code> 。完成计算后，释放分配给基地址变量和索引变量的寄存器。</li>
<li><code>BinaryIR</code> ：二元有符号计算，使用对应的二元计算指令即可。应注意，为防止计算中的数值溢出，加减指令应使用 <code>addu</code> 和 <code>subu</code> 。对于乘除模，使用 <code>mult</code> 、 <code>div</code> 指令搭配 <code>mfhi</code> 、 <code>mflo</code> 指令即可。完成计算后，释放分配给算式左值右值的寄存器。</li>
<li><code>BTypeTranIR</code> ：数据类型转换，由于 <code>int</code> / <code>char</code> 型均按照一个字节存储，理论上结果变量使用值变量的寄存器即可。但应注意，对于 <code>trunc</code> 指令，将 <code>int</code> 型缩减到 <code>char</code> 型，高24位数据应当舍弃。因此若为 <code>trunc</code> 指令，则添加 <code>andi $1, $2, 0xff</code> 。</li>
<li><code>IcmpIR</code> ：二元有符号比较，按照比较类型添加指令即可。由于LLVMIR中是先比较得到结果再进行跳转，而MIPS中只有 <code>slt</code> 一种比较指令，其他类型比较只有直接的跳转指令。因此为了不破坏LLVMIR指令的原子性，需要使用组合的 <code>slt</code> 指令。将 <code>&lt;=</code> / <code>&gt;=</code> 转化为 <code>!&gt;</code> / <code>!&lt;</code> ， <code>==</code> / <code>!=</code> 转化为 <code>!&gt; &amp;&amp; !&lt;</code> / <code>&gt; || &lt;</code> ，使用 <code>slt</code> 搭配逻辑运算指令即可实现其他类型的比较。完后比较后，释放分配给比较式左值右值的寄存器。</li>
<li><code>BrIR</code> ：各类跳转。对于 <code>br label</code> ，可直接翻译为 <code>j &lt;label&gt;</code> ；对于 <code>br cond, trueLabel, falseLabel</code> ，可翻译为 <code>beq cond, 0, &lt;falseLabel&gt;</code> 与 <code>j &lt;trueLabel&gt;</code> 的组合。对于后者，完成比较后，释放分配给条件的寄存器。</li>
<li><code>RetIR</code> ：函数返回。对于存在返回值的 <code>RetIR</code> 指令，首先需要将返回值赋值给 <code>$v0</code> 及 <code>$v1</code> 。由于文法中规定，返回值至多为一个值，因此只使用 <code>$v0</code> 即足够。完成赋值后， <code>jr $ra</code> 返回调用前下一条指令即可。</li>
</ul>
<p>由于MIPS中只存在全局寄存器和数据栈，不存在函数形参和实参的概念，因此 <code>FunctionMips</code> 的处理与 <code>FunctionIR</code> 的处理有所不同。在调用函数时，首先应进行压栈，将目前全部寄存器中的数据压入栈中，并按照压栈的数据数量改变 <code>$sp</code> 的值，防止函数解析时改变寄存器值而造成的错误。将实参解析后存入 <code>$a0 - $a3</code> 寄存器中，如果实参数量超过 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.532ex" role="img" focusable="false" viewBox="0 -677 500 677"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g></g></g></svg></mjx-container> 个，则将多余的实参压栈。进入函数解析后，首先应将 <code>$sp</code> 和实参取出并存在栈中。由于可能存在参数数量超过 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.532ex" role="img" focusable="false" viewBox="0 -677 500 677"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g></g></g></svg></mjx-container> 个的情况， <code>$a0</code> 对应的参数应当存入 <code>offset = 4</code> 的地址，会造成形参的污染，因此形参的存储应从后向前进行。函数解析中如果出现调用其他函数的情况，重复上述操作即可。行进到 <code>ret</code> 语句时取出 <code>$sp</code> ，并加入 <code>jr $ra</code> 。完成函数解析并返回调用前下一条指令后，将调用前压入栈中的数据从栈中取出（在出栈前可以先释放全部临时寄存器，以防函数遗留数据导致寄存器后期无法使用），并按照压栈的数据数量改变 <code>$sp</code> 的值。</p>
<hr>
<h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><h3 id="中间代码优化"><a href="#中间代码优化" class="headerlink" title="中间代码优化"></a>中间代码优化</h3><p>中间代码优化主要有以SSA形式建立中间语言、死代码删除、GVN&amp;GCN建立、常量提取等。由于时间原因，本次实验中编译器未进行中间代码优化。</p>
<h3 id="目标代码优化"><a href="#目标代码优化" class="headerlink" title="目标代码优化"></a>目标代码优化</h3><p>目标代码优化主要有指令选择、图着色寄存器分配、乘除法优化、基本块合并和窥孔优化。本次实验中，主要完成了指令选择、无用指令删除、乘除法优化。</p>
<h4 id="指令选择"><a href="#指令选择" class="headerlink" title="指令选择"></a>指令选择</h4><p>为了实现更多功能，以及更加方便翻译高级语言，MIPS提供了大量的伪指令使用，例如<code>subi</code>、<code>move</code>、<code>ble</code> 等，能够缩短指令的条数，增加代码的可读性。但实际上，伪指令会被翻译为多条实际指令进行使用。以 <code>subi</code> 为例，一条 <code>subi $1, $2, 1000</code> 的指令，会被MIPS的模拟器Mars翻译为 <code>addi $3, $0, 0x3e8</code> 和 <code>sub $1, $2, $3</code> 两条指令；但是如果直接使用 <code>addi $1, $2, -1000</code> 的指令，不会被翻译为额外指令，可以提高程序执行效率。因此，将全部 <code>subi</code> 指令替换为 <code>addi</code> 指令。程序中涉及到 <code>subi</code> 指令的部分主要是调用函数时 <code>$sp</code> 的改变，将这部分指令替换即可。</p>
<p>在目标代码翻译的过程中，出于保护LLVMIR指令原子性的考虑，将 <code>IcmpIR</code> 翻译为 <code>slt</code> 和逻辑运算指令搭配的形式，如 <code>%res = icmp eq i32 %1, %2</code> ，翻译为MIPS指令就是 <code>slt $t2, $t1, $t0</code> 、 <code>slt $t1, $t0, $t1</code> 、 <code>or $t2, $t2, $t1</code> 、 <code>xor $t2, $t2, 1</code> 四条指令，最终寄存器 <code>$t2</code> 存储的就是比较结果。由于比较式出现在 <code>Cond</code> 中，其后通常伴随着跳转指令，因此可以对其进行优化。比如说源代码 <code>if(i == 1) {...}</code> ，直接生成LLVMIR指令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%main_var2 = load i32, i32* %main_var1</span><br><span class="line">%main_var3 = icmp eq i32 %main_var2, 1</span><br><span class="line">br i1 %main_var3, label %trueLabel, label %falseLabel</span><br><span class="line">trueLabel:</span><br><span class="line">...</span><br><span class="line">falseLabel:</span><br></pre></td></tr></table></figure>
<p>优化前优化后的MIPS指令如下：</p>
<figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 优化前：</span></span><br><span class="line"><span class="keyword">lw </span>$<span class="built_in">t0</span>, <span class="number">4</span>($<span class="built_in">sp</span>)</span><br><span class="line"><span class="keyword">move </span>$<span class="built_in">t1</span>, $<span class="built_in">t0</span></span><br><span class="line">li $<span class="built_in">t0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">slt </span>$<span class="built_in">t2</span>, $<span class="built_in">t1</span>, $<span class="built_in">t0</span></span><br><span class="line"><span class="keyword">slt </span>$<span class="built_in">t1</span>, $<span class="built_in">t0</span>, $<span class="built_in">t1</span></span><br><span class="line"><span class="keyword">or </span>$<span class="built_in">t2</span>, $<span class="built_in">t2</span>, $<span class="built_in">t1</span></span><br><span class="line"><span class="keyword">xor </span>$<span class="built_in">t2</span>, $<span class="built_in">t2</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">beq </span>$<span class="built_in">t2</span>, $<span class="built_in">zero</span>, falseLabel</span><br><span class="line"><span class="symbol">trueLabel:</span></span><br><span class="line">...</span><br><span class="line"><span class="symbol">falseLabel:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#优化后</span></span><br><span class="line"><span class="keyword">lw </span>$<span class="built_in">t0</span>, <span class="number">4</span>($<span class="built_in">sp</span>)</span><br><span class="line"><span class="keyword">move </span>$<span class="built_in">t1</span>, $<span class="built_in">t0</span></span><br><span class="line">li $<span class="built_in">t0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">bne </span>$<span class="built_in">t1</span>, $<span class="built_in">t0</span>, falseLabel</span><br><span class="line"><span class="symbol">trueLabel:</span></span><br><span class="line">...</span><br><span class="line"><span class="symbol">falseLabel:</span></span><br></pre></td></tr></table></figure>
<p>其他比较类型 <code>!= | &gt;= | &lt;=</code> 与上述优化相似。</p>
<h4 id="无用指令删除"><a href="#无用指令删除" class="headerlink" title="无用指令删除"></a>无用指令删除</h4><p>在MIPS指令中，每个基本块不强制要求出现改变控制流的跳转指令，如果该块不存在跳转指令，则默认按照顺序执行。由于在目标代码翻译的过程中，对于带条件的 <code>br</code> 指令 <code>br cond, trueLabel, falseLabel</code> ，采取的翻译模式是 <code>beq cond, 0, &lt;falseLabel&gt;</code> 与 <code>j &lt;trueLabel&gt;</code> 的组合，而通常来讲 <code>j &lt;trueLabel&gt;</code> 跳转到的 <code>trueBlock</code> 即是下一个基本块。同时，在中间代码生成的过程中，可能会出现仅含有 <code>br</code> 指令的基本块。这类块在目标代码翻译中会被翻译为 <code>j &lt;label&gt;</code> ，且通常跳转到下一个基本块。在这些情况中，会出现多余的跳转指令。因此可以特判跳转指令，如果跳转到的 <code>&lt;label&gt;</code> 和下一个块的标签相同，则省略这条跳转指令。</p>
<h4 id="乘除法优化"><a href="#乘除法优化" class="headerlink" title="乘除法优化"></a>乘除法优化</h4><p>在MIPS指令中，乘除法计算指令 <code>mult</code> 和 <code>div</code> 消耗时间相比 <code>sll</code> 、<code>srl</code> 等移位指令， <code>addu</code> 、<code>subu</code> 等计算指令过大，需要进行一定优化。按照程序设置，在中间代码生成的过程中，当表达式左右两侧都为常量值时，会直接计算出结果。因此在目标代码翻译的过程中，只可能出现两个变量计算或一个变量一个常量值计算。乘除法优化基于一个变量一个常量值计算进行，主要原理是通过判定常量值是否是特定数值，优化乘除计算指令。在优化过程中，我们保证除数为正，当除数为负数时添加 <code>subu $1, $0, $1$</code> 即可。</p>
<h5 id="乘法优化"><a href="#乘法优化" class="headerlink" title="乘法优化"></a>乘法优化</h5><ul>
<li>数值为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.557ex" role="img" focusable="false" viewBox="0 -666 500 688"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></svg></mjx-container> ：可以直接对结果寄存器赋 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.557ex" role="img" focusable="false" viewBox="0 -666 500 688"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></svg></mjx-container> 值。</li>
<li>数值为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.507ex" role="img" focusable="false" viewBox="0 -666 500 666"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></svg></mjx-container> 的幂数：使用 <code>sll</code> 指令，计算该常量对于 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.507ex" role="img" focusable="false" viewBox="0 -666 500 666"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></svg></mjx-container> 的幂次，左移相应位数。</li>
<li>数值与小于它的最大 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.507ex" role="img" focusable="false" viewBox="0 -666 500 666"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></svg></mjx-container> 的幂数差小于 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.532ex" role="img" focusable="false" viewBox="0 -677 500 677"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g></g></g></svg></mjx-container> ：按照实验设定， <code>mult</code> 的时间消耗是 <code>sll</code> 、 <code>addu</code> 的 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.557ex" role="img" focusable="false" viewBox="0 -666 500 688"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></g></g></g></svg></mjx-container> 倍，因此部分乘数可以分解为 <code>sll + n * addu</code> 的形式，如数值为 <code>10 = 8 + 2</code> ，此时将 <code>x * 10</code> 就可以转变为 <code>x &lt;&lt; 3 + x + x</code> ，时间变短。数值与大于它的最小 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.507ex" role="img" focusable="false" viewBox="0 -666 500 666"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></svg></mjx-container> 的幂数差小于 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.532ex" role="img" focusable="false" viewBox="0 -677 500 677"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g></g></g></svg></mjx-container> 的同理，分解为 <code>sll + n * subu</code> 的形式。</li>
<li>其他数值：无法进行优化，正常添加指令即可。</li>
</ul>
<h5 id="除法优化"><a href="#除法优化" class="headerlink" title="除法优化"></a>除法优化</h5><ul>
<li><p>数值为1：可以直接对结果寄存器赋原值。</p>
</li>
<li><p>数值为2的幂数：使用 <code>sra</code> 指令，计算该常量对于2的幂次，右移相应位数。移位计算的结果是除法结果向下取整，如 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="7.542ex" height="1.557ex" role="img" focusable="false" viewBox="0 -666 3333.6 688"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(500,0)"></path><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(778,0)"></path></g><g data-mml-node="mo" transform="translate(1555.8,0)"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(2833.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></svg></mjx-container> 、 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="11.062ex" height="1.692ex" role="img" focusable="false" viewBox="0 -666 4889.6 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(778,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(500,0)"></path><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(778,0)"></path></g><g data-mml-node="mo" transform="translate(2333.8,0)"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g><g data-mml-node="mo" transform="translate(3611.6,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(4389.6,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g></g></g></svg></mjx-container> 。若被除数小于 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.557ex" role="img" focusable="false" viewBox="0 -666 500 688"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></svg></mjx-container> ，除法结果应当是移位计算结果加1。因此，首先使用 <code>srl $2, $1, 31</code> 获得被除数的符号位，并与移位结果相加（若被除数为正，符号位为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.557ex" role="img" focusable="false" viewBox="0 -666 500 688"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></svg></mjx-container> ，除法结果等于移位计算结果；若被除数为负，符号位为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.507ex" role="img" focusable="false" viewBox="0 -666 500 666"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container> ，除法结果等于移位计算结果加 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.507ex" role="img" focusable="false" viewBox="0 -666 500 666"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container> ）。</p>
</li>
<li><p>其他数值：按照实验设定， <code>div</code> 指令的时间消耗远大于 <code>mult</code> 的，因此可以借助乘法来优化除法。基本原理是先对原被除数乘一个大数，再右移获得最终结果。这个大数既要保证乘之后可以保证原除法结果，又要保证除法结果已经全部位于 <code>hi</code> 寄存器中。对于被除数 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container> 、除数 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex;" xmlns="http://www.w3.org/2000/svg" width="1.176ex" height="1.593ex" role="img" focusable="false" viewBox="0 -694 520 704"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g></g></g></svg></mjx-container> 、大数 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.986ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 878 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container> ，存在关系： <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.885ex;" xmlns="http://www.w3.org/2000/svg" width="13.14ex" height="2.582ex" role="img" focusable="false" viewBox="0 -750 5808.1 1141.4"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="230A" d="M174 734Q174 735 175 737T177 740T180 744T184 747T189 749T196 750Q206 748 214 735V-210H310H373Q401 -210 411 -213T422 -230T411 -247T369 -251Q362 -251 338 -251T298 -250H190Q178 -246 174 -234V734Z"></path></g><g data-mml-node="mfrac" transform="translate(444,0)"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(248.3,-345) scale(0.707)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><rect width="624.3" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(1308.3,0)"><path data-c="230B" d="M229 734Q229 735 230 737T232 740T235 744T239 747T244 749T251 750Q262 748 269 735V-235Q266 -240 256 -249L147 -250H77Q43 -250 32 -247T21 -230T32 -213T72 -209Q79 -209 99 -209T133 -210H229V734Z"></path></g><g data-mml-node="mo" transform="translate(2030,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mo" transform="translate(3085.8,0)"><path data-c="230A" d="M174 734Q174 735 175 737T177 740T180 744T184 747T189 749T196 750Q206 748 214 735V-210H310H373Q401 -210 411 -213T422 -230T411 -247T369 -251Q362 -251 338 -251T298 -250H190Q178 -246 174 -234V734Z"></path></g><g data-mml-node="mfrac" transform="translate(3529.8,0)"><g data-mml-node="mrow" transform="translate(296.3,394) scale(0.707)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="22C5" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250Z"></path></g><g data-mml-node="mi" transform="translate(878,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="msup" transform="translate(220,-391.4) scale(0.707)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,289) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mo" transform="translate(888,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1666,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g></g></g><rect width="1594.2" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(5364.1,0)"><path data-c="230B" d="M229 734Q229 735 230 737T232 740T235 744T239 747T244 749T251 750Q262 748 269 735V-235Q266 -240 256 -249L147 -250H77Q43 -250 32 -247T21 -230T32 -213T72 -209Q79 -209 99 -209T133 -210H229V734Z"></path></g></g></g></svg></mjx-container> ，其中大数 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.986ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 878 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container> 满足 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.312ex;" xmlns="http://www.w3.org/2000/svg" width="24.315ex" height="2.244ex" role="img" focusable="false" viewBox="0 -853.7 10747.2 991.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mo" transform="translate(888,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1666,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g></g></g><g data-mml-node="mo" transform="translate(2249.5,0)"><path data-c="2A7D" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM94 170Q102 172 104 172Q110 171 254 103T535 -30T678 -98Q694 -106 694 -118Q694 -136 676 -138H670L382 -2Q92 135 90 137Q83 142 83 154Q84 164 94 170Z"></path></g><g data-mml-node="mi" transform="translate(3305.3,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(4405.5,0)"><path data-c="22C5" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250Z"></path></g><g data-mml-node="mi" transform="translate(4905.8,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mo" transform="translate(5703.5,0)"><path data-c="2A7D" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM94 170Q102 172 104 172Q110 171 254 103T535 -30T678 -98Q694 -106 694 -118Q694 -136 676 -138H670L382 -2Q92 135 90 137Q83 142 83 154Q84 164 94 170Z"></path></g><g data-mml-node="msup" transform="translate(6759.3,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mo" transform="translate(888,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1666,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g></g></g><g data-mml-node="mo" transform="translate(8953.3,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="msup" transform="translate(9953.5,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g></g></g></g></svg></mjx-container> ，常数 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="7.289ex" height="1.731ex" role="img" focusable="false" viewBox="0 -683 3221.6 765"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mo" transform="translate(1165.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(2221.6,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path></g></g></g></svg></mjx-container> 保证该大数满足要求。为简化大数 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.986ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 878 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container> 的取值，设定 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="4.823ex" height="1.756ex" role="img" focusable="false" viewBox="0 -694 2131.6 776"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mo" transform="translate(575.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(1631.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container> 。可以得到代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.pow(<span class="number">2</span>, <span class="number">32</span> + l) / valueAbs);</span><br><span class="line"><span class="keyword">if</span> (!(Math.pow(<span class="number">2</span>, <span class="number">32</span> + l) &lt;= ((<span class="type">long</span>) m) * valueAbs &amp;&amp; </span><br><span class="line">		((<span class="type">long</span>) m) * valueAbs &lt;= Math.pow(<span class="number">2</span>, <span class="number">32</span> + l) + Math.pow(<span class="number">2</span>, l))) {</span><br><span class="line">	m++;</span><br><span class="line">} <span class="comment">// 保证m满足条件</span></span><br><span class="line"><span class="type">SymbolMips</span> <span class="variable">rSym</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SymbolMips</span>(m);</span><br><span class="line">symUseReg(rSym);</span><br><span class="line">curBlock.addInstr(<span class="keyword">new</span> <span class="title class_">MultMips</span>(lSym.getRegister(), rSym.getRegister()));</span><br><span class="line">curBlock.addInstr(<span class="keyword">new</span> <span class="title class_">MfhiMips</span>(resSym.getRegister()));</span><br><span class="line">curBlock.addInstr(<span class="keyword">new</span> <span class="title class_">SraMips</span>(resSym.getRegister(), resSym.getRegister(), l));</span><br><span class="line">curBlock.addInstr(<span class="keyword">new</span> <span class="title class_">SrlMips</span>(lSym.getRegister(), lSym.getRegister(), <span class="number">31</span>));</span><br><span class="line">curBlock.addInstr(<span class="keyword">new</span> <span class="title class_">AdduMips</span>(resSym.getRegister(), resSym.getRegister(), lSym.getRegister()));</span><br><span class="line">rSym.getRegister().freeReg();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>对于乘法优化，左值右值为常量时均可进行；对于除法优化，被除数为常量时不能进行，除数为常量时可以进行。</p>
<hr>
<h2 id="实验感想"><a href="#实验感想" class="headerlink" title="实验感想"></a>实验感想</h2><p>本次实验确实是一次量大难度高的任务，极具挑战性。在实验中，需要按照流程建立一套编译程序，从读入程序字符串出发，直到翻译为机器码，并能够执行获得结果。实验的架构设计是较为明确的，课程组提供的流程十分科学，可以进行模块化开发，词法分析、语法分析、符号表建立、中间代码生成、目标代码翻译，每一个模块相互独立，建立接口实现两两之间的信息交互。本次实验更像是在学完各种课程后的一次实战演练，将之前在计算机组成、操作系统等课中学到的各类知识结合运用起来。实验涉及的知识点很多，字符串解析、层次分析法、有限状态机等。可以使用的设计理念也有很多，如单例模式、工厂模式、观察者模式等。本次实验也是继OO课设后第一次自行设计实现大型项目，十分强调程序的层次化模块化抽象化，不仅锻炼了我的编码能力，还锻炼了我的架构设计思维。在实现编译流程后，还进行了一定的代码优化工作。这些工作向我展示了编译程序的底层优化逻辑，从程序结构和底层机器码的角度出发，既有对于无用部分的删除，也有偏硬方面的优化。美中不足的是，由于各项课程事务繁多，无法再对设计的编译器做进一步优化。整体来说，实验难度很大，从高级语言、LLVMIR到MIPS，结构理念都有很大的不同，每一次转换都是一种挑战，每一个语言下的Bug都曾令我困扰良久。但看着完成的七八千行代码，以及可以成功编译执行的各个代码文件，内心十分有成就感。文档末尾，是对一学期课程的反思与告别。也想感谢理论课老师、两位帮助我颇多的助教和每一位一同进步的同学，使得我能够在这条艰难的路上一直走下去。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Mr-MysteryMan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/03/17/Compiler/%E7%BC%96%E8%AF%91%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/">http://example.com/2025/03/17/Compiler/编译器设计文档/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">ENIGMA</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/C/">C</a><a class="post-meta__tags" href="/tags/Mips/">Mips</a><a class="post-meta__tags" href="/tags/LLVMIR/">LLVMIR</a></div><div class="post-share"><div class="social-share" data-image="/img/wuhui/16.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/03/16/Algorithm/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/" title="算法设计知识点整理"><img class="cover" src="/img/loading.gif" data-original="/img/wuhui/4.png" onerror="onerror=null;src='/img/footer.jpeg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">算法设计知识点整理</div></div><div class="info-2"><div class="info-item-1">基础知识渐进符号渐进紧确界  、渐进上界  、渐进下界  。 三种符号图例如下：  分析方法三种分析标准：最好情况分析、最差情况分析、平均（期望）情况分析。 和式求解  ，    ，   。  主定理法对形如  的递归式，存在解  。 进一步推导得出：当  时，存在  ；当  时，存在  ；当  时，存在  。 特别的，如果  的形式为  ，则可进一步简化为：当  时，存在  ；当  时，存在  ；当  时，存在  。 分治算法算法原理分解为子问题，递归求解，合并子问题。 经典问题归并排序对于一串数字数组进行排序。将原数组不断划分为小数组，直至该数组元素为  ，在进行比较。完成小数组比较后，比较合并数组。时间复杂度  。  对数列  从小到大排序。 分组为  。 第一次归并后   ，第二次归并后  ，第三次归并后   。    最大子数组在给定的数字数组（包含正数和负数）中，找到一个连续的子数组，使得这个子数组的元素和最大。将原数组不断划分为小数组，直至该数组元素为  ，计算元素和最大值。合并时比较中点左侧最大值，中点右侧最大值，跨中点最大值。时间复杂度为  。   对数列 ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/02/15/OS/Challenge-Shell%E4%BB%BB%E5%8A%A1%E6%96%87%E6%A1%A3/" title="Challenge-Shell任务文档"><img class="cover" src="/img/loading.gif" data-original="/img/wuhui/9.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-15</div><div class="info-item-2">Challenge-Shell任务文档</div></div><div class="info-2"><div class="info-item-1">实现不带 .b 后缀指令 你需要实现不带 .b 后缀的指令，但仍需兼容带有 .b 后缀的指令，如 ls 与 ls.b 都应能够正确列出当前目录下的文件。  外部指令的执行实际上是在spawn函数中打开可执行的指令文件创建新进程，并将其装载在新建子进程中，运行指令文件中的主程序。实现思路是更改文件打开程序，当文件名对应文件存在时直接打开即可，不存在时文件名末尾加.b再次尝试打开。 在spawn()函数中更改文件打开方式，具体代码如下： 1234567891011121314151617//user/lib/spawn.c spawn()if ((fd = open(prog, O_RDONLY)) &lt; 0) //尝试打开文件{	int len = 0;	char newProg[128];	for (len = 0; len &lt; 128 &amp;&amp; prog[len] != '\0'; len++)	{		newProg[len] = prog[len];	}	newProg[len++] = '.';	newProg[len++] =...</div></div></div></a><a class="pagination-related" href="/2025/02/15/OS/Lab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/" title="Lab0实验报告"><img class="cover" src="/img/loading.gif" data-original="/img/wuhui/17.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-15</div><div class="info-item-2">Lab0实验报告</div></div><div class="info-2"><div class="info-item-1">思考题Thinking 0.1   git commit -m "22373347"   不一样，第一次执行命令之前README.txt文件是新增文件，执行之后暂存区以含有该文件，所以再次执行会显示为修改后文件。  Thinking 0.2 add the file对应git add stage the file对应git add commit对应git commit  Thinking 0.3 git checkout -- print.c git reset HEAD print.c + git checkout -- print.c git rm --cached hello.txt  Thinking 0.4git reset --hard HEAD^和git reset --hard &lt;hash&gt;两条命令都可以进行回溯，其中HEAD^会回溯到上一条提交记录，&lt;hash&gt;会回溯到哈希值所指的提交记录；使用哈希值可以回溯到老版本，也可以在回溯到老版本之后重新回溯到新版本。 Thinking 0.5 Thinking...</div></div></div></a><a class="pagination-related" href="/2025/02/15/OS/Lab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/" title="Lab1实验报告"><img class="cover" src="/img/loading.gif" data-original="/img/wuhui/19.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-15</div><div class="info-item-2">Lab1实验报告</div></div><div class="info-2"><div class="info-item-1">思考题Thinking 1.1 x86原生工具链和mips交叉编译工具链对比：  x86原生工具链：  编译但未链接文件x86程序：   链接后文件x86程序：         mips交叉编译工具链：  编译但未链接mips程序：    链接后mips程序：      objdump传入参数：  -d：—disassemble[=symbol]，反汇编特定指令机器码的节；  -D：—disassemble-all，反汇编全部节代码；  -S：—source，代码段反汇编同时，将反汇编代码和源代码交替显示；  -g：—debugging，显示调试信息；  -l：—line-numbers，代码段反汇编同时，显示反汇编代码行数。     Thinking 1.2 解析/target/mos：    readelf解析readelf文件和hello文件：可见有多项因素会影响文件是否会被自定义readelf解析，如是大端项还是小端项，如文件位数（32位或64位）    Thinking...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/avatar.png" onerror="this.onerror=null;this.src='/img/logo.png'" alt="avatar"/></div><div class="author-info-name">Mr-MysteryMan</div><div class="author-info-description">广告位招租</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Mr-MysteryMan"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Mr-MysteryMan" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="mailto:1234567@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E7%BC%96%E8%AF%91%E5%99%A8%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">参考编译器介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">总体结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.2.</span> <span class="toc-text">接口设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87"><span class="toc-number">1.3.</span> <span class="toc-text">文件组织</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.</span> <span class="toc-text">编译器总体设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84-1"><span class="toc-number">2.1.</span> <span class="toc-text">总体结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1-1"><span class="toc-number">2.2.</span> <span class="toc-text">接口设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87-1"><span class="toc-number">2.3.</span> <span class="toc-text">文件组织</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.</span> <span class="toc-text">词法分析设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.</span> <span class="toc-text">语法分析设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E8%AE%BE%E8%AE%A1"><span class="toc-number">5.</span> <span class="toc-text">语义分析设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E8%AE%BE%E8%AE%A1"><span class="toc-number">6.</span> <span class="toc-text">错误处理设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.</span> <span class="toc-text">代码生成设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.1.</span> <span class="toc-text">中间代码生成设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.2.</span> <span class="toc-text">目标代码生成设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96"><span class="toc-number">8.</span> <span class="toc-text">代码优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96"><span class="toc-number">8.1.</span> <span class="toc-text">中间代码优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96"><span class="toc-number">8.2.</span> <span class="toc-text">目标代码优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%80%89%E6%8B%A9"><span class="toc-number">8.2.1.</span> <span class="toc-text">指令选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E7%94%A8%E6%8C%87%E4%BB%A4%E5%88%A0%E9%99%A4"><span class="toc-number">8.2.2.</span> <span class="toc-text">无用指令删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%98%E9%99%A4%E6%B3%95%E4%BC%98%E5%8C%96"><span class="toc-number">8.2.3.</span> <span class="toc-text">乘除法优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%98%E6%B3%95%E4%BC%98%E5%8C%96"><span class="toc-number">8.2.3.1.</span> <span class="toc-text">乘法优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%99%A4%E6%B3%95%E4%BC%98%E5%8C%96"><span class="toc-number">8.2.3.2.</span> <span class="toc-text">除法优化</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%84%9F%E6%83%B3"><span class="toc-number">9.</span> <span class="toc-text">实验感想</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/17/Compiler/%E7%BC%96%E8%AF%91%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/" title="编译器设计文档"><img src="/img/loading.gif" data-original="/img/wuhui/16.jpeg" onerror="this.onerror=null;this.src='/img/footer.jpeg'" alt="编译器设计文档"/></a><div class="content"><a class="title" href="/2025/03/17/Compiler/%E7%BC%96%E8%AF%91%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/" title="编译器设计文档">编译器设计文档</a><time datetime="2025-03-17T14:00:00.000Z" title="发表于 2025-03-17 22:00:00">2025-03-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/16/Algorithm/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/" title="算法设计知识点整理"><img src="/img/loading.gif" data-original="/img/wuhui/4.png" onerror="this.onerror=null;this.src='/img/footer.jpeg'" alt="算法设计知识点整理"/></a><div class="content"><a class="title" href="/2025/03/16/Algorithm/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/" title="算法设计知识点整理">算法设计知识点整理</a><time datetime="2025-03-16T14:00:00.000Z" title="发表于 2025-03-16 22:00:00">2025-03-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/16/Algorithm/%E7%AE%97%E6%B3%95%E7%AC%AC4%E6%AC%A1%E4%BD%9C%E4%B8%9A/" title="算法第4次作业"><img src="/img/loading.gif" data-original="/img/wuhui/9.png" onerror="this.onerror=null;this.src='/img/footer.jpeg'" alt="算法第4次作业"/></a><div class="content"><a class="title" href="/2025/03/16/Algorithm/%E7%AE%97%E6%B3%95%E7%AC%AC4%E6%AC%A1%E4%BD%9C%E4%B8%9A/" title="算法第4次作业">算法第4次作业</a><time datetime="2025-03-16T06:00:00.000Z" title="发表于 2025-03-16 14:00:00">2025-03-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/16/Algorithm/%E7%AE%97%E6%B3%95%E7%AC%AC3%E6%AC%A1%E4%BD%9C%E4%B8%9A/" title="算法第3次作业"><img src="/img/loading.gif" data-original="/img/wuhui/6.png" onerror="this.onerror=null;this.src='/img/footer.jpeg'" alt="算法第3次作业"/></a><div class="content"><a class="title" href="/2025/03/16/Algorithm/%E7%AE%97%E6%B3%95%E7%AC%AC3%E6%AC%A1%E4%BD%9C%E4%B8%9A/" title="算法第3次作业">算法第3次作业</a><time datetime="2025-03-16T04:00:00.000Z" title="发表于 2025-03-16 12:00:00">2025-03-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/16/Algorithm/%E7%AE%97%E6%B3%95%E7%AC%AC2%E6%AC%A1%E4%BD%9C%E4%B8%9A/" title="算法第2次作业"><img src="/img/loading.gif" data-original="/img/wuhui/12.jpg" onerror="this.onerror=null;this.src='/img/footer.jpeg'" alt="算法第2次作业"/></a><div class="content"><a class="title" href="/2025/03/16/Algorithm/%E7%AE%97%E6%B3%95%E7%AC%AC2%E6%AC%A1%E4%BD%9C%E4%B8%9A/" title="算法第2次作业">算法第2次作业</a><time datetime="2025-03-16T02:00:00.000Z" title="发表于 2025-03-16 10:00:00">2025-03-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/footer2.jpeg);"><div id="footer-wrap"><div class="copyright">&copy;2025 By Mr-MysteryMan</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div><div class="footer_custom_text"><span id="runtime"></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script src="/js/flipcountdown.js"></script><script data-pjax src="/js/runtime.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="富强,民主,文明,和谐,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>