<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>编译原理知识点整理 | hahaha</title><meta name="author" content="Mr-MysteryMan"><meta name="copyright" content="Mr-MysteryMan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="编译原理第一章 概论 低级语言：字位码、机器语言、汇编语言。与特定机器有关，功效高但使用复杂且易出错。 高级语言：C、Java等语言。不依赖具体机器，移植性好易维护。  源程序：汇编或高级语言编写的待翻译程序； 目标程序：目标语言编写的程序； 翻译程序：将源程序转换为目标程序的程序。  源程序使用汇编，目标程序是机器语言，此翻译程序就是汇编程序；源程序使用高级语言，此翻译程序就是编译程序。  编译">
<meta property="og:type" content="article">
<meta property="og:title" content="编译原理知识点整理">
<meta property="og:url" content="http://example.com/2025/03/15/Compiler/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="hahaha">
<meta property="og:description" content="编译原理第一章 概论 低级语言：字位码、机器语言、汇编语言。与特定机器有关，功效高但使用复杂且易出错。 高级语言：C、Java等语言。不依赖具体机器，移植性好易维护。  源程序：汇编或高级语言编写的待翻译程序； 目标程序：目标语言编写的程序； 翻译程序：将源程序转换为目标程序的程序。  源程序使用汇编，目标程序是机器语言，此翻译程序就是汇编程序；源程序使用高级语言，此翻译程序就是编译程序。  编译">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/wuhui/8.png">
<meta property="article:published_time" content="2025-03-15T14:00:00.000Z">
<meta property="article:modified_time" content="2025-03-17T11:48:43.119Z">
<meta property="article:author" content="Mr-MysteryMan">
<meta property="article:tag" content="review">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/wuhui/8.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "编译原理知识点整理",
  "url": "http://example.com/2025/03/15/Compiler/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/",
  "image": "http://example.com/img/wuhui/8.png",
  "datePublished": "2025-03-15T14:00:00.000Z",
  "dateModified": "2025-03-17T11:48:43.119Z",
  "author": [
    {
      "@type": "Person",
      "name": "Mr-MysteryMan",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/logo.png"><link rel="canonical" href="http://example.com/2025/03/15/Compiler/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '编译原理知识点整理',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/post-background.css"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-color: #efefef;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-original="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/wuhui/8.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">hahaha</span></a><a class="nav-page-title" href="/"><span class="site-name">编译原理知识点整理</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">编译原理知识点整理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-15T14:00:00.000Z" title="发表于 2025-03-15 22:00:00">2025-03-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-17T11:48:43.119Z" title="更新于 2025-03-17 19:48:43">2025-03-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">9.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>30分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h1><h2 id="第一章-概论"><a href="#第一章-概论" class="headerlink" title="第一章 概论"></a>第一章 概论</h2><ol>
<li><p>低级语言：字位码、机器语言、汇编语言。与特定机器有关，功效高但使用复杂且易出错。</p>
<p>高级语言：C、Java等语言。不依赖具体机器，移植性好易维护。</p>
</li>
<li><p>源程序：汇编或高级语言编写的待翻译程序；</p>
<p>目标程序：目标语言编写的程序；</p>
<p>翻译程序：将源程序转换为目标程序的程序。</p>
</li>
<li><p>源程序使用汇编，目标程序是机器语言，此翻译程序就是汇编程序；源程序使用高级语言，此翻译程序就是编译程序。</p>
</li>
<li><p>编译过程指将高级语言程序翻译为目标语言程序的过程。</p>
</li>
<li><p>五个阶段：词法分析、语法分析、语义分析与生成中间代码、代码优化、生成目标程序。</p>
<p>七个逻辑部分：词法分析、语法分析、语义分析与生成中间代码、代码优化、生成目标程序、符号表管理、出错处理。</p>
</li>
<li><p>遍：对源程序（以及源程序中间形式）从头到尾扫描一次，并进行相应处理。</p>
</li>
<li><p>编译程序通常分为前端（分析，与源语言有关）和后端（综合，与目标机有关）。</p>
</li>
</ol>
<h2 id="第二章-文法与语言概念"><a href="#第二章-文法与语言概念" class="headerlink" title="第二章 文法与语言概念"></a>第二章 文法与语言概念</h2><ol>
<li><p>文法/语法：对语言结构的定义与描述。</p>
</li>
<li><p>语法规则：描述句子的语法结构的规则。</p>
<p>用 ::= 表示由什么组成。</p>
</li>
<li><p>最左推导：从最左的语法成分进行推导，类似有最右推导、一般推导。</p>
</li>
<li><p>语法树：推导为语法成分（非终结符），再推导为单词符号（终结符）。</p>
</li>
<li><p>文法定义：$G=(V_n,V_t,P,Z)$，$V_n$非终结符号集，$V_t$终结符号集，$P$规则集，$Z$开始符号/识别符号。</p>
</li>
<li><p>在文法G中，由式子v推导到式子w，记作 $v\underset{G}{\Rightarrow}w$ 。<font color=navy>实际上是任意符推任意符。</font></p>
</li>
<li><p>在文法G中，$u_0, u_1, … \in V^+$，若 $v\Rightarrow u_0\Rightarrow u_1\Rightarrow …\Rightarrow w$，记作 $v\overset{+}{\underset{G}{\Rightarrow}}w$ 。<font color=navy>实际上是多层推导，v一步不能到w。</font></p>
</li>
<li><p>在文法G中， $v\overset{+}{\underset{G}{\Rightarrow}}w$ ，推导符号下加文法G、上加正闭包+，或 $v=w$ ，记作 $v\overset{*}{\underset{G}{\Rightarrow}}w$ 。</p>
</li>
<li><p>规范推导：若$xUy \Rightarrow xuy$，且y是终结符号，则称作规范推导。（规范推导就是最右推导）</p>
</li>
<li><p>文法G[Z]，Z能推导到的任何串称为句型，Z能推导到的只含终结符的串称为句子，文法G[Z]产生的所有句子的集合称为语言。</p>
</li>
<li><p>文法G与G’为不同文法，若两个文法产生的语言相同，则称为等价文法。</p>
</li>
<li><p>递归规则：规则右部有与左部一致的非终结符。</p>
<p>对于$U::=xUy$，若$x=\varepsilon$，称为左递归；若$y=\varepsilon$，称为右递归；若$x,y\neq\varepsilon$，称为自嵌入递归。</p>
</li>
<li><p>递归文法：若$U\Rightarrow U…$，称为左递归文法；若$U\Rightarrow …U$，称为右递归文法；若$U\Rightarrow …U…$，称为递归文法。</p>
</li>
<li><p>短语：句型可以推导到的串，即任何非终结符所能推导出的最终字符串，不可含自身（简单短语是由一个非终结符一步推导出的只含终结符的字符串）</p>
</li>
<li><p>句柄：句型能够推导到的最左简单短语。</p>
</li>
<li><p>若一个文法的某句子存在两种不同的规范推导，则称该文法具有二义性。</p>
</li>
<li><p>有害规则：形如$U::=U$，会引起二义性。</p>
</li>
<li><p>多余规则： 该规则的左部非终结符不出现在任何句型中。（不可达符号）</p>
<p>​                    该规则中含有推不出任何终结符号串的非终结符。（不活动符号）</p>
</li>
<li><p>某文法中不含有害规则或多余规则，则称该文法是压缩过的。</p>
</li>
<li><p>文法语言分类：0型，1型，2型，3型</p>
<p>0型：短语结构文法，可以用图灵机接受；($u::=v,u\in V^+,v\in V^*$)</p>
<p>1型：上下文敏感或上下文有关，只有在左右为x、y的情况下可以完成推导，可以用线性界限自动机接受；($xUy::=xuy,U\in V_n,xyu\in V^*$)</p>
<p>2型：上下文无关，与BNF等价，可以用下推自动机接受；($U::=u,U\in V_n,u\in V^*$)</p>
<p>3型：正则文法，可以用有穷自动机接受；(左线性：$U::=t \;/\; U::=Wt,UW\in V_n,t\in V_t$，右线性：$U::=t \;/\; U::=tW,UW\in V_n,t\in V_t$)</p>
</li>
</ol>
<h2 id="第三章-词法分析"><a href="#第三章-词法分析" class="headerlink" title="第三章 词法分析"></a>第三章 词法分析</h2><ol>
<li><p>词法分析：根据此法规则识别及组合单词，进行词法检查。</p>
</li>
<li><p>单词种类：保留字（for，begin，end，do）、标识符（函数变量名称）、常数、分界符（+-*/）</p>
</li>
<li><p>单词内部形式：</p>
<ul>
<li><p>按单词种类分类：类别编码+单词值</p>
</li>
<li><p>保留字和分界符采用一符一类</p>
<p><img src="/img/loading.gif" data-original="E:\文件\照片\markdown图片集\编译原理\保留字和分界符采用一符一类.png" alt="保留字和分界符采用一符一类" style="zoom: 67%;" /></p>
</li>
<li><p>标识符和常数的单词值又为指示字</p>
</li>
</ul>
</li>
<li><p>状态图： 状态以圆表示，箭头由规则右侧状态指向规则左侧状态，箭头上写转移时的终结符。</p>
<p>​                初始状态以S表示，其表示推导的最终结果（仅存在终结符）</p>
<p>​                文法G[Z]初始语句Z以状态Z表示，其外围两圈圆，内圆为虚线</p>
</li>
<li><p>词法分析中使用的全局变量和过程：</p>
</li>
</ol>
<p><img src="/img/loading.gif" data-original="/images/Compiler/编译原理/词法分析全局变量.png" alt="词法分析全局变量" style="zoom:67%;" /></p>
<ol>
<li>正则文法：左线性文法 + 右线性文法</li>
</ol>
<h2 id="第四章-语法分析"><a href="#第四章-语法分析" class="headerlink" title="第四章 语法分析"></a>第四章 语法分析</h2><ol>
<li><p>自顶向下：给定符号串，遵照文法尝试对其建立语法树。</p>
</li>
<li><p>存在问题：左递归文法、需要回溯</p>
</li>
<li><p>左递归消除：</p>
<ul>
<li>使用扩充BNF表示改写文法：提因子（$E::=Ac\,|\,Bc \Rightarrow E::=(A\,|\,B)c$），递归文法改写（$E::=E+T\,|\,T \Rightarrow E::=T{+T}$）；</li>
<li>将左递归文法改写为右递归文法。</li>
</ul>
</li>
<li><p>回溯问题：分析工作需要部分或全部退回去。</p>
</li>
<li><p>回溯问题不发生的充要条件：</p>
<p>定义$FIRST(\beta) = {c\,|\,\beta\overset{<em>}{\Rightarrow}c\,…,c\in V_t}$，$FOLLOW(A)={c\,|\,Z\overset{</em>}{\Rightarrow}\,…Ac\,…,c\in V_t}$。对于G的每一个满足$A::=\alpha\,|\,\beta$的非终结符A都应存在$FIRST(\alpha)\cap FIRST(\beta) = \varnothing$ 及$FIRST(\alpha)\cap FOLLOW(A) = \varnothing$（若$\beta\overset{*}{\Rightarrow}\epsilon 空字符$）。</p>
</li>
<li><p>回溯问题消除：多次改写和提因子，最终使得分析过程满足不需要回溯的冲要条件；超前扫描：向前多侦察多个字符，以确定文法选择。</p>
</li>
<li><p>分析程序主要使用方法：递归下降法</p>
</li>
</ol>
<h2 id="第五章-符号表"><a href="#第五章-符号表" class="headerlink" title="第五章 符号表"></a>第五章 符号表</h2><ol>
<li><p>符号表：编译过程中，编译程序用来记录源程序中各种名字的特性信息，也称名字特性表。</p>
</li>
<li><p>常见符号：程序名、过程名、函数名、用户定义类型名、变量名、常量名、枚举值名、标号名等。</p>
<p>常见信息：种类、类型、维数、参数个数、数值、存储单元地址等。</p>
</li>
<li><p>各种标识符通过声明存入符号表（填表）；填表前检查是否重复定义，后续使用时需查询符号表标识符是否声明（查表）。</p>
</li>
<li><p>符号表结构：名字+特性</p>
</li>
<li><p>特性域：应该包含多个子域。</p>
<ul>
<li>普通标识符：种类（变量名、函数名）、类型（int/char）、性质（var/const）、值、地址、所占地址大小、作用域嵌套层次</li>
<li>数组：维数、上下界值、首元素地址、数组元素类型</li>
<li>记录（结构、联合）：域的个数、域名、地址位移、类型</li>
<li>过程、函数：形参个数、所在层次、返回值类型、局部变量所占空间大小</li>
<li>指针：所指对象类型</li>
</ul>
</li>
<li><p>组织方式：大部分共同信息按统一格式制表，部分特殊信息用指针连接。</p>
</li>
<li><p>非分程序结构语言：可独立编译的程序单元是一个不包含子模块的单一模块，如FORTRAN语言。</p>
</li>
<li><p>标识符按作用域不同分为全局局部，制成全局符号表、局部符号表。</p>
</li>
<li><p>子程序、函数名、公共区名填入全局符号表</p>
<p>子程序（函数）声明部分制造或填入局部符号表（本单元局部符号表，有同名：重复声明报错，无同名：造表）</p>
<p>语句部分读到标识符查表（本单元局部符号表及全局符号表，有同名：已声明，无同名：无定义报错）</p>
<p>程序单元结束释放该单元局部符号表，程序编译结束释放全部符号表。</p>
</li>
<li><p>符号表可为无序符号表、有序符号表、哈希表</p>
</li>
<li><p>分程序结构语言：模块内可嵌入子模块</p>
</li>
<li><p>标识符声明性出现建表（本层符号表，有同名：重复声明报错，无同名：填表）</p>
<p>标识符引用性出现查表（本层符号表，有同名：已声明，无同名：转到直接外层）</p>
<p>标准标识符（不必声明可全程使用，标准名及数目已知）初始化时建表并将名字表填入</p>
</li>
</ol>
<h2 id="第六章-运行时存储管理"><a href="#第六章-运行时存储管理" class="headerlink" title="第六章 运行时存储管理"></a>第六章 运行时存储管理</h2><ol>
<li><p>静态存储分配：在编译阶段有编译程序实现对存储空间的管理和为源程序中变量分配存储。</p>
<p>条件：在编译时能够确定变量在运行时的数据空间大小，且运行时不改变。</p>
</li>
<li><p>动态存储分配：在目标程序运行阶段由目标程序实现对对存储空间的管理和为源程序中变量分配存储。</p>
<p>特点：在目标程序运行时进行变量存储分配，编译时要生成进行动态分配的目标指令。</p>
</li>
<li><p>静态存储分配：</p>
<ul>
<li><p>分配策略：开辟数据区，为每个模块分配，在模块内按序分配，目标地址填入符号表</p>
</li>
<li><p>FORTRAN子程序（模块）典型数据区：</p>
<p>变量、返回地址、形式参数、临时变量</p>
<p><img src="/img/loading.gif" data-original="/images/Compiler/编译原理/FORTRAN子程序典型存储结构.png" alt="FORTRAN子程序典型存储结构" style="zoom:50%;" /></p>
</li>
</ul>
</li>
<li><p>动态存储分配：编译时不能具体确定程序所需数据空间，编译程序生成有关存储分配的目标代码，实际分配在目标程序运行时进行。</p>
<p>分程序结构，且允许递归调用的语言：栈式动态存储分配</p>
<p>分配策略：整个数据区为一个堆栈，进入过程时，在栈顶分配数据区；退出过程时，撤销过程数据区。</p>
</li>
<li><p>典型活动记录可以分为三部分：局部数据区（各局部变量），参数区（显式隐式参数），display区（存放各外层模块活动记录的基地址）</p>
</li>
<li><p>参数区：显式参数：形参数据，出现在用户源程序中；隐式参数：prev abp（存放调用模块记录基地址，执行完后释放数据区，数据区指针指向调用前地址）、ret addr（返回地址，调用语句的下一条执行指令地址）、ret value（函数返回值）</p>
</li>
</ol>
<h2 id="第七章-源程序中间形式"><a href="#第七章-源程序中间形式" class="headerlink" title="第七章 源程序中间形式"></a>第七章 源程序中间形式</h2><ol>
<li><p>一般编译程序都是先生成中间代码，再生成目标代码，优点是可移植性（与具体目标程序无关）与可优化性。主要有三种中间代码表示形式：波兰表示，N元组表示，抽象机代码。</p>
</li>
<li><p>波兰表达式：前序后序中序表达式，$a+b \Rightarrow ab+$</p>
<p>算法：设立操作符栈。读到操作数时立即输出；读到操作符时，与栈顶操作符比较优先级，栈顶操作符优先级高/相同时栈顶操作符出栈，栈顶操作符优先级低时读入操作符入栈。</p>
</li>
<li><p>N元组表示：每条指令由N个域组成，通常第一个域表示操作符，其余表示操作数。（常用三元组四元组）</p>
<p>前序表达式，$a+b<em>c \Rightarrow (1)</em>,b,c \quad(2)+,a,(1)$</p>
</li>
<li><p>间接三元式：三元式不便优化，优化时会删除一些三元式，或对三元式顺序（编号）进行改变，但有些改变的三元式结果出现于其他三元式中，因此引入间接三元式。将三元式与三元式的执行顺序存储为两张表，优化时改变三元式执行顺序表。</p>
</li>
<li><p>四元式：操作符+操作数1+操作数2+结果</p>
<p>结果通常是由编译引入的临时变量，可由编译器分配一个寄存器或主存单元。</p>
</li>
<li><p>抽象机代码：P-code中间代码，主要操作寄存器，保存程序指令的存储器，堆栈式数据</p>
<p>使用的寄存器： PC: 程序计数器</p>
<p>​                            NP: New指针，指向存放由New生成的动态数据的堆顶端</p>
<p>​                            SP: 运行栈指针，存放所有可按源程序的数据声明直接寻址的数据</p>
<p>​                            BP: 基地址指针，指向当前活动记录的起始位置指针</p>
<p>​                            MP: 栈标志指针</p>
<p>​                            EP: 极限栈指针</p>
</li>
<li><p>抽象机所有操作都在运行栈的栈顶进行，顺序与波兰表达式相同</p>
</li>
<li><p>中间代码的图表示：</p>
<ul>
<li>语法树：操作数出现在叶结点，操作符出现在中间结点。</li>
<li>DAG图：Directed Acyclic Graphs有向无环图，语法树的一种归约表达形式（语法树中相同表达部分表示一次）</li>
</ul>
</li>
<li><p>三地址码：适合目标代码优化生成的表达形式，是语法树或DAG图的线性表示，树的中间结点由临时变量表示。</p>
</li>
</ol>
<h2 id="第八章-错误处理"><a href="#第八章-错误处理" class="headerlink" title="第八章 错误处理"></a>第八章 错误处理</h2><ol>
<li><p>错误分为两类：语法错误（不合文法）和语义错误（不合语义规则或超越系统限制）</p>
</li>
<li><p>语义规则：标识符先声明后引用；引用要符合作用域规定；调用时形参实参要一致；参与运算的操作数类型一致；下标变量下标不能越界。</p>
<p>超越系统限制：数据溢出错误；符号表、静态存储分配数据区溢出；动态存储数据区溢出。</p>
</li>
<li><p>错误诊察： 违反语法语义规则、超过编译系统限制的错误（语法语义分析时）</p>
<p>​                    下标越界、计算结果溢出、动态存储数据区溢出（目标程序运行时）</p>
</li>
<li><p>错误报告： 出错位置：行号计数器、单词序号计数器</p>
<p>​                    出错性质：文字信息、错误编码</p>
</li>
<li><p>错误处理技术：发现错误后，在报告错误的同时还要对错误进行处理，以便编译能继续进行。</p>
<p>错误改正：查出错误后，根据文法进行错误改正</p>
<p>错误局部化：尽可能将错误的影响限制在一个小范围内，避免错误扩散和影响程序其他部分分析。</p>
</li>
<li><p>局部化处理：</p>
<ul>
<li>一般原则：诊察到错误后停止对后面符号进行分析，跳过错误所在语法成分继续分析（一般是跳到语句右界符，从新语句开始分析）</li>
<li>局部化处理实现：递归下降法，出错后转存，并跳到正确部分分析。</li>
<li>提高错误局部化的方法：建立语法成分对应的合法后继符号集、停止符号集（跳读必须停止的符号）</li>
</ul>
</li>
<li><p>目标程序运行时错误检测与处理：较难确定出错位置，只需打印错误信息，保留寄存器储存器中的值</p>
</li>
</ol>
<h2 id="第九章-语法制导翻译技术"><a href="#第九章-语法制导翻译技术" class="headerlink" title="第九章 语法制导翻译技术"></a>第九章 语法制导翻译技术</h2><ol>
<li><p>程序语言的语义形式化描述有三种，操作语义、指称语义、公理语义。</p>
</li>
<li><p>翻译目标是将中缀表达式变为后缀表达式（逆波兰表示）。（只需在中缀表达文法中插入相应动作符号）</p>
</li>
<li><p>输入文法：未插入动作符号时的文法，可推导出输入序列。</p>
<p>翻译文法：插入动作符号后的文法，可推导出活动序列（输入序列/动作序列）。</p>
<blockquote>
<p>输入文法：$E \Rightarrow T + F \Rightarrow i + F \Rightarrow i + j$</p>
<p>翻译文法：$E \Rightarrow T + F@+ \Rightarrow i @i + F @+ \Rightarrow i @i + j @j @+$</p>
<p>其中，$@$为动作符号标记，代表一个动作，比如是打印其后字符串。</p>
</blockquote>
</li>
<li><p>活动序列：由翻译文法推导出的字符串，由终结符和动作符号组成。去除动作符号，可得输入序列；去除输入序列，可得动作序列。（执行动作序列即可完成翻译任务）</p>
<p>活动序列中的输入序列和动作序列构成对偶集。</p>
</li>
<li><p>语法制导翻译：给定输入字符串，根据翻译文法获得动作序列并完成动作的过程。</p>
</li>
<li><p>属性文法：在翻译文法基础上，为终结符、非终结符、动作符号加上属性（综合属性/继承属性）。</p>
</li>
<li><p>综合属性：$\uparrow c$ 代表该属性，$\uparrow$是综合属性标记，$c$是属性变量或属性值。根据文法自顶向下构建语法树，自底向上计算属性。</p>
<p>继承属性：$\downarrow c$ 代表该属性，$\downarrow$是继承属性标记，$c$是属性变量或属性值。可从之前得到，继承之前的值，自顶向下计算属性。</p>
</li>
<li><p>L属性翻译文法(L-TAG)：输入文法要求是LL(1)文法，可自顶向下构造分析器，分析过程中可进行属性求值。要求文法中的非终结符、终结符、动作符都需要存在属性，开始符号的继承属性和终结符号的综合属性有初值。继承属性自顶向下自左向右求值，综合属性自底向上自右向左求值。</p>
</li>
<li><p>简单赋值形式的L属性翻译文法(SL-TAG)：属性传递时除去动作符号，其余符号的属性只是简单的赋值关系，不存在复杂运算。</p>
<p>产生式右侧符号的继承属性等于左侧符号的继承属性或同右侧在其左边符号的综合属性。</p>
<p>产生式左侧符号的综合属性等于左侧符号的继承属性或右侧符号的综合属性。</p>
<blockquote>
<p>非SL-TAG文法：$A \Rightarrow B<em> {\uparrow R} C</em>{\uparrow S} D_{\downarrow I}$，其中$I:=f(R,S)$</p>
<p>SL-TAG文法：$A \Rightarrow B<em> {\uparrow R} C</em>{\uparrow S} @f<em>{\downarrow I_1, I_2\uparrow S_1} D</em>{\downarrow I}$，其中$I_1 := R, I_2 := S, S_1 = f(I_1, I_2),I := S_1$</p>
</blockquote>
</li>
<li><p>递归下降翻译器：翻译文法的自顶向下翻译。思路与输入文法的递归下降分析基本相同，只需按照翻译文法在过程中增加动作即可。</p>
</li>
<li><p>递归下降属性翻译器：属性文法的自顶向下翻译。对每个非终结符设置一个子程序，根据其具有属性数目设置相应参数。继承属性设置为赋值形参，综合属性设置为变量形参。</p>
<p>关于属性名：产生式左部同名非终结符使用相同属性名，具有相同值的属性取相同属性名。</p>
</li>
<li><p>过程调用函数实参，继承属性传递继承属性值，综合属性传递属性变量名（地址）。</p>
</li>
</ol>
<h2 id="第十章-语义分析和代码生成"><a href="#第十章-语义分析和代码生成" class="headerlink" title="第十章 语义分析和代码生成"></a>第十章 语义分析和代码生成</h2><ol>
<li><p>源语言：通用的过程语言。</p>
</li>
<li><p>生成代码：栈式抽象机生成的伪汇编代码。</p>
</li>
<li><p>翻译方法：自顶向下的属性翻译。</p>
</li>
<li><p>语法成分翻译子程序参数设置：继承属性为值形参，综合属性为变量形参。</p>
</li>
<li><p>语法成分动作翻译子程序参数设置：继承属性为值形参，综合属性不设形参而作为动作子程序返回值。</p>
</li>
<li><p>L属性翻译文法(L-ATG)：输入文法要求是LL(1)文法，可用自顶向下分析构建分析器。</p>
<p>其拥有特征：终结符、非终结符和动作符都具有属性；非终结符和动作符属性可分为继承属性综合属性；开始符号的继承属性具有指定初始值；终结符号的综合属性具有指定初始值；属性求值规则。</p>
</li>
<li><p>语义分析：</p>
<ul>
<li><p>上下文有关分析：标识符作用域；</p>
</li>
<li><p>类型一致性检查</p>
</li>
<li><p>语义处理： 声明语句：语义是声明变量类型等。编译程序工作是填符号表，登录名字特征信息，分配存储。</p>
<p>​                    执行语句：语义是某种操作。编译程序工作是按某种操作的目标结构生成代码。</p>
</li>
</ul>
</li>
<li><p>用上下文无关文法只能描述语言的语法结构，而不能描述其语义。</p>
<p>构建上下文有关文法过于困难，其分析器效率低。通常把与语义相关的上下文有关信息填入符号表中，并通过查符号表中的这些信息来分析程序的语义是否正确。</p>
</li>
<li><p>栈式抽象机：三个存储器、一个指令寄存器和多个地址寄存器组成。</p>
<p>存储器：数据存储器（存放AR的运行栈）、操作存储器（操作数栈）、指令存储器。</p>
</li>
<li><p>栈式抽象机指令代码：</p>
<p>| 指令名称 | 操作码                                   | 地址  | 指令意义                                     |<br>| ———— | ———————————————————— | ——- | —————————————————————— |<br>| 加载指令 | LOD                                      | D     | 将D的内容→栈顶                               |<br>| 立即加载 | LDC                                      | const | 常量→栈顶                                    |<br>| 地址加载 | LDA                                      | (D)   | 变量D的地址→栈顶                             |<br>| 存储     | STO                                      | D     | 栈顶内容→变量D                               |<br>| 间接存   | ST                                       | @D    | 栈顶内容→D所指单元                           |<br>| 间接存   | STN                                      |       | 栈顶内容→次栈顶所指单元                      |<br>| 加       | ADD                                      |       | 栈顶和次栈顶内容相加，结果留栈顶             |<br>| 减       | SUB                                      |       | 次栈顶内容减栈顶内容                         |<br>| 乘       | MUL                                      |       |                                              |<br>| 逻辑与   | AND                                      |       |                                              |<br>| 逻辑或   | ORL                                      |       |                                              |<br>| 逻辑非   | NOT                                      |       |                                              |<br>| 比较     | EQL, NEQ, <br />GRT, LES, <br />GTE, LSE |       | 次栈顶内容与栈顶内容比较，结果（1或0）留栈顶 |<br>| 转子     | JSR                                      | lab   |                                              |<br>| 分配     | ALC                                      | M     | 在运行栈顶分配大小为M的活动记录区            |</p>
</li>
<li><p>声明的处理：处理声明主要是填表并检查是否重复声明，处理已声明实体主要是查表。</p>
</li>
<li><p>对于静态数组，编译程序处理声明时应建立数组模板（数组信息向量），以便后期计算数组元素的存储地址。一般存储下界上界和地址计算常量。</p>
</li>
<li><p>大部分程序语言数组元素按照行优先存放，FORTRAN例外。</p>
</li>
<li><p>翻译文法中的动作符号也称为动作程序。</p>
</li>
<li><p>表达式的处理：处理表达式主要是生成计算该表达式值的代码。通常是把操作数装载到操作数栈栈顶或某个寄存器中，执行表达式所指定的操作，并将结果保留在栈顶或寄存器中。</p>
</li>
<li><p>操作数栈可以和运行栈（动态存储分配）合并，也可单独设栈。本章选择单独设栈的方式。</p>
</li>
<li><p>对于实际表达式计算允许整型实型混合使用，允许出现数组元素。因此除去基本运算，还应加入类型一致性检查或转换，计算下标变量地址并取下标变量值的语义动作。</p>
</li>
<li><p>过程调用：</p>
<ul>
<li>传值：调用段：计算实参值，放在操作数栈栈顶；被调用段：从栈顶取得值，对应形参单元。对形参的访问等于对相应实参的访问。</li>
<li>传值：调用段：计算实参地址，放在操作数栈栈顶；被调用段：从栈顶取得地址，对应形参单元。通过对形参的间接访问来访问相应的实参。</li>
<li>传名：将实参名传给形参。当实参变量为下标变量时，传名和传地址效果可能不同。传名实现复杂效率较低，现基本不使用。</li>
</ul>
</li>
<li><p>返回语句：返回返回值，并删除被调用过程活动记录。</p>
</li>
</ol>
<h2 id="第十一章-词法分析自动化"><a href="#第十一章-词法分析自动化" class="headerlink" title="第十一章 词法分析自动化"></a>第十一章 词法分析自动化</h2><ol>
<li><p>正则表达式和正则集合：有字母表 $\Sigma$ , 定义在 $\Sigma$ 上的正则表达式和正则集合递归定义如下 :</p>
<ul>
<li><p>$\varepsilon$ 和 $\phi$ 都是 $\Sigma$ 上的正则表达式, 其正则集合分别为: ${\varepsilon}$ 和 $\phi$ ;</p>
</li>
<li><p>任何 $a \in \Sigma$ <strong>,</strong> $a$是 $\Sigma$ 上的正则表达式,其正则集合为: ${a}$ ; </p>
</li>
<li>假定 $U$ 和 $V$ 是 $\Sigma$ 上的正则表达式, 其正则集合分别记为 $L(U)$ 和 $L(V)$ , 那么 $U|V$ , $U\cdot V$ 和 $U <em>$ 也都是 $\Sigma$ 上的正则表达式, 其正则集合分别为 $L(U) \cup L(V)$ 、 $L(U) \cdot L(V)$ 和 $L(U) </em>$ ；</li>
<li>任何 $\Sigma$ 上的正则表达式和正则集合均由 1、2和3产生。</li>
</ul>
</li>
<li><p>正则表达式符号： $|$ 或， $\cdot$ 连接， $* / {}$ 重复， $()$ 括号。</p>
</li>
<li><p>正则表达式与3型文法等价。</p>
</li>
<li><p>确定有穷自动机DFA：$M = {S, \Sigma, \delta, s_0, Z}$ ，其中 $S$ 代表有穷状态集， $\Sigma$ 代表输入字母表， $\delta$ 状态转移函数， $s_0$ 初始状态， $Z$ 终止状态集。</p>
<p>DFA的确定性表现在状态转换函数是单值函数。</p>
</li>
<li><p>不确定有穷自动机NFA：若 $δ$ 是一个多值函数，且输入可允许为 $\varepsilon$ ，则有穷自动机是不确定的 , 即在某个状态下，对于某个输入字符存在多个后继状态。</p>
</li>
<li><p>$\varepsilon-Closure(A) = A \cup B$ ，其中 $B$ 是指 $A$ 中元素经过任意条 $\varepsilon$ 弧能够到达的状态的集合。</p>
</li>
<li><p>NFA到DFA的转换原理是构建新的状态，按照NFA图构建新的转换函数 $\delta(s_0, 0) = \varepsilon-Closure(s_1) = {s_1, s_2}$ 。</p>
</li>
<li><p>DFA的化简：多余状态、等价状态（一致性：同为可接受或不可接受；蔓延性：任意输入符号都得转换到等价状态）。</p>
</li>
<li><p>DFA与正则文法等价。</p>
</li>
<li><p>正则文法可分为左线性正则文法和右线性正则文法。</p>
</li>
</ol>
<h2 id="第十二章-语法分析提高"><a href="#第十二章-语法分析提高" class="headerlink" title="第十二章 语法分析提高"></a>第十二章 语法分析提高</h2><ol>
<li><p>LL分析法：LL自左向右扫描、自左向右地分析和匹配输入串，表现出最左推导的性质。从左到右扫描，自顶向下归约。</p>
</li>
<li><p>$FIRST(\alpha) = {a|\alpha \Rightarrow a…, a\in V_t}$ ，其中 $a$ 可以为空字符。</p>
<p>$FOLLOW(A) = {a|\alpha \Rightarrow …Aa…, a\in V_t}$ 。若 $\alpha\Rightarrow …A$ ，则 $#\in FOLLOW(A)$ 。</p>
</li>
<li><p>LL(1)文法：文法分析表不含多重定义入口，即分析表中每格无两条以上规则。</p>
</li>
<li><p>LL(1)文法充要条件：对任意规则 $A::=\alpha \,|\, \beta$ ，都有</p>
<ul>
<li>$FIRST(\alpha) \cap FIRST(\beta) = \varnothing$ ；</li>
<li>若 $\beta \Rightarrow \varepsilon$ ，$FIRST(\alpha) \cap FOLLOW(A) = \varnothing$ 。</li>
</ul>
</li>
<li><p>自底向上分析：从输入符号串开始，重复查找当前句型句柄，并利用有关规则进行归约。</p>
</li>
<li><p>移进-归约分析：建立符号栈，记录分析历史和现状，根据所面临状态，确定下一步动作是移进还是归约。</p>
</li>
<li><p>算符优先分析：仿效算术式四则运算，为每个终结符设定执行的先后顺序。</p>
<p>该分析不一定是严格的最左归约/规范归约。</p>
</li>
<li><p>$FIRSTVT(U) = {b|U\Rightarrow b… 或 U \Rightarrow Vb…, V\in V_n, b \in V_t}$ ；</p>
<p>$LASTVT(U) = {a|U\Rightarrow …a 或 U \Rightarrow …aV, V\in V_n, a \in V_t}$ 。</p>
</li>
<li><p>素短语：一个短语，至少包含一个终结符号，且除它自身外不包含其他素短语。</p>
</li>
<li><p>LR分析法：从左到右扫描，自底向上归约。</p>
</li>
<li><p>LR分析器有状态栈、分析表、控制程序三部分。</p>
</li>
<li><p>分析表种类：SLR（简单LR）、LR（标准LR）、LALR（超前LR）。</p>
</li>
<li><p>规范句型：通过规范规约得到的句型。</p>
<p>前缀：输入串前部终结符串，只要满足剩余部分与其连接成为输入串即可。</p>
<p>活前缀：若分析过程能保证栈中符号串均是规范句型的前缀，则称为活前缀（表示当前分析中并无语法错误，活前缀实际是不包括句柄右边符号的前缀）。</p>
</li>
<li><p>有效项目：若项目 $A \rightarrow \beta_1\beta_2$ 对活前缀 $\alpha\beta_1$ 成立，则必有规范推导 $E\Rightarrow \alpha Aw\Rightarrow \alpha\beta_1\beta_2w$ 。（假设活前缀为 $\alpha_1…\alpha_k$ ，获得项目族群和项目间转移关系后，按照活前缀顺序输入进行转移，最终所在项目即是该活前缀的有效项目集）</p>
</li>
<li><p>状态转移表（GOTO）：终结符导致状态转移</p>
</li>
<li><p>分析动作表（ACTION）：移进（shift），归约（reduce），接受（accept），出错（error）</p>
</li>
<li><p>控制程序：根据栈顶状态和现输入符号查ACTION表执行规定操作，并根据GOTO表设置新栈顶状态。</p>
</li>
<li><p>LR分析过程：每次归约总是归约当前句型的句柄（规范规约）；分析每一步栈中符号串均是规范句型的活前缀，与输入串剩余部分构成规范句型。</p>
</li>
<li><p>SLR分析表构建：</p>
<ul>
<li>确定文法状态集合，即LR(0)项目集规范族：实现时首先应拓广文法，如普通G[S]文法，应该添加推导规则 $S’\rightarrow S$ ，保证分析表只有一个接受状态。初始状态是 $I_0:S’\rightarrow .S$ 以及这个项目的闭包（所有可以转移到的项目，如 $S\rightarrow .E,\ E\rightarrow .abc$ ）。</li>
<li>确定转移函数，从初始项目集出发，将 $.$ 后移一位，判断转移函数，填写ACTION和GOTO表。</li>
<li>确定文法归约，在状态中，寻找形如 $A\rightarrow abc.$ 的语句，则在 $FOLLOW(A)$ 的字符对应的格子中填入该语句对应的归约编号。如该语句编号为 $2$ ，$FOLLOW(A) = {a,b}$ ，则在 $a,b$ 对应的格子中填入 $r_2$ 。</li>
</ul>
</li>
<li><p>SLR判断方法：判断是否有移进-移进冲突（即一个字符出现两种转移）、移进-归约冲突（即一个字符可能为转移也可能为归约）。</p>
</li>
</ol>
<h2 id="第十四章-代码优化"><a href="#第十四章-代码优化" class="headerlink" title="第十四章 代码优化"></a>第十四章 代码优化</h2><ol>
<li><p>优化目标：提高目标代码运行效率，时间+空间</p>
</li>
<li><p>优化方法分类：</p>
<ul>
<li>与机器无关（中间代码优化）、与机器有关（目标代码优化，指令与寄存器的使用）；</li>
<li>局部优化（基本块内）、全局优化（函数内基本块间）、跨函数优化（整个程序内）。</li>
</ul>
</li>
<li><p>基本块定义：连续的语句序列，控制流只能从第一句进入基本块，从最后一句离开基本块。</p>
</li>
<li><p>流图定义：有向图，节点是基本块，基本块间关系是前驱和后继。</p>
</li>
<li><p>基本块内优化：</p>
<ul>
<li><p>代数变换：常数计算与合并，削弱运算强度；</p>
</li>
<li><p>复写传播：形如 $x:=y$ 的赋值语句称为复写语句，满足一定条件时，后续 $y$ 可用 $x$ 替代，称为复写传播；</p>
</li>
<li><p>死代码删除：如 $x := x + 0$ ，永真的 if-else 语句块。</p>
<blockquote>
<p><strong>消除公共子表达式</strong></p>
<p>通过构建DAG图（有向无环图）消除公共子表达式。</p>
<blockquote>
<p><strong>DAG图构建算法</strong></p>
<p>对于形如 $z = x\ op\ y$ 的表达式，在图中寻找 $x$ 、 $y$ 对应的节点，如果没有就在图中新添加。接着寻找 $op$ 对应的节点（该节点存在有向边分别指向 $x$ 、 $y$ 对应的节点），如果没有就在图中新添加。完成后将 $z$ 所代表的节点设置为 $op$ 对应的节点。</p>
<p>对于数组元素，需要改写表达式。对于形如 $z = a[i]$ 的表达式，改写为 $z = a\ []\ i$ 的形式， $[]$ 作为运算符。对于形如 $a[i] = z$ 的表达式，改写为 $a = i\ {[]=}\ z$ 的形式， $[]=$ 作为运算符。对于指针运算，尽量不要优化。</p>
<p><strong>从DAG图导出中间代码算法</strong></p>
<p>选择DAG图中任意一无父节点（即无有向边指向它）的节点，去除并加入队列。接着如果它的最左子节点符合无父节点的条件，则去除并加入队列，继续对加入节点的最左子节点判断；如果不符合条件，则在图中再选取一个符合条件的节点，继续上述流程。所有节点均加入队列后，反序输出队列中节点作为代码运算顺序。</p>
</blockquote>
</blockquote>
</li>
</ul>
</li>
<li><p>窥孔优化：窥孔优化关注在目标指令的 一个较短的序列上，通过删除其中的冗余代码，或者用更高效简洁的新代码来替代其中的部分代码，达到提升目标代码质量的目的。并不局限于一个基本块内。</p>
</li>
<li>全局优化：首先应进行数据流分析， $out[S] = gen[S] \cup (in[S] - kill[S])$ 或 $in[S] = use[S] \cup (out[S] - def[S])$ 对于任意基本块或语句都成立。</li>
<li>到达定义分析：某个变量定义是在哪里产生、在哪里消除，在哪些语句中都可以使用。基本块的到达定义分析先获得 $in$ 集合（ $in[B] = \cup_{B的前驱基本块P}\ out[P]$ ，其中 $in[B_1] = \varnothing$ ），并通过上式（ $out[S] = gen[S] \cup (in[S] - kill[S])$ ）获得 $out$ 集合。循环执行，直至全部块的 $out$ 集合不变。</li>
<li>活跃变量分析：某个变量在当前位置是否是活跃的，即后续是否使用。本块的活跃变量分析先获得 $out$ 集合（ $out[B] = \cup<em>{B的后驱基本块P}\ in[P]$ ，其中 $out[B</em>{exit}] = \varnothing$ ），并通过上式（ $in[S] = use[S] \cup (out[S] - def[S])$ ，活跃变量中， $def$ 代表在使用前定义/赋值的变量； $use$ 代表在定义/赋值前使用的变量）获得 $in$ 集合。循环执行，直至全部块的 $in$ 集合不变。</li>
<li>冲突图：假设只有跨越基本块活跃的变量才能分配到全局寄存器，并且活跃范围重合的变量之间无法共享全局寄存器。节点是待分配的全局寄存器，当两个变量中一个在另一个定义/赋值处活跃，他们之间便有一条边相连。</li>
<li>变量的定义-使用链：每个变量可能有多个链，每个链头元素表示定义/赋值位置，后面元素表示使用位置，可写为 ${<B_{def}, n_{pos}>, …}$ 的形式。</li>
<li>循环优化：循环不变式（不随循环控制变量改变而改变）外提、循环展开（以空间换时间，需判断展开前后是否更节省时间）、归纳变量（每次迭代过程中固定增加或减少一个值）的优化和条件判断的替换、多重嵌套变单层、相同形式循环合并。</li>
<li>in_line展开：将函数调用展开在主程序中，节省压栈和跳转时间。</li>
</ol>
<h2 id="第十五章-目标代码生成"><a href="#第十五章-目标代码生成" class="headerlink" title="第十五章 目标代码生成"></a>第十五章 目标代码生成</h2><ol>
<li><p>代码生成器输入：符号表、源程序中间表示。</p>
<p>要求：获得中间表示、标识符表示直接操作的变量、完成语法语义等检查。</p>
</li>
<li><p>指令集架构：</p>
<ul>
<li>栈式架构：PUSH、POP出入栈顶，计算指令计算栈顶单元。</li>
<li>累加器式架构：LOAD、STORE加载存储栈顶，计算指令计算栈顶单元和新输入单元。</li>
<li>寄存器架构：分为寄存器-内存指令架构（操作指令从寄存器和内存获得数据）和寄存器-寄存器（操作指令只能从寄存器获得数据）指令架构。</li>
</ul>
</li>
<li><p>为了程序效率，应该尽可能少访问除寄存器外的存储设备。</p>
</li>
<li><p>循环可以通过循环交换优化提高缓存命中率。</p>
</li>
<li><p>地址空间：代码区存放目标代码；静态数据区存放全局变量、静态变量和其他部分变量（如字符串）；动态内存区（也称内存堆）存放普通变量；程序运行栈存放活动记录和函数调用上下文现场。</p>
</li>
<li><p>程序运行栈设计：进入子程序/函数时分配，地址空间向下生长；从子程序/函数返回时，当前运行栈将被废弃；递归调用的同一个子程序/函数，每次调用都应获得独立的运行栈空间。</p>
</li>
<li><p>活动记录：函数返回地址、全局寄存器保存区、临时变量保存区、未分配到全局寄存器的局部变量保存区、其他辅助信息保存区。</p>
</li>
<li><p>寄存器分类：通用寄存器（临时寄存器/全局寄存器）、专用寄存器。</p>
</li>
<li><p>全局寄存器分配：相对于基本块而言，不是对于程序全局。</p>
<p>分配原则：优先分配给跨基本块活跃的变量，尤其是循环体内最活跃变量；局部变量参与全局寄存器分配；为线程安全，全局变量、静态变量不参与全局寄存器分配。</p>
</li>
<li><p>常用全局寄存器分配方法：</p>
<ul>
<li>引用计数：如果一个局部变量被访问次数较多，则获得全局寄存器概率越大；出现在循环尤其是内层嵌套循环中的变量被访问次数应获得一定加权。（但存在不再使用的寄存器不能及时释放寄存器）</li>
<li>图着色算法：通过数据流分析，构建变量的冲突图。如果有 $k$ 个可供分配的寄存器，尝试用 $k$ 种颜色为冲突图着色。一种方法是不断找到连接边数目小于 k 的节点移走；当无法再移走点时，删除合适的点，记录为不分配全局寄存器的变量，并继续重复上述步骤；当只剩余一个节点时，给此节点分配一种颜色，按照节点被移走的顺序，反向添加节点和边并选取颜色。</li>
</ul>
</li>
<li><p>图着色构建变量冲突图：节点是待分配全局寄存器的变量。一个变量在另一个变量的定义/赋值处是活跃的，则这两个变量的节点间有一条边连接（即有边相连的变量无法共用一个全局寄存器）。</p>
</li>
<li><p>临时寄存器的分配：如 <code>$a0</code> 、 <code>$v0</code> 、 <code>$hi</code> 此类寄存器。生成某些指令时必须使用指定寄存器，临时寄存器可能保有此前计算中间结果，因此需要合理使用临时寄存器。使用寄存器池管理分配临时寄存器。</p>
</li>
<li><p>临时寄存器生存范围：不超越基本块，不跨越函数调用。</p>
</li>
<li><p>分配原则：进入基本块时，清空临时寄存器池；如寄存器池中有空闲寄存器，标记该寄存器被占用，并返回该寄存器；反之选取一个不会被马上使用的寄存器写回相应内存空间，并将该寄存器分配给待分配变量；在基本块结束或调用函数前都应该将临时寄存器写回相应内存空间并清空寄存器池。</p>
</li>
</ol>
<h2 id="第十六章-编译程序生成方法和工具"><a href="#第十六章-编译程序生成方法和工具" class="headerlink" title="第十六章 编译程序生成方法和工具"></a>第十六章 编译程序生成方法和工具</h2><ol>
<li>编译程序的书写语言：机器语言或汇编语言、高级程序设计语言。</li>
<li>自编译性：如果一个高级语言可以书写自己的编译程序，则称为自编译语言。</li>
<li>自编译性不是绝对的，只是强弱不同。数据类型、控制结构丰富（适于进行多分支程序设计）的语言自编译性强。</li>
<li>自展：将语言分为多个部分，不断用前若干部分语言编写后若干部分的编译程序。（可提高生产率，核心语言小，可用汇编实现，其余部分高级语言编写）</li>
<li>编译程序的移植：将宿主机软件移植到目标机上。将语言分为两部分（与机器有关与机器无关），使用与机器有关语言改写为目标机有关语言，编译生成在宿主机上运行的语言交叉编译程序（其生成只能在目标机上运行的代码），编译生成在目标机上运行的语言编译程序。</li>
<li>编译程序的自动生成：目前还没有程序能自动生成整个编译系统。</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Mr-MysteryMan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/03/15/Compiler/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">http://example.com/2025/03/15/Compiler/编译原理/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">hahaha</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/review/">review</a></div><div class="post-share"><div class="social-share" data-image="/img/wuhui/8.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/15/OS/Lab6%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/" title="Lab6实验报告"><img class="cover" src="/img/loading.gif" data-original="/img/wuhui/4.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Lab6实验报告</div></div><div class="info-2"><div class="info-item-1">Lab6实验报告思考题Thinking 6.1 更改前的代码： 123456789101112131415161718192021int main()&#123;	switch (fork())     &#123;		case -1:			break;		case 0: /* 子进程 - 作为管道的读者 */			close(fildes[1]); /* 关闭不用的写端 */			read(fildes[0], buf, 100); /* 从管道中读数据 */			printf(&quot;child-process read:%s&quot;,buf); /* 打印读到的数据 */			close(fildes[0]); /* 读取结束，关闭读端 */			exit(EXIT_SUCCESS);		default: /* 父进程 - 作为管道的写者 */			close(fildes[0]); /* 关闭不用的读端 */			write(fildes[1], &quot;Hello world\n&quot;, 12); /* 向管道中写数据...</div></div></div></a><a class="pagination-related" href="/2025/03/15/OS/Challenge-Shell%E4%BB%BB%E5%8A%A1%E6%96%87%E6%A1%A3/" title="Challenge-Shell任务文档"><img class="cover" src="/img/loading.gif" data-original="/img/wuhui/10.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Challenge-Shell任务文档</div></div><div class="info-2"><div class="info-item-1">Challenge-Shell任务文档 实现不带 .b 后缀指令 你需要实现不带 .b 后缀的指令，但仍需兼容带有 .b 后缀的指令，如 ls 与 ls.b 都应能够正确列出当前目录下的文件。  外部指令的执行实际上是在spawn函数中打开可执行的指令文件创建新进程，并将其装载在新建子进程中，运行指令文件中的主程序。实现思路是更改文件打开程序，当文件名对应文件存在时直接打开即可，不存在时文件名末尾加.b再次尝试打开。 在spawn()函数中更改文件打开方式，具体代码如下： 1234567891011121314151617//user/lib/spawn.c spawn()if ((fd = open(prog, O_RDONLY)) &lt; 0) //尝试打开文件&#123;	int len = 0;	char newProg[128];	for (len = 0; len &lt; 128 &amp;&amp; prog[len] != &#x27;\0&#x27;; len++)	&#123;		newProg[len] =...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/03/17/DB/%E6%95%B0%E6%8D%AE%E5%BA%93/" title="数据库知识点整理"><img class="cover" src="/img/loading.gif" data-original="/img/wuhui/6.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-17</div><div class="info-item-2">数据库知识点整理</div></div><div class="info-2"><div class="info-item-1">数据库第一章 概述 文件系统：数据以文件形式保存在外存，存取以记录为单位，程序数据有一定独立性，文件与数据一一对应，数据共享性差冗余度大（存储消耗大，容易造成数据不一致性） 数据库系统：数据集成及共享（核心技术：数据模型、数据独立性）  数据库系统管理特点：全组织的复杂数据结构，数据冗余度小易扩充，数据和程序的独立性、映像功能、统一的数据控制、最小存取单位是数据项  数据库中模型分为两类：概念模型（信息模型）、数据模型（层次、网状、关系模型）。概念模型用于现实世界到信息世界，数据模型以计算机系统的形式对数据建模。  数据模型：抽象和表示现实世界中的是数据和信息。（严格定义的概念集合） 概念模型：基于信息世界主要概念，表达应用中各种语义。  概念模型基本概念：  实体（Entity）：客观存在并可区分的事物；  属性（Attribute）：实体所具有的某一特性；  码（Key）：唯一标识实体的属性集；  域（Domain）：某个/些属性的取值范围（一组具有相同数据类型值的集合）；  实体型（Entity...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Mr-MysteryMan</div><div class="author-info-description">广告位招租</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Mr-MysteryMan"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Mr-MysteryMan" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="mailto:1234567@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">编译原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%AE%BA"><span class="toc-number">1.1.</span> <span class="toc-text">第一章 概论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%96%87%E6%B3%95%E4%B8%8E%E8%AF%AD%E8%A8%80%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.</span> <span class="toc-text">第二章 文法与语言概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">1.3.</span> <span class="toc-text">第三章 词法分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">1.4.</span> <span class="toc-text">第四章 语法分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%AC%A6%E5%8F%B7%E8%A1%A8"><span class="toc-number">1.5.</span> <span class="toc-text">第五章 符号表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">1.6.</span> <span class="toc-text">第六章 运行时存储管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%BA%90%E7%A8%8B%E5%BA%8F%E4%B8%AD%E9%97%B4%E5%BD%A2%E5%BC%8F"><span class="toc-number">1.7.</span> <span class="toc-text">第七章 源程序中间形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">1.8.</span> <span class="toc-text">第八章 错误处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91%E6%8A%80%E6%9C%AF"><span class="toc-number">1.9.</span> <span class="toc-text">第九章 语法制导翻译技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E5%92%8C%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="toc-number">1.10.</span> <span class="toc-text">第十章 语义分析和代码生成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E8%87%AA%E5%8A%A8%E5%8C%96"><span class="toc-number">1.11.</span> <span class="toc-text">第十一章 词法分析自动化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%8F%90%E9%AB%98"><span class="toc-number">1.12.</span> <span class="toc-text">第十二章 语法分析提高</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96"><span class="toc-number">1.13.</span> <span class="toc-text">第十四章 代码优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="toc-number">1.14.</span> <span class="toc-text">第十五章 目标代码生成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0-%E7%BC%96%E8%AF%91%E7%A8%8B%E5%BA%8F%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7"><span class="toc-number">1.15.</span> <span class="toc-text">第十六章 编译程序生成方法和工具</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/17/Compiler/%E7%BC%96%E8%AF%91%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/" title="编译器设计文档"><img src="/img/loading.gif" data-original="/img/wuhui/11.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="编译器设计文档"/></a><div class="content"><a class="title" href="/2025/03/17/Compiler/%E7%BC%96%E8%AF%91%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/" title="编译器设计文档">编译器设计文档</a><time datetime="2025-03-17T14:00:00.000Z" title="发表于 2025-03-17 22:00:00">2025-03-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/17/DB/%E6%95%B0%E6%8D%AE%E5%BA%93/" title="数据库知识点整理"><img src="/img/loading.gif" data-original="/img/wuhui/6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库知识点整理"/></a><div class="content"><a class="title" href="/2025/03/17/DB/%E6%95%B0%E6%8D%AE%E5%BA%93/" title="数据库知识点整理">数据库知识点整理</a><time datetime="2025-03-17T14:00:00.000Z" title="发表于 2025-03-17 22:00:00">2025-03-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/17/OO/2024%E6%98%A5-OO%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/" title="面向对象课程总结"><img src="/img/loading.gif" data-original="/img/wuhui/9.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面向对象课程总结"/></a><div class="content"><a class="title" href="/2025/03/17/OO/2024%E6%98%A5-OO%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/" title="面向对象课程总结">面向对象课程总结</a><time datetime="2025-03-17T08:00:00.000Z" title="发表于 2025-03-17 16:00:00">2025-03-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/17/OO/2024%E6%98%A5-OO%E8%AF%BE%E7%A8%8BUnit4%E6%80%BB%E7%BB%93/" title="面向对象课程Unit4总结"><img src="/img/loading.gif" data-original="/img/wuhui/3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面向对象课程Unit4总结"/></a><div class="content"><a class="title" href="/2025/03/17/OO/2024%E6%98%A5-OO%E8%AF%BE%E7%A8%8BUnit4%E6%80%BB%E7%BB%93/" title="面向对象课程Unit4总结">面向对象课程Unit4总结</a><time datetime="2025-03-17T06:00:00.000Z" title="发表于 2025-03-17 14:00:00">2025-03-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/17/OO/2024%E6%98%A5-OO%E8%AF%BE%E7%A8%8BUnit3%E6%80%BB%E7%BB%93/" title="面向对象课程Unit3总结"><img src="/img/loading.gif" data-original="/img/wuhui/6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面向对象课程Unit3总结"/></a><div class="content"><a class="title" href="/2025/03/17/OO/2024%E6%98%A5-OO%E8%AF%BE%E7%A8%8BUnit3%E6%80%BB%E7%BB%93/" title="面向对象课程Unit3总结">面向对象课程Unit3总结</a><time datetime="2025-03-17T04:00:00.000Z" title="发表于 2025-03-17 12:00:00">2025-03-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Mr-MysteryMan</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="富强,民主,文明,和谐,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>